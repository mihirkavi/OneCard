"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/postgres";
exports.ids = ["vendor-chunks/postgres"];
exports.modules = {

/***/ "(action-browser)/./node_modules/postgres/src/bytes.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst size = 256\nlet buffer = Buffer.allocUnsafe(size)\n\nconst messages = 'BCcDdEFfHPpQSX'.split('').reduce((acc, x) => {\n  const v = x.charCodeAt(0)\n  acc[x] = () => {\n    buffer[0] = v\n    b.i = 5\n    return b\n  }\n  return acc\n}, {})\n\nconst b = Object.assign(reset, messages, {\n  N: String.fromCharCode(0),\n  i: 0,\n  inc(x) {\n    b.i += x\n    return b\n  },\n  str(x) {\n    const length = Buffer.byteLength(x)\n    fit(length)\n    b.i += buffer.write(x, b.i, length, 'utf8')\n    return b\n  },\n  i16(x) {\n    fit(2)\n    buffer.writeUInt16BE(x, b.i)\n    b.i += 2\n    return b\n  },\n  i32(x, i) {\n    if (i || i === 0) {\n      buffer.writeUInt32BE(x, i)\n      return b\n    }\n    fit(4)\n    buffer.writeUInt32BE(x, b.i)\n    b.i += 4\n    return b\n  },\n  z(x) {\n    fit(x)\n    buffer.fill(0, b.i, b.i + x)\n    b.i += x\n    return b\n  },\n  raw(x) {\n    buffer = Buffer.concat([buffer.subarray(0, b.i), x])\n    b.i = buffer.length\n    return b\n  },\n  end(at = 1) {\n    buffer.writeUInt32BE(b.i - at, at)\n    const out = buffer.subarray(0, b.i)\n    b.i = 0\n    buffer = Buffer.allocUnsafe(size)\n    return out\n  }\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (b);\n\nfunction fit(x) {\n  if (buffer.length - b.i < x) {\n    const prev = buffer\n        , length = prev.length\n\n    buffer = Buffer.allocUnsafe(length + (length >> 1) + x)\n    prev.copy(buffer)\n  }\n}\n\nfunction reset() {\n  b.i = 0\n  return b\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvYnl0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxDQUFDOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29uZWNhcmQvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2J5dGVzLmpzP2I3ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc2l6ZSA9IDI1NlxubGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuXG5jb25zdCBtZXNzYWdlcyA9ICdCQ2NEZEVGZkhQcFFTWCcuc3BsaXQoJycpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gIGNvbnN0IHYgPSB4LmNoYXJDb2RlQXQoMClcbiAgYWNjW3hdID0gKCkgPT4ge1xuICAgIGJ1ZmZlclswXSA9IHZcbiAgICBiLmkgPSA1XG4gICAgcmV0dXJuIGJcbiAgfVxuICByZXR1cm4gYWNjXG59LCB7fSlcblxuY29uc3QgYiA9IE9iamVjdC5hc3NpZ24ocmVzZXQsIG1lc3NhZ2VzLCB7XG4gIE46IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksXG4gIGk6IDAsXG4gIGluYyh4KSB7XG4gICAgYi5pICs9IHhcbiAgICByZXR1cm4gYlxuICB9LFxuICBzdHIoeCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHgpXG4gICAgZml0KGxlbmd0aClcbiAgICBiLmkgKz0gYnVmZmVyLndyaXRlKHgsIGIuaSwgbGVuZ3RoLCAndXRmOCcpXG4gICAgcmV0dXJuIGJcbiAgfSxcbiAgaTE2KHgpIHtcbiAgICBmaXQoMilcbiAgICBidWZmZXIud3JpdGVVSW50MTZCRSh4LCBiLmkpXG4gICAgYi5pICs9IDJcbiAgICByZXR1cm4gYlxuICB9LFxuICBpMzIoeCwgaSkge1xuICAgIGlmIChpIHx8IGkgPT09IDApIHtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHgsIGkpXG4gICAgICByZXR1cm4gYlxuICAgIH1cbiAgICBmaXQoNClcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRSh4LCBiLmkpXG4gICAgYi5pICs9IDRcbiAgICByZXR1cm4gYlxuICB9LFxuICB6KHgpIHtcbiAgICBmaXQoeClcbiAgICBidWZmZXIuZmlsbCgwLCBiLmksIGIuaSArIHgpXG4gICAgYi5pICs9IHhcbiAgICByZXR1cm4gYlxuICB9LFxuICByYXcoeCkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlci5zdWJhcnJheSgwLCBiLmkpLCB4XSlcbiAgICBiLmkgPSBidWZmZXIubGVuZ3RoXG4gICAgcmV0dXJuIGJcbiAgfSxcbiAgZW5kKGF0ID0gMSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGIuaSAtIGF0LCBhdClcbiAgICBjb25zdCBvdXQgPSBidWZmZXIuc3ViYXJyYXkoMCwgYi5pKVxuICAgIGIuaSA9IDBcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcbiAgICByZXR1cm4gb3V0XG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IGJcblxuZnVuY3Rpb24gZml0KHgpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggLSBiLmkgPCB4KSB7XG4gICAgY29uc3QgcHJldiA9IGJ1ZmZlclxuICAgICAgICAsIGxlbmd0aCA9IHByZXYubGVuZ3RoXG5cbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoICsgKGxlbmd0aCA+PiAxKSArIHgpXG4gICAgcHJldi5jb3B5KGJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgYi5pID0gMFxuICByZXR1cm4gYlxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/bytes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/bytes.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst size = 256\nlet buffer = Buffer.allocUnsafe(size)\n\nconst messages = 'BCcDdEFfHPpQSX'.split('').reduce((acc, x) => {\n  const v = x.charCodeAt(0)\n  acc[x] = () => {\n    buffer[0] = v\n    b.i = 5\n    return b\n  }\n  return acc\n}, {})\n\nconst b = Object.assign(reset, messages, {\n  N: String.fromCharCode(0),\n  i: 0,\n  inc(x) {\n    b.i += x\n    return b\n  },\n  str(x) {\n    const length = Buffer.byteLength(x)\n    fit(length)\n    b.i += buffer.write(x, b.i, length, 'utf8')\n    return b\n  },\n  i16(x) {\n    fit(2)\n    buffer.writeUInt16BE(x, b.i)\n    b.i += 2\n    return b\n  },\n  i32(x, i) {\n    if (i || i === 0) {\n      buffer.writeUInt32BE(x, i)\n      return b\n    }\n    fit(4)\n    buffer.writeUInt32BE(x, b.i)\n    b.i += 4\n    return b\n  },\n  z(x) {\n    fit(x)\n    buffer.fill(0, b.i, b.i + x)\n    b.i += x\n    return b\n  },\n  raw(x) {\n    buffer = Buffer.concat([buffer.subarray(0, b.i), x])\n    b.i = buffer.length\n    return b\n  },\n  end(at = 1) {\n    buffer.writeUInt32BE(b.i - at, at)\n    const out = buffer.subarray(0, b.i)\n    b.i = 0\n    buffer = Buffer.allocUnsafe(size)\n    return out\n  }\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (b);\n\nfunction fit(x) {\n  if (buffer.length - b.i < x) {\n    const prev = buffer\n        , length = prev.length\n\n    buffer = Buffer.allocUnsafe(length + (length >> 1) + x)\n    prev.copy(buffer)\n  }\n}\n\nfunction reset() {\n  b.i = 0\n  return b\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsQ0FBQzs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmVjYXJkLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzL3NyYy9ieXRlcy5qcz83NTVlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHNpemUgPSAyNTZcbmxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuY29uc3QgbWVzc2FnZXMgPSAnQkNjRGRFRmZIUHBRU1gnLnNwbGl0KCcnKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xuICBjb25zdCB2ID0geC5jaGFyQ29kZUF0KDApXG4gIGFjY1t4XSA9ICgpID0+IHtcbiAgICBidWZmZXJbMF0gPSB2XG4gICAgYi5pID0gNVxuICAgIHJldHVybiBiXG4gIH1cbiAgcmV0dXJuIGFjY1xufSwge30pXG5cbmNvbnN0IGIgPSBPYmplY3QuYXNzaWduKHJlc2V0LCBtZXNzYWdlcywge1xuICBOOiBTdHJpbmcuZnJvbUNoYXJDb2RlKDApLFxuICBpOiAwLFxuICBpbmMoeCkge1xuICAgIGIuaSArPSB4XG4gICAgcmV0dXJuIGJcbiAgfSxcbiAgc3RyKHgpIHtcbiAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh4KVxuICAgIGZpdChsZW5ndGgpXG4gICAgYi5pICs9IGJ1ZmZlci53cml0ZSh4LCBiLmksIGxlbmd0aCwgJ3V0ZjgnKVxuICAgIHJldHVybiBiXG4gIH0sXG4gIGkxNih4KSB7XG4gICAgZml0KDIpXG4gICAgYnVmZmVyLndyaXRlVUludDE2QkUoeCwgYi5pKVxuICAgIGIuaSArPSAyXG4gICAgcmV0dXJuIGJcbiAgfSxcbiAgaTMyKHgsIGkpIHtcbiAgICBpZiAoaSB8fCBpID09PSAwKSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh4LCBpKVxuICAgICAgcmV0dXJuIGJcbiAgICB9XG4gICAgZml0KDQpXG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUoeCwgYi5pKVxuICAgIGIuaSArPSA0XG4gICAgcmV0dXJuIGJcbiAgfSxcbiAgeih4KSB7XG4gICAgZml0KHgpXG4gICAgYnVmZmVyLmZpbGwoMCwgYi5pLCBiLmkgKyB4KVxuICAgIGIuaSArPSB4XG4gICAgcmV0dXJuIGJcbiAgfSxcbiAgcmF3KHgpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIuc3ViYXJyYXkoMCwgYi5pKSwgeF0pXG4gICAgYi5pID0gYnVmZmVyLmxlbmd0aFxuICAgIHJldHVybiBiXG4gIH0sXG4gIGVuZChhdCA9IDEpIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShiLmkgLSBhdCwgYXQpXG4gICAgY29uc3Qgb3V0ID0gYnVmZmVyLnN1YmFycmF5KDAsIGIuaSlcbiAgICBiLmkgPSAwXG4gICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG4gICAgcmV0dXJuIG91dFxuICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBiXG5cbmZ1bmN0aW9uIGZpdCh4KSB7XG4gIGlmIChidWZmZXIubGVuZ3RoIC0gYi5pIDwgeCkge1xuICAgIGNvbnN0IHByZXYgPSBidWZmZXJcbiAgICAgICAgLCBsZW5ndGggPSBwcmV2Lmxlbmd0aFxuXG4gICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCArIChsZW5ndGggPj4gMSkgKyB4KVxuICAgIHByZXYuY29weShidWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGIuaSA9IDBcbiAgcmV0dXJuIGJcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/bytes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/connection.js":
/*!*************************************************!*\
  !*** ./node_modules/postgres/src/connection.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tls */ \"tls\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var perf_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/postgres/src/types.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors.js */ \"(action-browser)/./node_modules/postgres/src/errors.js\");\n/* harmony import */ var _result_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./result.js */ \"(action-browser)/./node_modules/postgres/src/result.js\");\n/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./queue.js */ \"(action-browser)/./node_modules/postgres/src/queue.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./query.js */ \"(action-browser)/./node_modules/postgres/src/query.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./bytes.js */ \"(action-browser)/./node_modules/postgres/src/bytes.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Connection);\n\nlet uid = 1\n\nconst Sync = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().S().end()\n    , Flush = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().H().end()\n    , SSLRequest = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().i32(8).i32(80877103).end(8)\n    , ExecuteUnnamed = Buffer.concat([(0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().E().str(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i32(0).end(), Sync])\n    , DescribeUnnamed = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().D().str('S').str(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end()\n    , noop = () => { /* noop */ }\n\nconst retryRoutines = new Set([\n  'FetchPreparedStatement',\n  'RevalidateCachedQuery',\n  'transformAssignedExpr'\n])\n\nconst errorFields = {\n  83  : 'severity_local',    // S\n  86  : 'severity',          // V\n  67  : 'code',              // C\n  77  : 'message',           // M\n  68  : 'detail',            // D\n  72  : 'hint',              // H\n  80  : 'position',          // P\n  112 : 'internal_position', // p\n  113 : 'internal_query',    // q\n  87  : 'where',             // W\n  115 : 'schema_name',       // s\n  116 : 'table_name',        // t\n  99  : 'column_name',       // c\n  100 : 'data type_name',    // d\n  110 : 'constraint_name',   // n\n  70  : 'file',              // F\n  76  : 'line',              // L\n  82  : 'routine'            // R\n}\n\nfunction Connection(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {\n  const {\n    ssl,\n    max,\n    user,\n    host,\n    port,\n    database,\n    parsers,\n    transform,\n    onnotice,\n    onnotify,\n    onparameter,\n    max_pipeline,\n    keep_alive,\n    backoff,\n    target_session_attrs\n  } = options\n\n  const sent = (0,_queue_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])()\n      , id = uid++\n      , backend = { pid: null, secret: null }\n      , idleTimer = timer(end, options.idle_timeout)\n      , lifeTimer = timer(end, options.max_lifetime)\n      , connectTimer = timer(connectTimedOut, options.connect_timeout)\n\n  let socket = null\n    , cancelMessage\n    , result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]()\n    , incoming = Buffer.alloc(0)\n    , needsTypes = options.fetch_types\n    , backendParameters = {}\n    , statements = {}\n    , statementId = Math.random().toString(36).slice(2)\n    , statementCount = 1\n    , closedDate = 0\n    , remaining = 0\n    , hostIndex = 0\n    , retries = 0\n    , length = 0\n    , delay = 0\n    , rows = 0\n    , serverSignature = null\n    , nextWriteTimer = null\n    , terminated = false\n    , incomings = null\n    , results = null\n    , initial = null\n    , ending = null\n    , stream = null\n    , chunk = null\n    , ended = null\n    , nonce = null\n    , query = null\n    , final = null\n\n  const connection = {\n    queue: queues.closed,\n    idleTimer,\n    connect(query) {\n      initial = query\n      reconnect()\n    },\n    terminate,\n    execute,\n    cancel,\n    end,\n    count: 0,\n    id\n  }\n\n  queues.closed && queues.closed.push(connection)\n\n  return connection\n\n  async function createSocket() {\n    let x\n    try {\n      x = options.socket\n        ? (await Promise.resolve(options.socket(options)))\n        : new net__WEBPACK_IMPORTED_MODULE_0__.Socket()\n    } catch (e) {\n      error(e)\n      return\n    }\n    x.on('error', error)\n    x.on('close', closed)\n    x.on('drain', drain)\n    return x\n  }\n\n  async function cancel({ pid, secret }, resolve, reject) {\n    try {\n      cancelMessage = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().i32(16).i32(80877102).i32(pid).i32(secret).end(16)\n      await connect()\n      socket.once('error', reject)\n      socket.once('close', resolve)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  function execute(q) {\n    if (terminated)\n      return queryError(q, _errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_DESTROYED', options))\n\n    if (q.cancelled)\n      return\n\n    try {\n      q.state = backend\n      query\n        ? sent.push(q)\n        : (query = q, query.active = true)\n\n      build(q)\n      return write(toBuffer(q))\n        && !q.describeFirst\n        && !q.cursorFn\n        && sent.length < max_pipeline\n        && (!q.options.onexecute || q.options.onexecute(connection))\n    } catch (error) {\n      sent.length === 0 && write(Sync)\n      errored(error)\n      return true\n    }\n  }\n\n  function toBuffer(q) {\n    if (q.parameters.length >= 65534)\n      throw _errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('MAX_PARAMETERS_EXCEEDED', 'Max number of parameters (65534) exceeded')\n\n    return q.options.simple\n      ? (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().Q().str(q.statement.string + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end()\n      : q.describeFirst\n        ? Buffer.concat([describe(q), Flush])\n        : q.prepare\n          ? q.prepared\n            ? prepared(q)\n            : Buffer.concat([describe(q), prepared(q)])\n          : unnamed(q)\n  }\n\n  function describe(q) {\n    return Buffer.concat([\n      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),\n      Describe('S', q.statement.name)\n    ])\n  }\n\n  function prepared(q) {\n    return Buffer.concat([\n      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),\n      q.cursorFn\n        ? Execute('', q.cursorRows)\n        : ExecuteUnnamed\n    ])\n  }\n\n  function unnamed(q) {\n    return Buffer.concat([\n      Parse(q.statement.string, q.parameters, q.statement.types),\n      DescribeUnnamed,\n      prepared(q)\n    ])\n  }\n\n  function build(q) {\n    const parameters = []\n        , types = []\n\n    const string = (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.stringify)(q, q.strings[0], q.args[0], parameters, types, options)\n\n    !q.tagged && q.args.forEach(x => (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.handleValue)(x, parameters, types, options))\n\n    q.prepare = options.prepare && ('prepare' in q.options ? q.options.prepare : true)\n    q.string = string\n    q.signature = q.prepare && types + string\n    q.onlyDescribe && (delete statements[q.signature])\n    q.parameters = q.parameters || parameters\n    q.prepared = q.prepare && q.signature in statements\n    q.describeFirst = q.onlyDescribe || (parameters.length && !q.prepared)\n    q.statement = q.prepared\n      ? statements[q.signature]\n      : { string, types, name: q.prepare ? statementId + statementCount++ : '' }\n\n    typeof options.debug === 'function' && options.debug(id, string, parameters, types)\n  }\n\n  function write(x, fn) {\n    chunk = chunk ? Buffer.concat([chunk, x]) : Buffer.from(x)\n    if (fn || chunk.length >= 1024)\n      return nextWrite(fn)\n    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite))\n    return true\n  }\n\n  function nextWrite(fn) {\n    const x = socket.write(chunk, fn)\n    nextWriteTimer !== null && clearImmediate(nextWriteTimer)\n    chunk = nextWriteTimer = null\n    return x\n  }\n\n  function connectTimedOut() {\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECT_TIMEOUT', options, socket))\n    socket.destroy()\n  }\n\n  async function secure() {\n    write(SSLRequest)\n    const canSSL = await new Promise(r => socket.once('data', x => r(x[0] === 83))) // S\n\n    if (!canSSL && ssl === 'prefer')\n      return connected()\n\n    socket.removeAllListeners()\n    socket = tls__WEBPACK_IMPORTED_MODULE_1__.connect({\n      socket,\n      servername: net__WEBPACK_IMPORTED_MODULE_0__.isIP(socket.host) ? undefined : socket.host,\n      ...(ssl === 'require' || ssl === 'allow' || ssl === 'prefer'\n        ? { rejectUnauthorized: false }\n        : ssl === 'verify-full'\n          ? {}\n          : typeof ssl === 'object'\n            ? ssl\n            : {}\n      )\n    })\n    socket.on('secureConnect', connected)\n    socket.on('error', error)\n    socket.on('close', closed)\n    socket.on('drain', drain)\n  }\n\n  /* c8 ignore next 3 */\n  function drain() {\n    !query && onopen(connection)\n  }\n\n  function data(x) {\n    if (incomings) {\n      incomings.push(x)\n      remaining -= x.length\n      if (remaining >= 0)\n        return\n    }\n\n    incoming = incomings\n      ? Buffer.concat(incomings, length - remaining)\n      : incoming.length === 0\n        ? x\n        : Buffer.concat([incoming, x], incoming.length + x.length)\n\n    while (incoming.length > 4) {\n      length = incoming.readUInt32BE(1)\n      if (length >= incoming.length) {\n        remaining = length - incoming.length\n        incomings = [incoming]\n        break\n      }\n\n      try {\n        handle(incoming.subarray(0, length + 1))\n      } catch (e) {\n        query && (query.cursorFn || query.describeFirst) && write(Sync)\n        errored(e)\n      }\n      incoming = incoming.subarray(length + 1)\n      remaining = 0\n      incomings = null\n    }\n  }\n\n  async function connect() {\n    terminated = false\n    backendParameters = {}\n    socket || (socket = await createSocket())\n\n    if (!socket)\n      return\n\n    connectTimer.start()\n\n    if (options.socket)\n      return ssl ? secure() : connected()\n\n    socket.on('connect', ssl ? secure : connected)\n\n    if (options.path)\n      return socket.connect(options.path)\n\n    socket.ssl = ssl\n    socket.connect(port[hostIndex], host[hostIndex])\n    socket.host = host[hostIndex]\n    socket.port = port[hostIndex]\n\n    hostIndex = (hostIndex + 1) % port.length\n  }\n\n  function reconnect() {\n    setTimeout(connect, closedDate ? closedDate + delay - perf_hooks__WEBPACK_IMPORTED_MODULE_4__.performance.now() : 0)\n  }\n\n  function connected() {\n    try {\n      statements = {}\n      needsTypes = options.fetch_types\n      statementId = Math.random().toString(36).slice(2)\n      statementCount = 1\n      lifeTimer.start()\n      socket.on('data', data)\n      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive)\n      const s = StartupMessage()\n      write(s)\n    } catch (err) {\n      error(err)\n    }\n  }\n\n  function error(err) {\n    if (connection.queue === queues.connecting && options.host[retries + 1])\n      return\n\n    errored(err)\n    while (sent.length)\n      queryError(sent.shift(), err)\n  }\n\n  function errored(err) {\n    stream && (stream.destroy(err), stream = null)\n    query && queryError(query, err)\n    initial && (queryError(initial, err), initial = null)\n  }\n\n  function queryError(query, err) {\n    query.reject(Object.create(err, {\n      stack: { value: err.stack + query.origin.replace(/.*\\n/, '\\n'), enumerable: options.debug },\n      query: { value: query.string, enumerable: options.debug },\n      parameters: { value: query.parameters, enumerable: options.debug },\n      args: { value: query.args, enumerable: options.debug },\n      types: { value: query.statement && query.statement.types, enumerable: options.debug }\n    }))\n  }\n\n  function end() {\n    return ending || (\n      !connection.reserved && onend(connection),\n      !connection.reserved && !initial && !query && sent.length === 0\n        ? (terminate(), new Promise(r => socket && socket.readyState !== 'closed' ? socket.once('close', r) : r()))\n        : ending = new Promise(r => ended = r)\n    )\n  }\n\n  function terminate() {\n    terminated = true\n    if (stream || query || initial || sent.length)\n      error(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_DESTROYED', options))\n\n    clearImmediate(nextWriteTimer)\n    if (socket) {\n      socket.removeListener('data', data)\n      socket.removeListener('connect', connected)\n      socket.readyState === 'open' && socket.end((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().X().end())\n    }\n    ended && (ended(), ending = ended = null)\n  }\n\n  async function closed(hadError) {\n    incoming = Buffer.alloc(0)\n    remaining = 0\n    incomings = null\n    clearImmediate(nextWriteTimer)\n    socket.removeListener('data', data)\n    socket.removeListener('connect', connected)\n    idleTimer.cancel()\n    lifeTimer.cancel()\n    connectTimer.cancel()\n\n    if (socket.encrypted) {\n      socket.removeAllListeners()\n      socket = null\n    }\n\n    if (initial)\n      return reconnect()\n\n    !hadError && (query || sent.length) && error(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_CLOSED', options, socket))\n    closedDate = perf_hooks__WEBPACK_IMPORTED_MODULE_4__.performance.now()\n    hadError && options.shared.retries++\n    delay = (typeof backoff === 'function' ? backoff(options.shared.retries) : backoff) * 1000\n    onclose(connection)\n  }\n\n  /* Handlers */\n  function handle(xs, x = xs[0]) {\n    (\n      x === 68 ? DataRow :                   // D\n      x === 100 ? CopyData :                 // d\n      x === 65 ? NotificationResponse :      // A\n      x === 83 ? ParameterStatus :           // S\n      x === 90 ? ReadyForQuery :             // Z\n      x === 67 ? CommandComplete :           // C\n      x === 50 ? BindComplete :              // 2\n      x === 49 ? ParseComplete :             // 1\n      x === 116 ? ParameterDescription :     // t\n      x === 84 ? RowDescription :            // T\n      x === 82 ? Authentication :            // R\n      x === 110 ? NoData :                   // n\n      x === 75 ? BackendKeyData :            // K\n      x === 69 ? ErrorResponse :             // E\n      x === 115 ? PortalSuspended :          // s\n      x === 51 ? CloseComplete :             // 3\n      x === 71 ? CopyInResponse :            // G\n      x === 78 ? NoticeResponse :            // N\n      x === 72 ? CopyOutResponse :           // H\n      x === 99 ? CopyDone :                  // c\n      x === 73 ? EmptyQueryResponse :        // I\n      x === 86 ? FunctionCallResponse :      // V\n      x === 118 ? NegotiateProtocolVersion : // v\n      x === 87 ? CopyBothResponse :          // W\n      /* c8 ignore next */\n      UnknownMessage\n    )(xs)\n  }\n\n  function DataRow(x) {\n    let index = 7\n    let length\n    let column\n    let value\n\n    const row = query.isRaw ? new Array(query.statement.columns.length) : {}\n    for (let i = 0; i < query.statement.columns.length; i++) {\n      column = query.statement.columns[i]\n      length = x.readInt32BE(index)\n      index += 4\n\n      value = length === -1\n        ? null\n        : query.isRaw === true\n          ? x.subarray(index, index += length)\n          : column.parser === undefined\n            ? x.toString('utf8', index, index += length)\n            : column.parser.array === true\n              ? column.parser(x.toString('utf8', index + 1, index += length))\n              : column.parser(x.toString('utf8', index, index += length))\n\n      query.isRaw\n        ? (row[i] = query.isRaw === true\n          ? value\n          : transform.value.from ? transform.value.from(value, column) : value)\n        : (row[column.name] = transform.value.from ? transform.value.from(value, column) : value)\n    }\n\n    query.forEachFn\n      ? query.forEachFn(transform.row.from ? transform.row.from(row) : row, result)\n      : (result[rows++] = transform.row.from ? transform.row.from(row) : row)\n  }\n\n  function ParameterStatus(x) {\n    const [k, v] = x.toString('utf8', 5, x.length - 1).split(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N)\n    backendParameters[k] = v\n    if (options.parameters[k] !== v) {\n      options.parameters[k] = v\n      onparameter && onparameter(k, v)\n    }\n  }\n\n  function ReadyForQuery(x) {\n    query && query.options.simple && query.resolve(results || result)\n    query = results = null\n    result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]()\n    connectTimer.cancel()\n\n    if (initial) {\n      if (target_session_attrs) {\n        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)\n          return fetchState()\n        else if (tryNext(target_session_attrs, backendParameters))\n          return terminate()\n      }\n\n      if (needsTypes)\n        return fetchArrayTypes()\n\n      execute(initial)\n      options.shared.retries = retries = initial = 0\n      return\n    }\n\n    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))\n      Connection(options).cancel(query.state, query.cancelled.resolve, query.cancelled.reject)\n\n    if (query)\n      return // Consider opening if able and sent.length < 50\n\n    connection.reserved\n      ? !connection.reserved.release && x[5] === 73 // I\n        ? ending\n          ? terminate()\n          : (connection.reserved = null, onopen(connection))\n        : connection.reserved()\n      : ending\n        ? terminate()\n        : onopen(connection)\n  }\n\n  function CommandComplete(x) {\n    rows = 0\n\n    for (let i = x.length - 1; i > 0; i--) {\n      if (x[i] === 32 && x[i + 1] < 58 && result.count === null)\n        result.count = +x.toString('utf8', i + 1, x.length - 1)\n      if (x[i - 1] >= 65) {\n        result.command = x.toString('utf8', 5, i)\n        result.state = backend\n        break\n      }\n    }\n\n    final && (final(), final = null)\n\n    if (result.command === 'BEGIN' && max !== 1 && !connection.reserved)\n      return errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('UNSAFE_TRANSACTION', 'Only use sql.begin, sql.reserved or max: 1'))\n\n    if (query.options.simple)\n      return BindComplete()\n\n    if (query.cursorFn) {\n      result.count && query.cursorFn(result)\n      write(Sync)\n    }\n\n    query.resolve(result)\n  }\n\n  function ParseComplete() {\n    query.parsing = false\n  }\n\n  function BindComplete() {\n    !result.statement && (result.statement = query.statement)\n    result.columns = query.statement.columns\n  }\n\n  function ParameterDescription(x) {\n    const length = x.readUInt16BE(5)\n\n    for (let i = 0; i < length; ++i)\n      !query.statement.types[i] && (query.statement.types[i] = x.readUInt32BE(7 + i * 4))\n\n    query.prepare && (statements[query.signature] = query.statement)\n    query.describeFirst && !query.onlyDescribe && (write(prepared(query)), query.describeFirst = false)\n  }\n\n  function RowDescription(x) {\n    if (result.command) {\n      results = results || [result]\n      results.push(result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]())\n      result.count = null\n      query.statement.columns = null\n    }\n\n    const length = x.readUInt16BE(5)\n    let index = 7\n    let start\n\n    query.statement.columns = Array(length)\n\n    for (let i = 0; i < length; ++i) {\n      start = index\n      while (x[index++] !== 0);\n      const table = x.readUInt32BE(index)\n      const number = x.readUInt16BE(index + 4)\n      const type = x.readUInt32BE(index + 6)\n      query.statement.columns[i] = {\n        name: transform.column.from\n          ? transform.column.from(x.toString('utf8', start, index - 1))\n          : x.toString('utf8', start, index - 1),\n        parser: parsers[type],\n        table,\n        number,\n        type\n      }\n      index += 18\n    }\n\n    result.statement = query.statement\n    if (query.onlyDescribe)\n      return (query.resolve(query.statement), write(Sync))\n  }\n\n  async function Authentication(x, type = x.readUInt32BE(5)) {\n    (\n      type === 3 ? AuthenticationCleartextPassword :\n      type === 5 ? AuthenticationMD5Password :\n      type === 10 ? SASL :\n      type === 11 ? SASLContinue :\n      type === 12 ? SASLFinal :\n      type !== 0 ? UnknownAuth :\n      noop\n    )(x, type)\n  }\n\n  /* c8 ignore next 5 */\n  async function AuthenticationCleartextPassword() {\n    write(\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str(await Pass()).z(1).end()\n    )\n  }\n\n  async function AuthenticationMD5Password(x) {\n    write(\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str(\n        'md5' +\n        (await md5(Buffer.concat([\n          Buffer.from(await md5((await Pass()) + user)),\n          x.subarray(9)\n        ])))\n      ).z(1).end()\n    )\n  }\n\n  async function SASL() {\n    (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str('SCRAM-SHA-256' + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N)\n    const i = _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i\n    nonce = (await crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes(18)).toString('base64')\n    write(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].inc(4).str('n,,n=*,r=' + nonce).i32(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i - i - 4, i).end())\n  }\n\n  async function SASLContinue(x) {\n    const res = x.toString('utf8', 9).split(',').reduce((acc, x) => (acc[x[0]] = x.slice(2), acc), {})\n\n    const saltedPassword = await crypto__WEBPACK_IMPORTED_MODULE_2__.pbkdf2Sync(\n      await Pass(),\n      Buffer.from(res.s, 'base64'),\n      parseInt(res.i), 32,\n      'sha256'\n    )\n\n    const clientKey = await hmac(saltedPassword, 'Client Key')\n\n    const auth = 'n=*,r=' + nonce + ','\n               + 'r=' + res.r + ',s=' + res.s + ',i=' + res.i\n               + ',c=biws,r=' + res.r\n\n    serverSignature = (await hmac(await hmac(saltedPassword, 'Server Key'), auth)).toString('base64')\n\n    write(\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str(\n        'c=biws,r=' + res.r + ',p=' + xor(\n          clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))\n        ).toString('base64')\n      ).end()\n    )\n  }\n\n  function SASLFinal(x) {\n    if (x.toString('utf8', 9).split(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N, 1)[0].slice(2) === serverSignature)\n      return\n    /* c8 ignore next 5 */\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('SASL_SIGNATURE_MISMATCH', 'The server did not return the correct signature'))\n    socket.destroy()\n  }\n\n  function Pass() {\n    return Promise.resolve(typeof options.pass === 'function'\n      ? options.pass()\n      : options.pass\n    )\n  }\n\n  function NoData() {\n    result.statement = query.statement\n    result.statement.columns = []\n    if (query.onlyDescribe)\n      return (query.resolve(query.statement), write(Sync))\n  }\n\n  function BackendKeyData(x) {\n    backend.pid = x.readUInt32BE(5)\n    backend.secret = x.readUInt32BE(9)\n  }\n\n  async function fetchArrayTypes() {\n    needsTypes = false\n    const types = await new _query_js__WEBPACK_IMPORTED_MODULE_9__.Query([`\n      select b.oid, b.typarray\n      from pg_catalog.pg_type a\n      left join pg_catalog.pg_type b on b.oid = a.typelem\n      where a.typcategory = 'A'\n      group by b.oid, b.typarray\n      order by b.oid\n    `], [], execute)\n    types.forEach(({ oid, typarray }) => addArrayType(oid, typarray))\n  }\n\n  function addArrayType(oid, typarray) {\n    if (!!options.parsers[typarray] && !!options.serializers[typarray]) return\n    const parser = options.parsers[oid]\n    options.shared.typeArrayMap[oid] = typarray\n    options.parsers[typarray] = (xs) => (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.arrayParser)(xs, parser, typarray)\n    options.parsers[typarray].array = true\n    options.serializers[typarray] = (xs) => (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.arraySerializer)(xs, options.serializers[oid], options, typarray)\n  }\n\n  function tryNext(x, xs) {\n    return (\n      (x === 'read-write' && xs.default_transaction_read_only === 'on') ||\n      (x === 'read-only' && xs.default_transaction_read_only === 'off') ||\n      (x === 'primary' && xs.in_hot_standby === 'on') ||\n      (x === 'standby' && xs.in_hot_standby === 'off') ||\n      (x === 'prefer-standby' && xs.in_hot_standby === 'off' && options.host[retries])\n    )\n  }\n\n  function fetchState() {\n    const query = new _query_js__WEBPACK_IMPORTED_MODULE_9__.Query([`\n      show transaction_read_only;\n      select pg_catalog.pg_is_in_recovery()\n    `], [], execute, null, { simple: true })\n    query.resolve = ([[a], [b]]) => {\n      backendParameters.default_transaction_read_only = a.transaction_read_only\n      backendParameters.in_hot_standby = b.pg_is_in_recovery ? 'on' : 'off'\n    }\n    query.execute()\n  }\n\n  function ErrorResponse(x) {\n    query && (query.cursorFn || query.describeFirst) && write(Sync)\n    const error = _errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.postgres(parseError(x))\n    query && query.retried\n      ? errored(query.retried)\n      : query && retryRoutines.has(error.routine)\n        ? retry(query, error)\n        : errored(error)\n  }\n\n  function retry(q, error) {\n    delete statements[q.signature]\n    q.retried = error\n    execute(q)\n  }\n\n  function NotificationResponse(x) {\n    if (!onnotify)\n      return\n\n    let index = 9\n    while (x[index++] !== 0);\n    onnotify(\n      x.toString('utf8', 9, index - 1),\n      x.toString('utf8', index, x.length - 1)\n    )\n  }\n\n  async function PortalSuspended() {\n    try {\n      const x = await Promise.resolve(query.cursorFn(result))\n      rows = 0\n      x === _query_js__WEBPACK_IMPORTED_MODULE_9__.CLOSE\n        ? write(Close(query.portal))\n        : (result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](), write(Execute('', query.cursorRows)))\n    } catch (err) {\n      write(Sync)\n      query.reject(err)\n    }\n  }\n\n  function CloseComplete() {\n    result.count && query.cursorFn(result)\n    query.resolve(result)\n  }\n\n  function CopyInResponse() {\n    stream = new stream__WEBPACK_IMPORTED_MODULE_3__.Writable({\n      autoDestroy: true,\n      write(chunk, encoding, callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().d().raw(chunk).end(), callback)\n      },\n      destroy(error, callback) {\n        callback(error)\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().f().str(error + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end())\n        stream = null\n      },\n      final(callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().c().end())\n        final = callback\n      }\n    })\n    query.resolve(stream)\n  }\n\n  function CopyOutResponse() {\n    stream = new stream__WEBPACK_IMPORTED_MODULE_3__.Readable({\n      read() { socket.resume() }\n    })\n    query.resolve(stream)\n  }\n\n  /* c8 ignore next 3 */\n  function CopyBothResponse() {\n    stream = new stream__WEBPACK_IMPORTED_MODULE_3__.Duplex({\n      autoDestroy: true,\n      read() { socket.resume() },\n      /* c8 ignore next 11 */\n      write(chunk, encoding, callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().d().raw(chunk).end(), callback)\n      },\n      destroy(error, callback) {\n        callback(error)\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().f().str(error + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end())\n        stream = null\n      },\n      final(callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().c().end())\n        final = callback\n      }\n    })\n    query.resolve(stream)\n  }\n\n  function CopyData(x) {\n    stream && (stream.push(x.subarray(5)) || socket.pause())\n  }\n\n  function CopyDone() {\n    stream && stream.push(null)\n    stream = null\n  }\n\n  function NoticeResponse(x) {\n    onnotice\n      ? onnotice(parseError(x))\n      : console.log(parseError(x)) // eslint-disable-line\n\n  }\n\n  /* c8 ignore next 3 */\n  function EmptyQueryResponse() {\n    /* noop */\n  }\n\n  /* c8 ignore next 3 */\n  function FunctionCallResponse() {\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.notSupported('FunctionCallResponse'))\n  }\n\n  /* c8 ignore next 3 */\n  function NegotiateProtocolVersion() {\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.notSupported('NegotiateProtocolVersion'))\n  }\n\n  /* c8 ignore next 3 */\n  function UnknownMessage(x) {\n    console.error('Postgres.js : Unknown Message:', x[0]) // eslint-disable-line\n  }\n\n  /* c8 ignore next 3 */\n  function UnknownAuth(x, type) {\n    console.error('Postgres.js : Unknown Auth:', type) // eslint-disable-line\n  }\n\n  /* Messages */\n  function Bind(parameters, types, statement = '', portal = '') {\n    let prev\n      , type\n\n    ;(0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().B().str(portal + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).str(statement + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i16(0).i16(parameters.length)\n\n    parameters.forEach((x, i) => {\n      if (x === null)\n        return _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i32(0xFFFFFFFF)\n\n      type = types[i]\n      parameters[i] = x = type in options.serializers\n        ? options.serializers[type](x)\n        : '' + x\n\n      prev = _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i\n      _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].inc(4).str(x).i32(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i - prev - 4, prev)\n    })\n\n    _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i16(0)\n\n    return _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].end()\n  }\n\n  function Parse(str, parameters, types, name = '') {\n    (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().P().str(name + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).str(str + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i16(parameters.length)\n    parameters.forEach((x, i) => _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i32(types[i] || 0))\n    return _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].end()\n  }\n\n  function Describe(x, name = '') {\n    return (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().D().str(x).str(name + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end()\n  }\n\n  function Execute(portal = '', rows = 0) {\n    return Buffer.concat([\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().E().str(portal + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i32(rows).end(),\n      Flush\n    ])\n  }\n\n  function Close(portal = '') {\n    return Buffer.concat([\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().C().str('P').str(portal + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end(),\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().S().end()\n    ])\n  }\n\n  function StartupMessage() {\n    return cancelMessage || (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().inc(4).i16(3).z(2).str(\n      Object.entries(Object.assign({\n        user,\n        database,\n        client_encoding: 'UTF8'\n      },\n        options.connection\n      )).filter(([, v]) => v).map(([k, v]) => k + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N + v).join(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N)\n    ).z(2).end(0)\n  }\n\n}\n\nfunction parseError(x) {\n  const error = {}\n  let start = 5\n  for (let i = 5; i < x.length - 1; i++) {\n    if (x[i] === 0) {\n      error[errorFields[x[start]]] = x.toString('utf8', start + 1, i)\n      start = i + 1\n    }\n  }\n  return error\n}\n\nfunction md5(x) {\n  return crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('md5').update(x).digest('hex')\n}\n\nfunction hmac(key, x) {\n  return crypto__WEBPACK_IMPORTED_MODULE_2__.createHmac('sha256', key).update(x).digest()\n}\n\nfunction sha256(x) {\n  return crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('sha256').update(x).digest()\n}\n\nfunction xor(a, b) {\n  const length = Math.max(a.length, b.length)\n  const buffer = Buffer.allocUnsafe(length)\n  for (let i = 0; i < length; i++)\n    buffer[i] = a[i] ^ b[i]\n  return buffer\n}\n\nfunction timer(fn, seconds) {\n  seconds = typeof seconds === 'function' ? seconds() : seconds\n  if (!seconds)\n    return { cancel: noop, start: noop }\n\n  let timer\n  return {\n    cancel() {\n      timer && (clearTimeout(timer), timer = null)\n    },\n    start() {\n      timer && clearTimeout(timer)\n      timer = setTimeout(done, seconds * 1000, arguments)\n    }\n  }\n\n  function done(args) {\n    fn.apply(null, args)\n    timer = null\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBcUI7QUFDQTtBQUNNO0FBQ0E7QUFDYTs7QUFFeUM7QUFDN0M7QUFDSjtBQUNGO0FBQ1c7QUFDZjs7QUFFMUIsaUVBQWUsVUFBVTs7QUFFekI7O0FBRUEsYUFBYSxzREFBQztBQUNkLGNBQWMsc0RBQUM7QUFDZixtQkFBbUIsc0RBQUM7QUFDcEIsc0NBQXNDLHNEQUFDLFdBQVcsb0RBQUc7QUFDckQsd0JBQXdCLHNEQUFDLG9CQUFvQixvREFBRztBQUNoRCxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsSUFBSSw4Q0FBOEMsSUFBSTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosZUFBZSxxREFBSztBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1Q0FBVTtBQUN4QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBLHNCQUFzQixzREFBQztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQU07O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBTTs7QUFFbEI7QUFDQSxRQUFRLHNEQUFDLGdDQUFnQyxvREFBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0RBQVM7O0FBRTVCLHFDQUFxQyxzREFBVzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksOENBQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsd0NBQVc7QUFDeEI7QUFDQSxrQkFBa0IscUNBQVE7QUFDMUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxtREFBVztBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxrRkFBa0Y7QUFDakcsZUFBZSxnREFBZ0Q7QUFDL0Qsb0JBQW9CLG9EQUFvRDtBQUN4RSxjQUFjLDhDQUE4QztBQUM1RCxlQUFlO0FBQ2YsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBTTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQUM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELDhDQUFNO0FBQ3ZELGlCQUFpQixtREFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxvREFBRztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFNO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQiw4Q0FBTTs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQU07QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0RBQUM7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHNEQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksc0RBQUMsNkJBQTZCLG9EQUFHO0FBQ3JDLGNBQWMsb0RBQUc7QUFDakIsbUJBQW1CLCtDQUFrQjtBQUNyQyxVQUFVLHNEQUFLLGlDQUFpQyxvREFBRztBQUNuRDs7QUFFQTtBQUNBLHFHQUFxRzs7QUFFckcsaUNBQWlDLDhDQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sc0RBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msb0RBQUc7QUFDdkM7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzREFBVztBQUNuRDtBQUNBLDRDQUE0QywwREFBZTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNENBQUs7QUFDM0I7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQUs7QUFDakI7QUFDQSx3QkFBd0Isa0RBQU07QUFDOUIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDRDQUFlO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUM7QUFDdEIsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUMsbUJBQW1CLG9EQUFHO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUJBQXFCLHNEQUFDO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0Q0FBZTtBQUNoQyxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBYTtBQUM5QjtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUM7QUFDdEIsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUMsbUJBQW1CLG9EQUFHO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUJBQXFCLHNEQUFDO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSx1REFBQyxvQkFBb0Isb0RBQUcsa0JBQWtCLG9EQUFHOztBQUVqRDtBQUNBO0FBQ0EsZUFBZSxzREFBSzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxvREFBRztBQUNoQixNQUFNLHNEQUFLLGVBQWUsb0RBQUc7QUFDN0IsS0FBSzs7QUFFTCxJQUFJLHNEQUFLOztBQUVULFdBQVcsc0RBQUs7QUFDaEI7O0FBRUE7QUFDQSxJQUFJLHNEQUFDLGtCQUFrQixvREFBRyxZQUFZLG9EQUFHO0FBQ3pDLGlDQUFpQyxzREFBSztBQUN0QyxXQUFXLHNEQUFLO0FBQ2hCOztBQUVBO0FBQ0EsV0FBVyxzREFBQyx5QkFBeUIsb0RBQUc7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLE1BQU0sc0RBQUMsb0JBQW9CLG9EQUFHO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzREFBQyw2QkFBNkIsb0RBQUc7QUFDdkMsTUFBTSxzREFBQztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsc0RBQUM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrREFBa0Qsb0RBQUcsV0FBVyxvREFBRztBQUNuRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDhDQUFpQjtBQUMxQjs7QUFFQTtBQUNBLFNBQVMsOENBQWlCO0FBQzFCOztBQUVBO0FBQ0EsU0FBUyw4Q0FBaUI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvY29ubmVjdGlvbi5qcz84MWNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuZXQgZnJvbSAnbmV0J1xuaW1wb3J0IHRscyBmcm9tICd0bHMnXG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0bydcbmltcG9ydCBTdHJlYW0gZnJvbSAnc3RyZWFtJ1xuaW1wb3J0IHsgcGVyZm9ybWFuY2UgfSBmcm9tICdwZXJmX2hvb2tzJ1xuXG5pbXBvcnQgeyBzdHJpbmdpZnksIGhhbmRsZVZhbHVlLCBhcnJheVBhcnNlciwgYXJyYXlTZXJpYWxpemVyIH0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gJy4vZXJyb3JzLmpzJ1xuaW1wb3J0IFJlc3VsdCBmcm9tICcuL3Jlc3VsdC5qcydcbmltcG9ydCBRdWV1ZSBmcm9tICcuL3F1ZXVlLmpzJ1xuaW1wb3J0IHsgUXVlcnksIENMT1NFIH0gZnJvbSAnLi9xdWVyeS5qcydcbmltcG9ydCBiIGZyb20gJy4vYnl0ZXMuanMnXG5cbmV4cG9ydCBkZWZhdWx0IENvbm5lY3Rpb25cblxubGV0IHVpZCA9IDFcblxuY29uc3QgU3luYyA9IGIoKS5TKCkuZW5kKClcbiAgICAsIEZsdXNoID0gYigpLkgoKS5lbmQoKVxuICAgICwgU1NMUmVxdWVzdCA9IGIoKS5pMzIoOCkuaTMyKDgwODc3MTAzKS5lbmQoOClcbiAgICAsIEV4ZWN1dGVVbm5hbWVkID0gQnVmZmVyLmNvbmNhdChbYigpLkUoKS5zdHIoYi5OKS5pMzIoMCkuZW5kKCksIFN5bmNdKVxuICAgICwgRGVzY3JpYmVVbm5hbWVkID0gYigpLkQoKS5zdHIoJ1MnKS5zdHIoYi5OKS5lbmQoKVxuICAgICwgbm9vcCA9ICgpID0+IHsgLyogbm9vcCAqLyB9XG5cbmNvbnN0IHJldHJ5Um91dGluZXMgPSBuZXcgU2V0KFtcbiAgJ0ZldGNoUHJlcGFyZWRTdGF0ZW1lbnQnLFxuICAnUmV2YWxpZGF0ZUNhY2hlZFF1ZXJ5JyxcbiAgJ3RyYW5zZm9ybUFzc2lnbmVkRXhwcidcbl0pXG5cbmNvbnN0IGVycm9yRmllbGRzID0ge1xuICA4MyAgOiAnc2V2ZXJpdHlfbG9jYWwnLCAgICAvLyBTXG4gIDg2ICA6ICdzZXZlcml0eScsICAgICAgICAgIC8vIFZcbiAgNjcgIDogJ2NvZGUnLCAgICAgICAgICAgICAgLy8gQ1xuICA3NyAgOiAnbWVzc2FnZScsICAgICAgICAgICAvLyBNXG4gIDY4ICA6ICdkZXRhaWwnLCAgICAgICAgICAgIC8vIERcbiAgNzIgIDogJ2hpbnQnLCAgICAgICAgICAgICAgLy8gSFxuICA4MCAgOiAncG9zaXRpb24nLCAgICAgICAgICAvLyBQXG4gIDExMiA6ICdpbnRlcm5hbF9wb3NpdGlvbicsIC8vIHBcbiAgMTEzIDogJ2ludGVybmFsX3F1ZXJ5JywgICAgLy8gcVxuICA4NyAgOiAnd2hlcmUnLCAgICAgICAgICAgICAvLyBXXG4gIDExNSA6ICdzY2hlbWFfbmFtZScsICAgICAgIC8vIHNcbiAgMTE2IDogJ3RhYmxlX25hbWUnLCAgICAgICAgLy8gdFxuICA5OSAgOiAnY29sdW1uX25hbWUnLCAgICAgICAvLyBjXG4gIDEwMCA6ICdkYXRhIHR5cGVfbmFtZScsICAgIC8vIGRcbiAgMTEwIDogJ2NvbnN0cmFpbnRfbmFtZScsICAgLy8gblxuICA3MCAgOiAnZmlsZScsICAgICAgICAgICAgICAvLyBGXG4gIDc2ICA6ICdsaW5lJywgICAgICAgICAgICAgIC8vIExcbiAgODIgIDogJ3JvdXRpbmUnICAgICAgICAgICAgLy8gUlxufVxuXG5mdW5jdGlvbiBDb25uZWN0aW9uKG9wdGlvbnMsIHF1ZXVlcyA9IHt9LCB7IG9ub3BlbiA9IG5vb3AsIG9uZW5kID0gbm9vcCwgb25jbG9zZSA9IG5vb3AgfSA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzc2wsXG4gICAgbWF4LFxuICAgIHVzZXIsXG4gICAgaG9zdCxcbiAgICBwb3J0LFxuICAgIGRhdGFiYXNlLFxuICAgIHBhcnNlcnMsXG4gICAgdHJhbnNmb3JtLFxuICAgIG9ubm90aWNlLFxuICAgIG9ubm90aWZ5LFxuICAgIG9ucGFyYW1ldGVyLFxuICAgIG1heF9waXBlbGluZSxcbiAgICBrZWVwX2FsaXZlLFxuICAgIGJhY2tvZmYsXG4gICAgdGFyZ2V0X3Nlc3Npb25fYXR0cnNcbiAgfSA9IG9wdGlvbnNcblxuICBjb25zdCBzZW50ID0gUXVldWUoKVxuICAgICAgLCBpZCA9IHVpZCsrXG4gICAgICAsIGJhY2tlbmQgPSB7IHBpZDogbnVsbCwgc2VjcmV0OiBudWxsIH1cbiAgICAgICwgaWRsZVRpbWVyID0gdGltZXIoZW5kLCBvcHRpb25zLmlkbGVfdGltZW91dClcbiAgICAgICwgbGlmZVRpbWVyID0gdGltZXIoZW5kLCBvcHRpb25zLm1heF9saWZldGltZSlcbiAgICAgICwgY29ubmVjdFRpbWVyID0gdGltZXIoY29ubmVjdFRpbWVkT3V0LCBvcHRpb25zLmNvbm5lY3RfdGltZW91dClcblxuICBsZXQgc29ja2V0ID0gbnVsbFxuICAgICwgY2FuY2VsTWVzc2FnZVxuICAgICwgcmVzdWx0ID0gbmV3IFJlc3VsdCgpXG4gICAgLCBpbmNvbWluZyA9IEJ1ZmZlci5hbGxvYygwKVxuICAgICwgbmVlZHNUeXBlcyA9IG9wdGlvbnMuZmV0Y2hfdHlwZXNcbiAgICAsIGJhY2tlbmRQYXJhbWV0ZXJzID0ge31cbiAgICAsIHN0YXRlbWVudHMgPSB7fVxuICAgICwgc3RhdGVtZW50SWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKVxuICAgICwgc3RhdGVtZW50Q291bnQgPSAxXG4gICAgLCBjbG9zZWREYXRlID0gMFxuICAgICwgcmVtYWluaW5nID0gMFxuICAgICwgaG9zdEluZGV4ID0gMFxuICAgICwgcmV0cmllcyA9IDBcbiAgICAsIGxlbmd0aCA9IDBcbiAgICAsIGRlbGF5ID0gMFxuICAgICwgcm93cyA9IDBcbiAgICAsIHNlcnZlclNpZ25hdHVyZSA9IG51bGxcbiAgICAsIG5leHRXcml0ZVRpbWVyID0gbnVsbFxuICAgICwgdGVybWluYXRlZCA9IGZhbHNlXG4gICAgLCBpbmNvbWluZ3MgPSBudWxsXG4gICAgLCByZXN1bHRzID0gbnVsbFxuICAgICwgaW5pdGlhbCA9IG51bGxcbiAgICAsIGVuZGluZyA9IG51bGxcbiAgICAsIHN0cmVhbSA9IG51bGxcbiAgICAsIGNodW5rID0gbnVsbFxuICAgICwgZW5kZWQgPSBudWxsXG4gICAgLCBub25jZSA9IG51bGxcbiAgICAsIHF1ZXJ5ID0gbnVsbFxuICAgICwgZmluYWwgPSBudWxsXG5cbiAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICBxdWV1ZTogcXVldWVzLmNsb3NlZCxcbiAgICBpZGxlVGltZXIsXG4gICAgY29ubmVjdChxdWVyeSkge1xuICAgICAgaW5pdGlhbCA9IHF1ZXJ5XG4gICAgICByZWNvbm5lY3QoKVxuICAgIH0sXG4gICAgdGVybWluYXRlLFxuICAgIGV4ZWN1dGUsXG4gICAgY2FuY2VsLFxuICAgIGVuZCxcbiAgICBjb3VudDogMCxcbiAgICBpZFxuICB9XG5cbiAgcXVldWVzLmNsb3NlZCAmJiBxdWV1ZXMuY2xvc2VkLnB1c2goY29ubmVjdGlvbilcblxuICByZXR1cm4gY29ubmVjdGlvblxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNvY2tldCgpIHtcbiAgICBsZXQgeFxuICAgIHRyeSB7XG4gICAgICB4ID0gb3B0aW9ucy5zb2NrZXRcbiAgICAgICAgPyAoYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMuc29ja2V0KG9wdGlvbnMpKSlcbiAgICAgICAgOiBuZXcgbmV0LlNvY2tldCgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB4Lm9uKCdlcnJvcicsIGVycm9yKVxuICAgIHgub24oJ2Nsb3NlJywgY2xvc2VkKVxuICAgIHgub24oJ2RyYWluJywgZHJhaW4pXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbmNlbCh7IHBpZCwgc2VjcmV0IH0sIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICBjYW5jZWxNZXNzYWdlID0gYigpLmkzMigxNikuaTMyKDgwODc3MTAyKS5pMzIocGlkKS5pMzIoc2VjcmV0KS5lbmQoMTYpXG4gICAgICBhd2FpdCBjb25uZWN0KClcbiAgICAgIHNvY2tldC5vbmNlKCdlcnJvcicsIHJlamVjdClcbiAgICAgIHNvY2tldC5vbmNlKCdjbG9zZScsIHJlc29sdmUpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleGVjdXRlKHEpIHtcbiAgICBpZiAodGVybWluYXRlZClcbiAgICAgIHJldHVybiBxdWVyeUVycm9yKHEsIEVycm9ycy5jb25uZWN0aW9uKCdDT05ORUNUSU9OX0RFU1RST1lFRCcsIG9wdGlvbnMpKVxuXG4gICAgaWYgKHEuY2FuY2VsbGVkKVxuICAgICAgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgcS5zdGF0ZSA9IGJhY2tlbmRcbiAgICAgIHF1ZXJ5XG4gICAgICAgID8gc2VudC5wdXNoKHEpXG4gICAgICAgIDogKHF1ZXJ5ID0gcSwgcXVlcnkuYWN0aXZlID0gdHJ1ZSlcblxuICAgICAgYnVpbGQocSlcbiAgICAgIHJldHVybiB3cml0ZSh0b0J1ZmZlcihxKSlcbiAgICAgICAgJiYgIXEuZGVzY3JpYmVGaXJzdFxuICAgICAgICAmJiAhcS5jdXJzb3JGblxuICAgICAgICAmJiBzZW50Lmxlbmd0aCA8IG1heF9waXBlbGluZVxuICAgICAgICAmJiAoIXEub3B0aW9ucy5vbmV4ZWN1dGUgfHwgcS5vcHRpb25zLm9uZXhlY3V0ZShjb25uZWN0aW9uKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2VudC5sZW5ndGggPT09IDAgJiYgd3JpdGUoU3luYylcbiAgICAgIGVycm9yZWQoZXJyb3IpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQnVmZmVyKHEpIHtcbiAgICBpZiAocS5wYXJhbWV0ZXJzLmxlbmd0aCA+PSA2NTUzNClcbiAgICAgIHRocm93IEVycm9ycy5nZW5lcmljKCdNQVhfUEFSQU1FVEVSU19FWENFRURFRCcsICdNYXggbnVtYmVyIG9mIHBhcmFtZXRlcnMgKDY1NTM0KSBleGNlZWRlZCcpXG5cbiAgICByZXR1cm4gcS5vcHRpb25zLnNpbXBsZVxuICAgICAgPyBiKCkuUSgpLnN0cihxLnN0YXRlbWVudC5zdHJpbmcgKyBiLk4pLmVuZCgpXG4gICAgICA6IHEuZGVzY3JpYmVGaXJzdFxuICAgICAgICA/IEJ1ZmZlci5jb25jYXQoW2Rlc2NyaWJlKHEpLCBGbHVzaF0pXG4gICAgICAgIDogcS5wcmVwYXJlXG4gICAgICAgICAgPyBxLnByZXBhcmVkXG4gICAgICAgICAgICA/IHByZXBhcmVkKHEpXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoW2Rlc2NyaWJlKHEpLCBwcmVwYXJlZChxKV0pXG4gICAgICAgICAgOiB1bm5hbWVkKHEpXG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZShxKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgUGFyc2UocS5zdGF0ZW1lbnQuc3RyaW5nLCBxLnBhcmFtZXRlcnMsIHEuc3RhdGVtZW50LnR5cGVzLCBxLnN0YXRlbWVudC5uYW1lKSxcbiAgICAgIERlc2NyaWJlKCdTJywgcS5zdGF0ZW1lbnQubmFtZSlcbiAgICBdKVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZWQocSkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJpbmQocS5wYXJhbWV0ZXJzLCBxLnN0YXRlbWVudC50eXBlcywgcS5zdGF0ZW1lbnQubmFtZSwgcS5jdXJzb3JOYW1lKSxcbiAgICAgIHEuY3Vyc29yRm5cbiAgICAgICAgPyBFeGVjdXRlKCcnLCBxLmN1cnNvclJvd3MpXG4gICAgICAgIDogRXhlY3V0ZVVubmFtZWRcbiAgICBdKVxuICB9XG5cbiAgZnVuY3Rpb24gdW5uYW1lZChxKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgUGFyc2UocS5zdGF0ZW1lbnQuc3RyaW5nLCBxLnBhcmFtZXRlcnMsIHEuc3RhdGVtZW50LnR5cGVzKSxcbiAgICAgIERlc2NyaWJlVW5uYW1lZCxcbiAgICAgIHByZXBhcmVkKHEpXG4gICAgXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkKHEpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gW11cbiAgICAgICAgLCB0eXBlcyA9IFtdXG5cbiAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdpZnkocSwgcS5zdHJpbmdzWzBdLCBxLmFyZ3NbMF0sIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKVxuXG4gICAgIXEudGFnZ2VkICYmIHEuYXJncy5mb3JFYWNoKHggPT4gaGFuZGxlVmFsdWUoeCwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpKVxuXG4gICAgcS5wcmVwYXJlID0gb3B0aW9ucy5wcmVwYXJlICYmICgncHJlcGFyZScgaW4gcS5vcHRpb25zID8gcS5vcHRpb25zLnByZXBhcmUgOiB0cnVlKVxuICAgIHEuc3RyaW5nID0gc3RyaW5nXG4gICAgcS5zaWduYXR1cmUgPSBxLnByZXBhcmUgJiYgdHlwZXMgKyBzdHJpbmdcbiAgICBxLm9ubHlEZXNjcmliZSAmJiAoZGVsZXRlIHN0YXRlbWVudHNbcS5zaWduYXR1cmVdKVxuICAgIHEucGFyYW1ldGVycyA9IHEucGFyYW1ldGVycyB8fCBwYXJhbWV0ZXJzXG4gICAgcS5wcmVwYXJlZCA9IHEucHJlcGFyZSAmJiBxLnNpZ25hdHVyZSBpbiBzdGF0ZW1lbnRzXG4gICAgcS5kZXNjcmliZUZpcnN0ID0gcS5vbmx5RGVzY3JpYmUgfHwgKHBhcmFtZXRlcnMubGVuZ3RoICYmICFxLnByZXBhcmVkKVxuICAgIHEuc3RhdGVtZW50ID0gcS5wcmVwYXJlZFxuICAgICAgPyBzdGF0ZW1lbnRzW3Euc2lnbmF0dXJlXVxuICAgICAgOiB7IHN0cmluZywgdHlwZXMsIG5hbWU6IHEucHJlcGFyZSA/IHN0YXRlbWVudElkICsgc3RhdGVtZW50Q291bnQrKyA6ICcnIH1cblxuICAgIHR5cGVvZiBvcHRpb25zLmRlYnVnID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuZGVidWcoaWQsIHN0cmluZywgcGFyYW1ldGVycywgdHlwZXMpXG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSh4LCBmbikge1xuICAgIGNodW5rID0gY2h1bmsgPyBCdWZmZXIuY29uY2F0KFtjaHVuaywgeF0pIDogQnVmZmVyLmZyb20oeClcbiAgICBpZiAoZm4gfHwgY2h1bmsubGVuZ3RoID49IDEwMjQpXG4gICAgICByZXR1cm4gbmV4dFdyaXRlKGZuKVxuICAgIG5leHRXcml0ZVRpbWVyID09PSBudWxsICYmIChuZXh0V3JpdGVUaW1lciA9IHNldEltbWVkaWF0ZShuZXh0V3JpdGUpKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBuZXh0V3JpdGUoZm4pIHtcbiAgICBjb25zdCB4ID0gc29ja2V0LndyaXRlKGNodW5rLCBmbilcbiAgICBuZXh0V3JpdGVUaW1lciAhPT0gbnVsbCAmJiBjbGVhckltbWVkaWF0ZShuZXh0V3JpdGVUaW1lcilcbiAgICBjaHVuayA9IG5leHRXcml0ZVRpbWVyID0gbnVsbFxuICAgIHJldHVybiB4XG4gIH1cblxuICBmdW5jdGlvbiBjb25uZWN0VGltZWRPdXQoKSB7XG4gICAgZXJyb3JlZChFcnJvcnMuY29ubmVjdGlvbignQ09OTkVDVF9USU1FT1VUJywgb3B0aW9ucywgc29ja2V0KSlcbiAgICBzb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZWN1cmUoKSB7XG4gICAgd3JpdGUoU1NMUmVxdWVzdClcbiAgICBjb25zdCBjYW5TU0wgPSBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNvY2tldC5vbmNlKCdkYXRhJywgeCA9PiByKHhbMF0gPT09IDgzKSkpIC8vIFNcblxuICAgIGlmICghY2FuU1NMICYmIHNzbCA9PT0gJ3ByZWZlcicpXG4gICAgICByZXR1cm4gY29ubmVjdGVkKClcblxuICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHtcbiAgICAgIHNvY2tldCxcbiAgICAgIHNlcnZlcm5hbWU6IG5ldC5pc0lQKHNvY2tldC5ob3N0KSA/IHVuZGVmaW5lZCA6IHNvY2tldC5ob3N0LFxuICAgICAgLi4uKHNzbCA9PT0gJ3JlcXVpcmUnIHx8IHNzbCA9PT0gJ2FsbG93JyB8fCBzc2wgPT09ICdwcmVmZXInXG4gICAgICAgID8geyByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlIH1cbiAgICAgICAgOiBzc2wgPT09ICd2ZXJpZnktZnVsbCdcbiAgICAgICAgICA/IHt9XG4gICAgICAgICAgOiB0eXBlb2Ygc3NsID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBzc2xcbiAgICAgICAgICAgIDoge31cbiAgICAgIClcbiAgICB9KVxuICAgIHNvY2tldC5vbignc2VjdXJlQ29ubmVjdCcsIGNvbm5lY3RlZClcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgZXJyb3IpXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIGNsb3NlZClcbiAgICBzb2NrZXQub24oJ2RyYWluJywgZHJhaW4pXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICFxdWVyeSAmJiBvbm9wZW4oY29ubmVjdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIGRhdGEoeCkge1xuICAgIGlmIChpbmNvbWluZ3MpIHtcbiAgICAgIGluY29taW5ncy5wdXNoKHgpXG4gICAgICByZW1haW5pbmcgLT0geC5sZW5ndGhcbiAgICAgIGlmIChyZW1haW5pbmcgPj0gMClcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaW5jb21pbmcgPSBpbmNvbWluZ3NcbiAgICAgID8gQnVmZmVyLmNvbmNhdChpbmNvbWluZ3MsIGxlbmd0aCAtIHJlbWFpbmluZylcbiAgICAgIDogaW5jb21pbmcubGVuZ3RoID09PSAwXG4gICAgICAgID8geFxuICAgICAgICA6IEJ1ZmZlci5jb25jYXQoW2luY29taW5nLCB4XSwgaW5jb21pbmcubGVuZ3RoICsgeC5sZW5ndGgpXG5cbiAgICB3aGlsZSAoaW5jb21pbmcubGVuZ3RoID4gNCkge1xuICAgICAgbGVuZ3RoID0gaW5jb21pbmcucmVhZFVJbnQzMkJFKDEpXG4gICAgICBpZiAobGVuZ3RoID49IGluY29taW5nLmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmcgPSBsZW5ndGggLSBpbmNvbWluZy5sZW5ndGhcbiAgICAgICAgaW5jb21pbmdzID0gW2luY29taW5nXVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGUoaW5jb21pbmcuc3ViYXJyYXkoMCwgbGVuZ3RoICsgMSkpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHF1ZXJ5ICYmIChxdWVyeS5jdXJzb3JGbiB8fCBxdWVyeS5kZXNjcmliZUZpcnN0KSAmJiB3cml0ZShTeW5jKVxuICAgICAgICBlcnJvcmVkKGUpXG4gICAgICB9XG4gICAgICBpbmNvbWluZyA9IGluY29taW5nLnN1YmFycmF5KGxlbmd0aCArIDEpXG4gICAgICByZW1haW5pbmcgPSAwXG4gICAgICBpbmNvbWluZ3MgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICB0ZXJtaW5hdGVkID0gZmFsc2VcbiAgICBiYWNrZW5kUGFyYW1ldGVycyA9IHt9XG4gICAgc29ja2V0IHx8IChzb2NrZXQgPSBhd2FpdCBjcmVhdGVTb2NrZXQoKSlcblxuICAgIGlmICghc29ja2V0KVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25uZWN0VGltZXIuc3RhcnQoKVxuXG4gICAgaWYgKG9wdGlvbnMuc29ja2V0KVxuICAgICAgcmV0dXJuIHNzbCA/IHNlY3VyZSgpIDogY29ubmVjdGVkKClcblxuICAgIHNvY2tldC5vbignY29ubmVjdCcsIHNzbCA/IHNlY3VyZSA6IGNvbm5lY3RlZClcblxuICAgIGlmIChvcHRpb25zLnBhdGgpXG4gICAgICByZXR1cm4gc29ja2V0LmNvbm5lY3Qob3B0aW9ucy5wYXRoKVxuXG4gICAgc29ja2V0LnNzbCA9IHNzbFxuICAgIHNvY2tldC5jb25uZWN0KHBvcnRbaG9zdEluZGV4XSwgaG9zdFtob3N0SW5kZXhdKVxuICAgIHNvY2tldC5ob3N0ID0gaG9zdFtob3N0SW5kZXhdXG4gICAgc29ja2V0LnBvcnQgPSBwb3J0W2hvc3RJbmRleF1cblxuICAgIGhvc3RJbmRleCA9IChob3N0SW5kZXggKyAxKSAlIHBvcnQubGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiByZWNvbm5lY3QoKSB7XG4gICAgc2V0VGltZW91dChjb25uZWN0LCBjbG9zZWREYXRlID8gY2xvc2VkRGF0ZSArIGRlbGF5IC0gcGVyZm9ybWFuY2Uubm93KCkgOiAwKVxuICB9XG5cbiAgZnVuY3Rpb24gY29ubmVjdGVkKCkge1xuICAgIHRyeSB7XG4gICAgICBzdGF0ZW1lbnRzID0ge31cbiAgICAgIG5lZWRzVHlwZXMgPSBvcHRpb25zLmZldGNoX3R5cGVzXG4gICAgICBzdGF0ZW1lbnRJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpXG4gICAgICBzdGF0ZW1lbnRDb3VudCA9IDFcbiAgICAgIGxpZmVUaW1lci5zdGFydCgpXG4gICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhKVxuICAgICAga2VlcF9hbGl2ZSAmJiBzb2NrZXQuc2V0S2VlcEFsaXZlICYmIHNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwgMTAwMCAqIGtlZXBfYWxpdmUpXG4gICAgICBjb25zdCBzID0gU3RhcnR1cE1lc3NhZ2UoKVxuICAgICAgd3JpdGUocylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yKGVycilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoY29ubmVjdGlvbi5xdWV1ZSA9PT0gcXVldWVzLmNvbm5lY3RpbmcgJiYgb3B0aW9ucy5ob3N0W3JldHJpZXMgKyAxXSlcbiAgICAgIHJldHVyblxuXG4gICAgZXJyb3JlZChlcnIpXG4gICAgd2hpbGUgKHNlbnQubGVuZ3RoKVxuICAgICAgcXVlcnlFcnJvcihzZW50LnNoaWZ0KCksIGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yZWQoZXJyKSB7XG4gICAgc3RyZWFtICYmIChzdHJlYW0uZGVzdHJveShlcnIpLCBzdHJlYW0gPSBudWxsKVxuICAgIHF1ZXJ5ICYmIHF1ZXJ5RXJyb3IocXVlcnksIGVycilcbiAgICBpbml0aWFsICYmIChxdWVyeUVycm9yKGluaXRpYWwsIGVyciksIGluaXRpYWwgPSBudWxsKVxuICB9XG5cbiAgZnVuY3Rpb24gcXVlcnlFcnJvcihxdWVyeSwgZXJyKSB7XG4gICAgcXVlcnkucmVqZWN0KE9iamVjdC5jcmVhdGUoZXJyLCB7XG4gICAgICBzdGFjazogeyB2YWx1ZTogZXJyLnN0YWNrICsgcXVlcnkub3JpZ2luLnJlcGxhY2UoLy4qXFxuLywgJ1xcbicpLCBlbnVtZXJhYmxlOiBvcHRpb25zLmRlYnVnIH0sXG4gICAgICBxdWVyeTogeyB2YWx1ZTogcXVlcnkuc3RyaW5nLCBlbnVtZXJhYmxlOiBvcHRpb25zLmRlYnVnIH0sXG4gICAgICBwYXJhbWV0ZXJzOiB7IHZhbHVlOiBxdWVyeS5wYXJhbWV0ZXJzLCBlbnVtZXJhYmxlOiBvcHRpb25zLmRlYnVnIH0sXG4gICAgICBhcmdzOiB7IHZhbHVlOiBxdWVyeS5hcmdzLCBlbnVtZXJhYmxlOiBvcHRpb25zLmRlYnVnIH0sXG4gICAgICB0eXBlczogeyB2YWx1ZTogcXVlcnkuc3RhdGVtZW50ICYmIHF1ZXJ5LnN0YXRlbWVudC50eXBlcywgZW51bWVyYWJsZTogb3B0aW9ucy5kZWJ1ZyB9XG4gICAgfSkpXG4gIH1cblxuICBmdW5jdGlvbiBlbmQoKSB7XG4gICAgcmV0dXJuIGVuZGluZyB8fCAoXG4gICAgICAhY29ubmVjdGlvbi5yZXNlcnZlZCAmJiBvbmVuZChjb25uZWN0aW9uKSxcbiAgICAgICFjb25uZWN0aW9uLnJlc2VydmVkICYmICFpbml0aWFsICYmICFxdWVyeSAmJiBzZW50Lmxlbmd0aCA9PT0gMFxuICAgICAgICA/ICh0ZXJtaW5hdGUoKSwgbmV3IFByb21pc2UociA9PiBzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgIT09ICdjbG9zZWQnID8gc29ja2V0Lm9uY2UoJ2Nsb3NlJywgcikgOiByKCkpKVxuICAgICAgICA6IGVuZGluZyA9IG5ldyBQcm9taXNlKHIgPT4gZW5kZWQgPSByKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlcm1pbmF0ZSgpIHtcbiAgICB0ZXJtaW5hdGVkID0gdHJ1ZVxuICAgIGlmIChzdHJlYW0gfHwgcXVlcnkgfHwgaW5pdGlhbCB8fCBzZW50Lmxlbmd0aClcbiAgICAgIGVycm9yKEVycm9ycy5jb25uZWN0aW9uKCdDT05ORUNUSU9OX0RFU1RST1lFRCcsIG9wdGlvbnMpKVxuXG4gICAgY2xlYXJJbW1lZGlhdGUobmV4dFdyaXRlVGltZXIpXG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgZGF0YSlcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIGNvbm5lY3RlZClcbiAgICAgIHNvY2tldC5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgc29ja2V0LmVuZChiKCkuWCgpLmVuZCgpKVxuICAgIH1cbiAgICBlbmRlZCAmJiAoZW5kZWQoKSwgZW5kaW5nID0gZW5kZWQgPSBudWxsKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2xvc2VkKGhhZEVycm9yKSB7XG4gICAgaW5jb21pbmcgPSBCdWZmZXIuYWxsb2MoMClcbiAgICByZW1haW5pbmcgPSAwXG4gICAgaW5jb21pbmdzID0gbnVsbFxuICAgIGNsZWFySW1tZWRpYXRlKG5leHRXcml0ZVRpbWVyKVxuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGRhdGEpXG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdGVkKVxuICAgIGlkbGVUaW1lci5jYW5jZWwoKVxuICAgIGxpZmVUaW1lci5jYW5jZWwoKVxuICAgIGNvbm5lY3RUaW1lci5jYW5jZWwoKVxuXG4gICAgaWYgKHNvY2tldC5lbmNyeXB0ZWQpIHtcbiAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgICAgc29ja2V0ID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChpbml0aWFsKVxuICAgICAgcmV0dXJuIHJlY29ubmVjdCgpXG5cbiAgICAhaGFkRXJyb3IgJiYgKHF1ZXJ5IHx8IHNlbnQubGVuZ3RoKSAmJiBlcnJvcihFcnJvcnMuY29ubmVjdGlvbignQ09OTkVDVElPTl9DTE9TRUQnLCBvcHRpb25zLCBzb2NrZXQpKVxuICAgIGNsb3NlZERhdGUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGhhZEVycm9yICYmIG9wdGlvbnMuc2hhcmVkLnJldHJpZXMrK1xuICAgIGRlbGF5ID0gKHR5cGVvZiBiYWNrb2ZmID09PSAnZnVuY3Rpb24nID8gYmFja29mZihvcHRpb25zLnNoYXJlZC5yZXRyaWVzKSA6IGJhY2tvZmYpICogMTAwMFxuICAgIG9uY2xvc2UoY29ubmVjdGlvbilcbiAgfVxuXG4gIC8qIEhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZSh4cywgeCA9IHhzWzBdKSB7XG4gICAgKFxuICAgICAgeCA9PT0gNjggPyBEYXRhUm93IDogICAgICAgICAgICAgICAgICAgLy8gRFxuICAgICAgeCA9PT0gMTAwID8gQ29weURhdGEgOiAgICAgICAgICAgICAgICAgLy8gZFxuICAgICAgeCA9PT0gNjUgPyBOb3RpZmljYXRpb25SZXNwb25zZSA6ICAgICAgLy8gQVxuICAgICAgeCA9PT0gODMgPyBQYXJhbWV0ZXJTdGF0dXMgOiAgICAgICAgICAgLy8gU1xuICAgICAgeCA9PT0gOTAgPyBSZWFkeUZvclF1ZXJ5IDogICAgICAgICAgICAgLy8gWlxuICAgICAgeCA9PT0gNjcgPyBDb21tYW5kQ29tcGxldGUgOiAgICAgICAgICAgLy8gQ1xuICAgICAgeCA9PT0gNTAgPyBCaW5kQ29tcGxldGUgOiAgICAgICAgICAgICAgLy8gMlxuICAgICAgeCA9PT0gNDkgPyBQYXJzZUNvbXBsZXRlIDogICAgICAgICAgICAgLy8gMVxuICAgICAgeCA9PT0gMTE2ID8gUGFyYW1ldGVyRGVzY3JpcHRpb24gOiAgICAgLy8gdFxuICAgICAgeCA9PT0gODQgPyBSb3dEZXNjcmlwdGlvbiA6ICAgICAgICAgICAgLy8gVFxuICAgICAgeCA9PT0gODIgPyBBdXRoZW50aWNhdGlvbiA6ICAgICAgICAgICAgLy8gUlxuICAgICAgeCA9PT0gMTEwID8gTm9EYXRhIDogICAgICAgICAgICAgICAgICAgLy8gblxuICAgICAgeCA9PT0gNzUgPyBCYWNrZW5kS2V5RGF0YSA6ICAgICAgICAgICAgLy8gS1xuICAgICAgeCA9PT0gNjkgPyBFcnJvclJlc3BvbnNlIDogICAgICAgICAgICAgLy8gRVxuICAgICAgeCA9PT0gMTE1ID8gUG9ydGFsU3VzcGVuZGVkIDogICAgICAgICAgLy8gc1xuICAgICAgeCA9PT0gNTEgPyBDbG9zZUNvbXBsZXRlIDogICAgICAgICAgICAgLy8gM1xuICAgICAgeCA9PT0gNzEgPyBDb3B5SW5SZXNwb25zZSA6ICAgICAgICAgICAgLy8gR1xuICAgICAgeCA9PT0gNzggPyBOb3RpY2VSZXNwb25zZSA6ICAgICAgICAgICAgLy8gTlxuICAgICAgeCA9PT0gNzIgPyBDb3B5T3V0UmVzcG9uc2UgOiAgICAgICAgICAgLy8gSFxuICAgICAgeCA9PT0gOTkgPyBDb3B5RG9uZSA6ICAgICAgICAgICAgICAgICAgLy8gY1xuICAgICAgeCA9PT0gNzMgPyBFbXB0eVF1ZXJ5UmVzcG9uc2UgOiAgICAgICAgLy8gSVxuICAgICAgeCA9PT0gODYgPyBGdW5jdGlvbkNhbGxSZXNwb25zZSA6ICAgICAgLy8gVlxuICAgICAgeCA9PT0gMTE4ID8gTmVnb3RpYXRlUHJvdG9jb2xWZXJzaW9uIDogLy8gdlxuICAgICAgeCA9PT0gODcgPyBDb3B5Qm90aFJlc3BvbnNlIDogICAgICAgICAgLy8gV1xuICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgIFVua25vd25NZXNzYWdlXG4gICAgKSh4cylcbiAgfVxuXG4gIGZ1bmN0aW9uIERhdGFSb3coeCkge1xuICAgIGxldCBpbmRleCA9IDdcbiAgICBsZXQgbGVuZ3RoXG4gICAgbGV0IGNvbHVtblxuICAgIGxldCB2YWx1ZVxuXG4gICAgY29uc3Qgcm93ID0gcXVlcnkuaXNSYXcgPyBuZXcgQXJyYXkocXVlcnkuc3RhdGVtZW50LmNvbHVtbnMubGVuZ3RoKSA6IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVyeS5zdGF0ZW1lbnQuY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29sdW1uID0gcXVlcnkuc3RhdGVtZW50LmNvbHVtbnNbaV1cbiAgICAgIGxlbmd0aCA9IHgucmVhZEludDMyQkUoaW5kZXgpXG4gICAgICBpbmRleCArPSA0XG5cbiAgICAgIHZhbHVlID0gbGVuZ3RoID09PSAtMVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBxdWVyeS5pc1JhdyA9PT0gdHJ1ZVxuICAgICAgICAgID8geC5zdWJhcnJheShpbmRleCwgaW5kZXggKz0gbGVuZ3RoKVxuICAgICAgICAgIDogY29sdW1uLnBhcnNlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHgudG9TdHJpbmcoJ3V0ZjgnLCBpbmRleCwgaW5kZXggKz0gbGVuZ3RoKVxuICAgICAgICAgICAgOiBjb2x1bW4ucGFyc2VyLmFycmF5ID09PSB0cnVlXG4gICAgICAgICAgICAgID8gY29sdW1uLnBhcnNlcih4LnRvU3RyaW5nKCd1dGY4JywgaW5kZXggKyAxLCBpbmRleCArPSBsZW5ndGgpKVxuICAgICAgICAgICAgICA6IGNvbHVtbi5wYXJzZXIoeC50b1N0cmluZygndXRmOCcsIGluZGV4LCBpbmRleCArPSBsZW5ndGgpKVxuXG4gICAgICBxdWVyeS5pc1Jhd1xuICAgICAgICA/IChyb3dbaV0gPSBxdWVyeS5pc1JhdyA9PT0gdHJ1ZVxuICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICA6IHRyYW5zZm9ybS52YWx1ZS5mcm9tID8gdHJhbnNmb3JtLnZhbHVlLmZyb20odmFsdWUsIGNvbHVtbikgOiB2YWx1ZSlcbiAgICAgICAgOiAocm93W2NvbHVtbi5uYW1lXSA9IHRyYW5zZm9ybS52YWx1ZS5mcm9tID8gdHJhbnNmb3JtLnZhbHVlLmZyb20odmFsdWUsIGNvbHVtbikgOiB2YWx1ZSlcbiAgICB9XG5cbiAgICBxdWVyeS5mb3JFYWNoRm5cbiAgICAgID8gcXVlcnkuZm9yRWFjaEZuKHRyYW5zZm9ybS5yb3cuZnJvbSA/IHRyYW5zZm9ybS5yb3cuZnJvbShyb3cpIDogcm93LCByZXN1bHQpXG4gICAgICA6IChyZXN1bHRbcm93cysrXSA9IHRyYW5zZm9ybS5yb3cuZnJvbSA/IHRyYW5zZm9ybS5yb3cuZnJvbShyb3cpIDogcm93KVxuICB9XG5cbiAgZnVuY3Rpb24gUGFyYW1ldGVyU3RhdHVzKHgpIHtcbiAgICBjb25zdCBbaywgdl0gPSB4LnRvU3RyaW5nKCd1dGY4JywgNSwgeC5sZW5ndGggLSAxKS5zcGxpdChiLk4pXG4gICAgYmFja2VuZFBhcmFtZXRlcnNba10gPSB2XG4gICAgaWYgKG9wdGlvbnMucGFyYW1ldGVyc1trXSAhPT0gdikge1xuICAgICAgb3B0aW9ucy5wYXJhbWV0ZXJzW2tdID0gdlxuICAgICAgb25wYXJhbWV0ZXIgJiYgb25wYXJhbWV0ZXIoaywgdilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBSZWFkeUZvclF1ZXJ5KHgpIHtcbiAgICBxdWVyeSAmJiBxdWVyeS5vcHRpb25zLnNpbXBsZSAmJiBxdWVyeS5yZXNvbHZlKHJlc3VsdHMgfHwgcmVzdWx0KVxuICAgIHF1ZXJ5ID0gcmVzdWx0cyA9IG51bGxcbiAgICByZXN1bHQgPSBuZXcgUmVzdWx0KClcbiAgICBjb25uZWN0VGltZXIuY2FuY2VsKClcblxuICAgIGlmIChpbml0aWFsKSB7XG4gICAgICBpZiAodGFyZ2V0X3Nlc3Npb25fYXR0cnMpIHtcbiAgICAgICAgaWYgKCFiYWNrZW5kUGFyYW1ldGVycy5pbl9ob3Rfc3RhbmRieSB8fCAhYmFja2VuZFBhcmFtZXRlcnMuZGVmYXVsdF90cmFuc2FjdGlvbl9yZWFkX29ubHkpXG4gICAgICAgICAgcmV0dXJuIGZldGNoU3RhdGUoKVxuICAgICAgICBlbHNlIGlmICh0cnlOZXh0KHRhcmdldF9zZXNzaW9uX2F0dHJzLCBiYWNrZW5kUGFyYW1ldGVycykpXG4gICAgICAgICAgcmV0dXJuIHRlcm1pbmF0ZSgpXG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkc1R5cGVzKVxuICAgICAgICByZXR1cm4gZmV0Y2hBcnJheVR5cGVzKClcblxuICAgICAgZXhlY3V0ZShpbml0aWFsKVxuICAgICAgb3B0aW9ucy5zaGFyZWQucmV0cmllcyA9IHJldHJpZXMgPSBpbml0aWFsID0gMFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgd2hpbGUgKHNlbnQubGVuZ3RoICYmIChxdWVyeSA9IHNlbnQuc2hpZnQoKSkgJiYgKHF1ZXJ5LmFjdGl2ZSA9IHRydWUsIHF1ZXJ5LmNhbmNlbGxlZCkpXG4gICAgICBDb25uZWN0aW9uKG9wdGlvbnMpLmNhbmNlbChxdWVyeS5zdGF0ZSwgcXVlcnkuY2FuY2VsbGVkLnJlc29sdmUsIHF1ZXJ5LmNhbmNlbGxlZC5yZWplY3QpXG5cbiAgICBpZiAocXVlcnkpXG4gICAgICByZXR1cm4gLy8gQ29uc2lkZXIgb3BlbmluZyBpZiBhYmxlIGFuZCBzZW50Lmxlbmd0aCA8IDUwXG5cbiAgICBjb25uZWN0aW9uLnJlc2VydmVkXG4gICAgICA/ICFjb25uZWN0aW9uLnJlc2VydmVkLnJlbGVhc2UgJiYgeFs1XSA9PT0gNzMgLy8gSVxuICAgICAgICA/IGVuZGluZ1xuICAgICAgICAgID8gdGVybWluYXRlKClcbiAgICAgICAgICA6IChjb25uZWN0aW9uLnJlc2VydmVkID0gbnVsbCwgb25vcGVuKGNvbm5lY3Rpb24pKVxuICAgICAgICA6IGNvbm5lY3Rpb24ucmVzZXJ2ZWQoKVxuICAgICAgOiBlbmRpbmdcbiAgICAgICAgPyB0ZXJtaW5hdGUoKVxuICAgICAgICA6IG9ub3Blbihjb25uZWN0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gQ29tbWFuZENvbXBsZXRlKHgpIHtcbiAgICByb3dzID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IHgubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgaWYgKHhbaV0gPT09IDMyICYmIHhbaSArIDFdIDwgNTggJiYgcmVzdWx0LmNvdW50ID09PSBudWxsKVxuICAgICAgICByZXN1bHQuY291bnQgPSAreC50b1N0cmluZygndXRmOCcsIGkgKyAxLCB4Lmxlbmd0aCAtIDEpXG4gICAgICBpZiAoeFtpIC0gMV0gPj0gNjUpIHtcbiAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSB4LnRvU3RyaW5nKCd1dGY4JywgNSwgaSlcbiAgICAgICAgcmVzdWx0LnN0YXRlID0gYmFja2VuZFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpbmFsICYmIChmaW5hbCgpLCBmaW5hbCA9IG51bGwpXG5cbiAgICBpZiAocmVzdWx0LmNvbW1hbmQgPT09ICdCRUdJTicgJiYgbWF4ICE9PSAxICYmICFjb25uZWN0aW9uLnJlc2VydmVkKVxuICAgICAgcmV0dXJuIGVycm9yZWQoRXJyb3JzLmdlbmVyaWMoJ1VOU0FGRV9UUkFOU0FDVElPTicsICdPbmx5IHVzZSBzcWwuYmVnaW4sIHNxbC5yZXNlcnZlZCBvciBtYXg6IDEnKSlcblxuICAgIGlmIChxdWVyeS5vcHRpb25zLnNpbXBsZSlcbiAgICAgIHJldHVybiBCaW5kQ29tcGxldGUoKVxuXG4gICAgaWYgKHF1ZXJ5LmN1cnNvckZuKSB7XG4gICAgICByZXN1bHQuY291bnQgJiYgcXVlcnkuY3Vyc29yRm4ocmVzdWx0KVxuICAgICAgd3JpdGUoU3luYylcbiAgICB9XG5cbiAgICBxdWVyeS5yZXNvbHZlKHJlc3VsdClcbiAgfVxuXG4gIGZ1bmN0aW9uIFBhcnNlQ29tcGxldGUoKSB7XG4gICAgcXVlcnkucGFyc2luZyA9IGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBCaW5kQ29tcGxldGUoKSB7XG4gICAgIXJlc3VsdC5zdGF0ZW1lbnQgJiYgKHJlc3VsdC5zdGF0ZW1lbnQgPSBxdWVyeS5zdGF0ZW1lbnQpXG4gICAgcmVzdWx0LmNvbHVtbnMgPSBxdWVyeS5zdGF0ZW1lbnQuY29sdW1uc1xuICB9XG5cbiAgZnVuY3Rpb24gUGFyYW1ldGVyRGVzY3JpcHRpb24oeCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHgucmVhZFVJbnQxNkJFKDUpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKVxuICAgICAgIXF1ZXJ5LnN0YXRlbWVudC50eXBlc1tpXSAmJiAocXVlcnkuc3RhdGVtZW50LnR5cGVzW2ldID0geC5yZWFkVUludDMyQkUoNyArIGkgKiA0KSlcblxuICAgIHF1ZXJ5LnByZXBhcmUgJiYgKHN0YXRlbWVudHNbcXVlcnkuc2lnbmF0dXJlXSA9IHF1ZXJ5LnN0YXRlbWVudClcbiAgICBxdWVyeS5kZXNjcmliZUZpcnN0ICYmICFxdWVyeS5vbmx5RGVzY3JpYmUgJiYgKHdyaXRlKHByZXBhcmVkKHF1ZXJ5KSksIHF1ZXJ5LmRlc2NyaWJlRmlyc3QgPSBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFJvd0Rlc2NyaXB0aW9uKHgpIHtcbiAgICBpZiAocmVzdWx0LmNvbW1hbmQpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtyZXN1bHRdXG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0ID0gbmV3IFJlc3VsdCgpKVxuICAgICAgcmVzdWx0LmNvdW50ID0gbnVsbFxuICAgICAgcXVlcnkuc3RhdGVtZW50LmNvbHVtbnMgPSBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0geC5yZWFkVUludDE2QkUoNSlcbiAgICBsZXQgaW5kZXggPSA3XG4gICAgbGV0IHN0YXJ0XG5cbiAgICBxdWVyeS5zdGF0ZW1lbnQuY29sdW1ucyA9IEFycmF5KGxlbmd0aClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHN0YXJ0ID0gaW5kZXhcbiAgICAgIHdoaWxlICh4W2luZGV4KytdICE9PSAwKTtcbiAgICAgIGNvbnN0IHRhYmxlID0geC5yZWFkVUludDMyQkUoaW5kZXgpXG4gICAgICBjb25zdCBudW1iZXIgPSB4LnJlYWRVSW50MTZCRShpbmRleCArIDQpXG4gICAgICBjb25zdCB0eXBlID0geC5yZWFkVUludDMyQkUoaW5kZXggKyA2KVxuICAgICAgcXVlcnkuc3RhdGVtZW50LmNvbHVtbnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IHRyYW5zZm9ybS5jb2x1bW4uZnJvbVxuICAgICAgICAgID8gdHJhbnNmb3JtLmNvbHVtbi5mcm9tKHgudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgaW5kZXggLSAxKSlcbiAgICAgICAgICA6IHgudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgaW5kZXggLSAxKSxcbiAgICAgICAgcGFyc2VyOiBwYXJzZXJzW3R5cGVdLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICB0eXBlXG4gICAgICB9XG4gICAgICBpbmRleCArPSAxOFxuICAgIH1cblxuICAgIHJlc3VsdC5zdGF0ZW1lbnQgPSBxdWVyeS5zdGF0ZW1lbnRcbiAgICBpZiAocXVlcnkub25seURlc2NyaWJlKVxuICAgICAgcmV0dXJuIChxdWVyeS5yZXNvbHZlKHF1ZXJ5LnN0YXRlbWVudCksIHdyaXRlKFN5bmMpKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gQXV0aGVudGljYXRpb24oeCwgdHlwZSA9IHgucmVhZFVJbnQzMkJFKDUpKSB7XG4gICAgKFxuICAgICAgdHlwZSA9PT0gMyA/IEF1dGhlbnRpY2F0aW9uQ2xlYXJ0ZXh0UGFzc3dvcmQgOlxuICAgICAgdHlwZSA9PT0gNSA/IEF1dGhlbnRpY2F0aW9uTUQ1UGFzc3dvcmQgOlxuICAgICAgdHlwZSA9PT0gMTAgPyBTQVNMIDpcbiAgICAgIHR5cGUgPT09IDExID8gU0FTTENvbnRpbnVlIDpcbiAgICAgIHR5cGUgPT09IDEyID8gU0FTTEZpbmFsIDpcbiAgICAgIHR5cGUgIT09IDAgPyBVbmtub3duQXV0aCA6XG4gICAgICBub29wXG4gICAgKSh4LCB0eXBlKVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgNSAqL1xuICBhc3luYyBmdW5jdGlvbiBBdXRoZW50aWNhdGlvbkNsZWFydGV4dFBhc3N3b3JkKCkge1xuICAgIHdyaXRlKFxuICAgICAgYigpLnAoKS5zdHIoYXdhaXQgUGFzcygpKS56KDEpLmVuZCgpXG4gICAgKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gQXV0aGVudGljYXRpb25NRDVQYXNzd29yZCh4KSB7XG4gICAgd3JpdGUoXG4gICAgICBiKCkucCgpLnN0cihcbiAgICAgICAgJ21kNScgK1xuICAgICAgICAoYXdhaXQgbWQ1KEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgIEJ1ZmZlci5mcm9tKGF3YWl0IG1kNSgoYXdhaXQgUGFzcygpKSArIHVzZXIpKSxcbiAgICAgICAgICB4LnN1YmFycmF5KDkpXG4gICAgICAgIF0pKSlcbiAgICAgICkueigxKS5lbmQoKVxuICAgIClcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIFNBU0woKSB7XG4gICAgYigpLnAoKS5zdHIoJ1NDUkFNLVNIQS0yNTYnICsgYi5OKVxuICAgIGNvbnN0IGkgPSBiLmlcbiAgICBub25jZSA9IChhd2FpdCBjcnlwdG8ucmFuZG9tQnl0ZXMoMTgpKS50b1N0cmluZygnYmFzZTY0JylcbiAgICB3cml0ZShiLmluYyg0KS5zdHIoJ24sLG49KixyPScgKyBub25jZSkuaTMyKGIuaSAtIGkgLSA0LCBpKS5lbmQoKSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIFNBU0xDb250aW51ZSh4KSB7XG4gICAgY29uc3QgcmVzID0geC50b1N0cmluZygndXRmOCcsIDkpLnNwbGl0KCcsJykucmVkdWNlKChhY2MsIHgpID0+IChhY2NbeFswXV0gPSB4LnNsaWNlKDIpLCBhY2MpLCB7fSlcblxuICAgIGNvbnN0IHNhbHRlZFBhc3N3b3JkID0gYXdhaXQgY3J5cHRvLnBia2RmMlN5bmMoXG4gICAgICBhd2FpdCBQYXNzKCksXG4gICAgICBCdWZmZXIuZnJvbShyZXMucywgJ2Jhc2U2NCcpLFxuICAgICAgcGFyc2VJbnQocmVzLmkpLCAzMixcbiAgICAgICdzaGEyNTYnXG4gICAgKVxuXG4gICAgY29uc3QgY2xpZW50S2V5ID0gYXdhaXQgaG1hYyhzYWx0ZWRQYXNzd29yZCwgJ0NsaWVudCBLZXknKVxuXG4gICAgY29uc3QgYXV0aCA9ICduPSoscj0nICsgbm9uY2UgKyAnLCdcbiAgICAgICAgICAgICAgICsgJ3I9JyArIHJlcy5yICsgJyxzPScgKyByZXMucyArICcsaT0nICsgcmVzLmlcbiAgICAgICAgICAgICAgICsgJyxjPWJpd3Mscj0nICsgcmVzLnJcblxuICAgIHNlcnZlclNpZ25hdHVyZSA9IChhd2FpdCBobWFjKGF3YWl0IGhtYWMoc2FsdGVkUGFzc3dvcmQsICdTZXJ2ZXIgS2V5JyksIGF1dGgpKS50b1N0cmluZygnYmFzZTY0JylcblxuICAgIHdyaXRlKFxuICAgICAgYigpLnAoKS5zdHIoXG4gICAgICAgICdjPWJpd3Mscj0nICsgcmVzLnIgKyAnLHA9JyArIHhvcihcbiAgICAgICAgICBjbGllbnRLZXksIEJ1ZmZlci5mcm9tKGF3YWl0IGhtYWMoYXdhaXQgc2hhMjU2KGNsaWVudEtleSksIGF1dGgpKVxuICAgICAgICApLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgKS5lbmQoKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIFNBU0xGaW5hbCh4KSB7XG4gICAgaWYgKHgudG9TdHJpbmcoJ3V0ZjgnLCA5KS5zcGxpdChiLk4sIDEpWzBdLnNsaWNlKDIpID09PSBzZXJ2ZXJTaWduYXR1cmUpXG4gICAgICByZXR1cm5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gICAgZXJyb3JlZChFcnJvcnMuZ2VuZXJpYygnU0FTTF9TSUdOQVRVUkVfTUlTTUFUQ0gnLCAnVGhlIHNlcnZlciBkaWQgbm90IHJldHVybiB0aGUgY29ycmVjdCBzaWduYXR1cmUnKSlcbiAgICBzb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBmdW5jdGlvbiBQYXNzKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHlwZW9mIG9wdGlvbnMucGFzcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBvcHRpb25zLnBhc3MoKVxuICAgICAgOiBvcHRpb25zLnBhc3NcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBOb0RhdGEoKSB7XG4gICAgcmVzdWx0LnN0YXRlbWVudCA9IHF1ZXJ5LnN0YXRlbWVudFxuICAgIHJlc3VsdC5zdGF0ZW1lbnQuY29sdW1ucyA9IFtdXG4gICAgaWYgKHF1ZXJ5Lm9ubHlEZXNjcmliZSlcbiAgICAgIHJldHVybiAocXVlcnkucmVzb2x2ZShxdWVyeS5zdGF0ZW1lbnQpLCB3cml0ZShTeW5jKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIEJhY2tlbmRLZXlEYXRhKHgpIHtcbiAgICBiYWNrZW5kLnBpZCA9IHgucmVhZFVJbnQzMkJFKDUpXG4gICAgYmFja2VuZC5zZWNyZXQgPSB4LnJlYWRVSW50MzJCRSg5KVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBcnJheVR5cGVzKCkge1xuICAgIG5lZWRzVHlwZXMgPSBmYWxzZVxuICAgIGNvbnN0IHR5cGVzID0gYXdhaXQgbmV3IFF1ZXJ5KFtgXG4gICAgICBzZWxlY3QgYi5vaWQsIGIudHlwYXJyYXlcbiAgICAgIGZyb20gcGdfY2F0YWxvZy5wZ190eXBlIGFcbiAgICAgIGxlZnQgam9pbiBwZ19jYXRhbG9nLnBnX3R5cGUgYiBvbiBiLm9pZCA9IGEudHlwZWxlbVxuICAgICAgd2hlcmUgYS50eXBjYXRlZ29yeSA9ICdBJ1xuICAgICAgZ3JvdXAgYnkgYi5vaWQsIGIudHlwYXJyYXlcbiAgICAgIG9yZGVyIGJ5IGIub2lkXG4gICAgYF0sIFtdLCBleGVjdXRlKVxuICAgIHR5cGVzLmZvckVhY2goKHsgb2lkLCB0eXBhcnJheSB9KSA9PiBhZGRBcnJheVR5cGUob2lkLCB0eXBhcnJheSkpXG4gIH1cblxuICBmdW5jdGlvbiBhZGRBcnJheVR5cGUob2lkLCB0eXBhcnJheSkge1xuICAgIGlmICghIW9wdGlvbnMucGFyc2Vyc1t0eXBhcnJheV0gJiYgISFvcHRpb25zLnNlcmlhbGl6ZXJzW3R5cGFycmF5XSkgcmV0dXJuXG4gICAgY29uc3QgcGFyc2VyID0gb3B0aW9ucy5wYXJzZXJzW29pZF1cbiAgICBvcHRpb25zLnNoYXJlZC50eXBlQXJyYXlNYXBbb2lkXSA9IHR5cGFycmF5XG4gICAgb3B0aW9ucy5wYXJzZXJzW3R5cGFycmF5XSA9ICh4cykgPT4gYXJyYXlQYXJzZXIoeHMsIHBhcnNlciwgdHlwYXJyYXkpXG4gICAgb3B0aW9ucy5wYXJzZXJzW3R5cGFycmF5XS5hcnJheSA9IHRydWVcbiAgICBvcHRpb25zLnNlcmlhbGl6ZXJzW3R5cGFycmF5XSA9ICh4cykgPT4gYXJyYXlTZXJpYWxpemVyKHhzLCBvcHRpb25zLnNlcmlhbGl6ZXJzW29pZF0sIG9wdGlvbnMsIHR5cGFycmF5KVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5TmV4dCh4LCB4cykge1xuICAgIHJldHVybiAoXG4gICAgICAoeCA9PT0gJ3JlYWQtd3JpdGUnICYmIHhzLmRlZmF1bHRfdHJhbnNhY3Rpb25fcmVhZF9vbmx5ID09PSAnb24nKSB8fFxuICAgICAgKHggPT09ICdyZWFkLW9ubHknICYmIHhzLmRlZmF1bHRfdHJhbnNhY3Rpb25fcmVhZF9vbmx5ID09PSAnb2ZmJykgfHxcbiAgICAgICh4ID09PSAncHJpbWFyeScgJiYgeHMuaW5faG90X3N0YW5kYnkgPT09ICdvbicpIHx8XG4gICAgICAoeCA9PT0gJ3N0YW5kYnknICYmIHhzLmluX2hvdF9zdGFuZGJ5ID09PSAnb2ZmJykgfHxcbiAgICAgICh4ID09PSAncHJlZmVyLXN0YW5kYnknICYmIHhzLmluX2hvdF9zdGFuZGJ5ID09PSAnb2ZmJyAmJiBvcHRpb25zLmhvc3RbcmV0cmllc10pXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hTdGF0ZSgpIHtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeShbYFxuICAgICAgc2hvdyB0cmFuc2FjdGlvbl9yZWFkX29ubHk7XG4gICAgICBzZWxlY3QgcGdfY2F0YWxvZy5wZ19pc19pbl9yZWNvdmVyeSgpXG4gICAgYF0sIFtdLCBleGVjdXRlLCBudWxsLCB7IHNpbXBsZTogdHJ1ZSB9KVxuICAgIHF1ZXJ5LnJlc29sdmUgPSAoW1thXSwgW2JdXSkgPT4ge1xuICAgICAgYmFja2VuZFBhcmFtZXRlcnMuZGVmYXVsdF90cmFuc2FjdGlvbl9yZWFkX29ubHkgPSBhLnRyYW5zYWN0aW9uX3JlYWRfb25seVxuICAgICAgYmFja2VuZFBhcmFtZXRlcnMuaW5faG90X3N0YW5kYnkgPSBiLnBnX2lzX2luX3JlY292ZXJ5ID8gJ29uJyA6ICdvZmYnXG4gICAgfVxuICAgIHF1ZXJ5LmV4ZWN1dGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gRXJyb3JSZXNwb25zZSh4KSB7XG4gICAgcXVlcnkgJiYgKHF1ZXJ5LmN1cnNvckZuIHx8IHF1ZXJ5LmRlc2NyaWJlRmlyc3QpICYmIHdyaXRlKFN5bmMpXG4gICAgY29uc3QgZXJyb3IgPSBFcnJvcnMucG9zdGdyZXMocGFyc2VFcnJvcih4KSlcbiAgICBxdWVyeSAmJiBxdWVyeS5yZXRyaWVkXG4gICAgICA/IGVycm9yZWQocXVlcnkucmV0cmllZClcbiAgICAgIDogcXVlcnkgJiYgcmV0cnlSb3V0aW5lcy5oYXMoZXJyb3Iucm91dGluZSlcbiAgICAgICAgPyByZXRyeShxdWVyeSwgZXJyb3IpXG4gICAgICAgIDogZXJyb3JlZChlcnJvcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJ5KHEsIGVycm9yKSB7XG4gICAgZGVsZXRlIHN0YXRlbWVudHNbcS5zaWduYXR1cmVdXG4gICAgcS5yZXRyaWVkID0gZXJyb3JcbiAgICBleGVjdXRlKHEpXG4gIH1cblxuICBmdW5jdGlvbiBOb3RpZmljYXRpb25SZXNwb25zZSh4KSB7XG4gICAgaWYgKCFvbm5vdGlmeSlcbiAgICAgIHJldHVyblxuXG4gICAgbGV0IGluZGV4ID0gOVxuICAgIHdoaWxlICh4W2luZGV4KytdICE9PSAwKTtcbiAgICBvbm5vdGlmeShcbiAgICAgIHgudG9TdHJpbmcoJ3V0ZjgnLCA5LCBpbmRleCAtIDEpLFxuICAgICAgeC50b1N0cmluZygndXRmOCcsIGluZGV4LCB4Lmxlbmd0aCAtIDEpXG4gICAgKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gUG9ydGFsU3VzcGVuZGVkKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB4ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5LmN1cnNvckZuKHJlc3VsdCkpXG4gICAgICByb3dzID0gMFxuICAgICAgeCA9PT0gQ0xPU0VcbiAgICAgICAgPyB3cml0ZShDbG9zZShxdWVyeS5wb3J0YWwpKVxuICAgICAgICA6IChyZXN1bHQgPSBuZXcgUmVzdWx0KCksIHdyaXRlKEV4ZWN1dGUoJycsIHF1ZXJ5LmN1cnNvclJvd3MpKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHdyaXRlKFN5bmMpXG4gICAgICBxdWVyeS5yZWplY3QoZXJyKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIENsb3NlQ29tcGxldGUoKSB7XG4gICAgcmVzdWx0LmNvdW50ICYmIHF1ZXJ5LmN1cnNvckZuKHJlc3VsdClcbiAgICBxdWVyeS5yZXNvbHZlKHJlc3VsdClcbiAgfVxuXG4gIGZ1bmN0aW9uIENvcHlJblJlc3BvbnNlKCkge1xuICAgIHN0cmVhbSA9IG5ldyBTdHJlYW0uV3JpdGFibGUoe1xuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShiKCkuZCgpLnJhdyhjaHVuaykuZW5kKCksIGNhbGxiYWNrKVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3koZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKVxuICAgICAgICBzb2NrZXQud3JpdGUoYigpLmYoKS5zdHIoZXJyb3IgKyBiLk4pLmVuZCgpKVxuICAgICAgICBzdHJlYW0gPSBudWxsXG4gICAgICB9LFxuICAgICAgZmluYWwoY2FsbGJhY2spIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGIoKS5jKCkuZW5kKCkpXG4gICAgICAgIGZpbmFsID0gY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9KVxuICAgIHF1ZXJ5LnJlc29sdmUoc3RyZWFtKVxuICB9XG5cbiAgZnVuY3Rpb24gQ29weU91dFJlc3BvbnNlKCkge1xuICAgIHN0cmVhbSA9IG5ldyBTdHJlYW0uUmVhZGFibGUoe1xuICAgICAgcmVhZCgpIHsgc29ja2V0LnJlc3VtZSgpIH1cbiAgICB9KVxuICAgIHF1ZXJ5LnJlc29sdmUoc3RyZWFtKVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBmdW5jdGlvbiBDb3B5Qm90aFJlc3BvbnNlKCkge1xuICAgIHN0cmVhbSA9IG5ldyBTdHJlYW0uRHVwbGV4KHtcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZCgpIHsgc29ja2V0LnJlc3VtZSgpIH0sXG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAxMSAqL1xuICAgICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBzb2NrZXQud3JpdGUoYigpLmQoKS5yYXcoY2h1bmspLmVuZCgpLCBjYWxsYmFjaylcbiAgICAgIH0sXG4gICAgICBkZXN0cm95KGVycm9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhlcnJvcilcbiAgICAgICAgc29ja2V0LndyaXRlKGIoKS5mKCkuc3RyKGVycm9yICsgYi5OKS5lbmQoKSlcbiAgICAgICAgc3RyZWFtID0gbnVsbFxuICAgICAgfSxcbiAgICAgIGZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShiKCkuYygpLmVuZCgpKVxuICAgICAgICBmaW5hbCA9IGNhbGxiYWNrXG4gICAgICB9XG4gICAgfSlcbiAgICBxdWVyeS5yZXNvbHZlKHN0cmVhbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIENvcHlEYXRhKHgpIHtcbiAgICBzdHJlYW0gJiYgKHN0cmVhbS5wdXNoKHguc3ViYXJyYXkoNSkpIHx8IHNvY2tldC5wYXVzZSgpKVxuICB9XG5cbiAgZnVuY3Rpb24gQ29weURvbmUoKSB7XG4gICAgc3RyZWFtICYmIHN0cmVhbS5wdXNoKG51bGwpXG4gICAgc3RyZWFtID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gTm90aWNlUmVzcG9uc2UoeCkge1xuICAgIG9ubm90aWNlXG4gICAgICA/IG9ubm90aWNlKHBhcnNlRXJyb3IoeCkpXG4gICAgICA6IGNvbnNvbGUubG9nKHBhcnNlRXJyb3IoeCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBmdW5jdGlvbiBFbXB0eVF1ZXJ5UmVzcG9uc2UoKSB7XG4gICAgLyogbm9vcCAqL1xuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBmdW5jdGlvbiBGdW5jdGlvbkNhbGxSZXNwb25zZSgpIHtcbiAgICBlcnJvcmVkKEVycm9ycy5ub3RTdXBwb3J0ZWQoJ0Z1bmN0aW9uQ2FsbFJlc3BvbnNlJykpXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIE5lZ290aWF0ZVByb3RvY29sVmVyc2lvbigpIHtcbiAgICBlcnJvcmVkKEVycm9ycy5ub3RTdXBwb3J0ZWQoJ05lZ290aWF0ZVByb3RvY29sVmVyc2lvbicpKVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBmdW5jdGlvbiBVbmtub3duTWVzc2FnZSh4KSB7XG4gICAgY29uc29sZS5lcnJvcignUG9zdGdyZXMuanMgOiBVbmtub3duIE1lc3NhZ2U6JywgeFswXSkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBmdW5jdGlvbiBVbmtub3duQXV0aCh4LCB0eXBlKSB7XG4gICAgY29uc29sZS5lcnJvcignUG9zdGdyZXMuanMgOiBVbmtub3duIEF1dGg6JywgdHlwZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgLyogTWVzc2FnZXMgKi9cbiAgZnVuY3Rpb24gQmluZChwYXJhbWV0ZXJzLCB0eXBlcywgc3RhdGVtZW50ID0gJycsIHBvcnRhbCA9ICcnKSB7XG4gICAgbGV0IHByZXZcbiAgICAgICwgdHlwZVxuXG4gICAgYigpLkIoKS5zdHIocG9ydGFsICsgYi5OKS5zdHIoc3RhdGVtZW50ICsgYi5OKS5pMTYoMCkuaTE2KHBhcmFtZXRlcnMubGVuZ3RoKVxuXG4gICAgcGFyYW1ldGVycy5mb3JFYWNoKCh4LCBpKSA9PiB7XG4gICAgICBpZiAoeCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGIuaTMyKDB4RkZGRkZGRkYpXG5cbiAgICAgIHR5cGUgPSB0eXBlc1tpXVxuICAgICAgcGFyYW1ldGVyc1tpXSA9IHggPSB0eXBlIGluIG9wdGlvbnMuc2VyaWFsaXplcnNcbiAgICAgICAgPyBvcHRpb25zLnNlcmlhbGl6ZXJzW3R5cGVdKHgpXG4gICAgICAgIDogJycgKyB4XG5cbiAgICAgIHByZXYgPSBiLmlcbiAgICAgIGIuaW5jKDQpLnN0cih4KS5pMzIoYi5pIC0gcHJldiAtIDQsIHByZXYpXG4gICAgfSlcblxuICAgIGIuaTE2KDApXG5cbiAgICByZXR1cm4gYi5lbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gUGFyc2Uoc3RyLCBwYXJhbWV0ZXJzLCB0eXBlcywgbmFtZSA9ICcnKSB7XG4gICAgYigpLlAoKS5zdHIobmFtZSArIGIuTikuc3RyKHN0ciArIGIuTikuaTE2KHBhcmFtZXRlcnMubGVuZ3RoKVxuICAgIHBhcmFtZXRlcnMuZm9yRWFjaCgoeCwgaSkgPT4gYi5pMzIodHlwZXNbaV0gfHwgMCkpXG4gICAgcmV0dXJuIGIuZW5kKClcbiAgfVxuXG4gIGZ1bmN0aW9uIERlc2NyaWJlKHgsIG5hbWUgPSAnJykge1xuICAgIHJldHVybiBiKCkuRCgpLnN0cih4KS5zdHIobmFtZSArIGIuTikuZW5kKClcbiAgfVxuXG4gIGZ1bmN0aW9uIEV4ZWN1dGUocG9ydGFsID0gJycsIHJvd3MgPSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgYigpLkUoKS5zdHIocG9ydGFsICsgYi5OKS5pMzIocm93cykuZW5kKCksXG4gICAgICBGbHVzaFxuICAgIF0pXG4gIH1cblxuICBmdW5jdGlvbiBDbG9zZShwb3J0YWwgPSAnJykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGIoKS5DKCkuc3RyKCdQJykuc3RyKHBvcnRhbCArIGIuTikuZW5kKCksXG4gICAgICBiKCkuUygpLmVuZCgpXG4gICAgXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFN0YXJ0dXBNZXNzYWdlKCkge1xuICAgIHJldHVybiBjYW5jZWxNZXNzYWdlIHx8IGIoKS5pbmMoNCkuaTE2KDMpLnooMikuc3RyKFxuICAgICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHVzZXIsXG4gICAgICAgIGRhdGFiYXNlLFxuICAgICAgICBjbGllbnRfZW5jb2Rpbmc6ICdVVEY4J1xuICAgICAgfSxcbiAgICAgICAgb3B0aW9ucy5jb25uZWN0aW9uXG4gICAgICApKS5maWx0ZXIoKFssIHZdKSA9PiB2KS5tYXAoKFtrLCB2XSkgPT4gayArIGIuTiArIHYpLmpvaW4oYi5OKVxuICAgICkueigyKS5lbmQoMClcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBhcnNlRXJyb3IoeCkge1xuICBjb25zdCBlcnJvciA9IHt9XG4gIGxldCBzdGFydCA9IDVcbiAgZm9yIChsZXQgaSA9IDU7IGkgPCB4Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh4W2ldID09PSAwKSB7XG4gICAgICBlcnJvcltlcnJvckZpZWxkc1t4W3N0YXJ0XV1dID0geC50b1N0cmluZygndXRmOCcsIHN0YXJ0ICsgMSwgaSlcbiAgICAgIHN0YXJ0ID0gaSArIDFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycm9yXG59XG5cbmZ1bmN0aW9uIG1kNSh4KSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHgpLmRpZ2VzdCgnaGV4Jylcbn1cblxuZnVuY3Rpb24gaG1hYyhrZXksIHgpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpLnVwZGF0ZSh4KS5kaWdlc3QoKVxufVxuXG5mdW5jdGlvbiBzaGEyNTYoeCkge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZSh4KS5kaWdlc3QoKVxufVxuXG5mdW5jdGlvbiB4b3IoYSwgYikge1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgYnVmZmVyW2ldID0gYVtpXSBeIGJbaV1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiB0aW1lcihmbiwgc2Vjb25kcykge1xuICBzZWNvbmRzID0gdHlwZW9mIHNlY29uZHMgPT09ICdmdW5jdGlvbicgPyBzZWNvbmRzKCkgOiBzZWNvbmRzXG4gIGlmICghc2Vjb25kcylcbiAgICByZXR1cm4geyBjYW5jZWw6IG5vb3AsIHN0YXJ0OiBub29wIH1cblxuICBsZXQgdGltZXJcbiAgcmV0dXJuIHtcbiAgICBjYW5jZWwoKSB7XG4gICAgICB0aW1lciAmJiAoY2xlYXJUaW1lb3V0KHRpbWVyKSwgdGltZXIgPSBudWxsKVxuICAgIH0sXG4gICAgc3RhcnQoKSB7XG4gICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZG9uZSwgc2Vjb25kcyAqIDEwMDAsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb25lKGFyZ3MpIHtcbiAgICBmbi5hcHBseShudWxsLCBhcmdzKVxuICAgIHRpbWVyID0gbnVsbFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/connection.js":
/*!*************************************************!*\
  !*** ./node_modules/postgres/src/connection.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tls */ \"tls\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var perf_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/postgres/src/types.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/postgres/src/errors.js\");\n/* harmony import */ var _result_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./result.js */ \"(rsc)/./node_modules/postgres/src/result.js\");\n/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./queue.js */ \"(rsc)/./node_modules/postgres/src/queue.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./query.js */ \"(rsc)/./node_modules/postgres/src/query.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./bytes.js */ \"(rsc)/./node_modules/postgres/src/bytes.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Connection);\n\nlet uid = 1\n\nconst Sync = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().S().end()\n    , Flush = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().H().end()\n    , SSLRequest = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().i32(8).i32(80877103).end(8)\n    , ExecuteUnnamed = Buffer.concat([(0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().E().str(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i32(0).end(), Sync])\n    , DescribeUnnamed = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().D().str('S').str(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end()\n    , noop = () => { /* noop */ }\n\nconst retryRoutines = new Set([\n  'FetchPreparedStatement',\n  'RevalidateCachedQuery',\n  'transformAssignedExpr'\n])\n\nconst errorFields = {\n  83  : 'severity_local',    // S\n  86  : 'severity',          // V\n  67  : 'code',              // C\n  77  : 'message',           // M\n  68  : 'detail',            // D\n  72  : 'hint',              // H\n  80  : 'position',          // P\n  112 : 'internal_position', // p\n  113 : 'internal_query',    // q\n  87  : 'where',             // W\n  115 : 'schema_name',       // s\n  116 : 'table_name',        // t\n  99  : 'column_name',       // c\n  100 : 'data type_name',    // d\n  110 : 'constraint_name',   // n\n  70  : 'file',              // F\n  76  : 'line',              // L\n  82  : 'routine'            // R\n}\n\nfunction Connection(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {\n  const {\n    ssl,\n    max,\n    user,\n    host,\n    port,\n    database,\n    parsers,\n    transform,\n    onnotice,\n    onnotify,\n    onparameter,\n    max_pipeline,\n    keep_alive,\n    backoff,\n    target_session_attrs\n  } = options\n\n  const sent = (0,_queue_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])()\n      , id = uid++\n      , backend = { pid: null, secret: null }\n      , idleTimer = timer(end, options.idle_timeout)\n      , lifeTimer = timer(end, options.max_lifetime)\n      , connectTimer = timer(connectTimedOut, options.connect_timeout)\n\n  let socket = null\n    , cancelMessage\n    , result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]()\n    , incoming = Buffer.alloc(0)\n    , needsTypes = options.fetch_types\n    , backendParameters = {}\n    , statements = {}\n    , statementId = Math.random().toString(36).slice(2)\n    , statementCount = 1\n    , closedDate = 0\n    , remaining = 0\n    , hostIndex = 0\n    , retries = 0\n    , length = 0\n    , delay = 0\n    , rows = 0\n    , serverSignature = null\n    , nextWriteTimer = null\n    , terminated = false\n    , incomings = null\n    , results = null\n    , initial = null\n    , ending = null\n    , stream = null\n    , chunk = null\n    , ended = null\n    , nonce = null\n    , query = null\n    , final = null\n\n  const connection = {\n    queue: queues.closed,\n    idleTimer,\n    connect(query) {\n      initial = query\n      reconnect()\n    },\n    terminate,\n    execute,\n    cancel,\n    end,\n    count: 0,\n    id\n  }\n\n  queues.closed && queues.closed.push(connection)\n\n  return connection\n\n  async function createSocket() {\n    let x\n    try {\n      x = options.socket\n        ? (await Promise.resolve(options.socket(options)))\n        : new net__WEBPACK_IMPORTED_MODULE_0__.Socket()\n    } catch (e) {\n      error(e)\n      return\n    }\n    x.on('error', error)\n    x.on('close', closed)\n    x.on('drain', drain)\n    return x\n  }\n\n  async function cancel({ pid, secret }, resolve, reject) {\n    try {\n      cancelMessage = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().i32(16).i32(80877102).i32(pid).i32(secret).end(16)\n      await connect()\n      socket.once('error', reject)\n      socket.once('close', resolve)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  function execute(q) {\n    if (terminated)\n      return queryError(q, _errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_DESTROYED', options))\n\n    if (q.cancelled)\n      return\n\n    try {\n      q.state = backend\n      query\n        ? sent.push(q)\n        : (query = q, query.active = true)\n\n      build(q)\n      return write(toBuffer(q))\n        && !q.describeFirst\n        && !q.cursorFn\n        && sent.length < max_pipeline\n        && (!q.options.onexecute || q.options.onexecute(connection))\n    } catch (error) {\n      sent.length === 0 && write(Sync)\n      errored(error)\n      return true\n    }\n  }\n\n  function toBuffer(q) {\n    if (q.parameters.length >= 65534)\n      throw _errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('MAX_PARAMETERS_EXCEEDED', 'Max number of parameters (65534) exceeded')\n\n    return q.options.simple\n      ? (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().Q().str(q.statement.string + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end()\n      : q.describeFirst\n        ? Buffer.concat([describe(q), Flush])\n        : q.prepare\n          ? q.prepared\n            ? prepared(q)\n            : Buffer.concat([describe(q), prepared(q)])\n          : unnamed(q)\n  }\n\n  function describe(q) {\n    return Buffer.concat([\n      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),\n      Describe('S', q.statement.name)\n    ])\n  }\n\n  function prepared(q) {\n    return Buffer.concat([\n      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),\n      q.cursorFn\n        ? Execute('', q.cursorRows)\n        : ExecuteUnnamed\n    ])\n  }\n\n  function unnamed(q) {\n    return Buffer.concat([\n      Parse(q.statement.string, q.parameters, q.statement.types),\n      DescribeUnnamed,\n      prepared(q)\n    ])\n  }\n\n  function build(q) {\n    const parameters = []\n        , types = []\n\n    const string = (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.stringify)(q, q.strings[0], q.args[0], parameters, types, options)\n\n    !q.tagged && q.args.forEach(x => (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.handleValue)(x, parameters, types, options))\n\n    q.prepare = options.prepare && ('prepare' in q.options ? q.options.prepare : true)\n    q.string = string\n    q.signature = q.prepare && types + string\n    q.onlyDescribe && (delete statements[q.signature])\n    q.parameters = q.parameters || parameters\n    q.prepared = q.prepare && q.signature in statements\n    q.describeFirst = q.onlyDescribe || (parameters.length && !q.prepared)\n    q.statement = q.prepared\n      ? statements[q.signature]\n      : { string, types, name: q.prepare ? statementId + statementCount++ : '' }\n\n    typeof options.debug === 'function' && options.debug(id, string, parameters, types)\n  }\n\n  function write(x, fn) {\n    chunk = chunk ? Buffer.concat([chunk, x]) : Buffer.from(x)\n    if (fn || chunk.length >= 1024)\n      return nextWrite(fn)\n    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite))\n    return true\n  }\n\n  function nextWrite(fn) {\n    const x = socket.write(chunk, fn)\n    nextWriteTimer !== null && clearImmediate(nextWriteTimer)\n    chunk = nextWriteTimer = null\n    return x\n  }\n\n  function connectTimedOut() {\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECT_TIMEOUT', options, socket))\n    socket.destroy()\n  }\n\n  async function secure() {\n    write(SSLRequest)\n    const canSSL = await new Promise(r => socket.once('data', x => r(x[0] === 83))) // S\n\n    if (!canSSL && ssl === 'prefer')\n      return connected()\n\n    socket.removeAllListeners()\n    socket = tls__WEBPACK_IMPORTED_MODULE_1__.connect({\n      socket,\n      servername: net__WEBPACK_IMPORTED_MODULE_0__.isIP(socket.host) ? undefined : socket.host,\n      ...(ssl === 'require' || ssl === 'allow' || ssl === 'prefer'\n        ? { rejectUnauthorized: false }\n        : ssl === 'verify-full'\n          ? {}\n          : typeof ssl === 'object'\n            ? ssl\n            : {}\n      )\n    })\n    socket.on('secureConnect', connected)\n    socket.on('error', error)\n    socket.on('close', closed)\n    socket.on('drain', drain)\n  }\n\n  /* c8 ignore next 3 */\n  function drain() {\n    !query && onopen(connection)\n  }\n\n  function data(x) {\n    if (incomings) {\n      incomings.push(x)\n      remaining -= x.length\n      if (remaining >= 0)\n        return\n    }\n\n    incoming = incomings\n      ? Buffer.concat(incomings, length - remaining)\n      : incoming.length === 0\n        ? x\n        : Buffer.concat([incoming, x], incoming.length + x.length)\n\n    while (incoming.length > 4) {\n      length = incoming.readUInt32BE(1)\n      if (length >= incoming.length) {\n        remaining = length - incoming.length\n        incomings = [incoming]\n        break\n      }\n\n      try {\n        handle(incoming.subarray(0, length + 1))\n      } catch (e) {\n        query && (query.cursorFn || query.describeFirst) && write(Sync)\n        errored(e)\n      }\n      incoming = incoming.subarray(length + 1)\n      remaining = 0\n      incomings = null\n    }\n  }\n\n  async function connect() {\n    terminated = false\n    backendParameters = {}\n    socket || (socket = await createSocket())\n\n    if (!socket)\n      return\n\n    connectTimer.start()\n\n    if (options.socket)\n      return ssl ? secure() : connected()\n\n    socket.on('connect', ssl ? secure : connected)\n\n    if (options.path)\n      return socket.connect(options.path)\n\n    socket.ssl = ssl\n    socket.connect(port[hostIndex], host[hostIndex])\n    socket.host = host[hostIndex]\n    socket.port = port[hostIndex]\n\n    hostIndex = (hostIndex + 1) % port.length\n  }\n\n  function reconnect() {\n    setTimeout(connect, closedDate ? closedDate + delay - perf_hooks__WEBPACK_IMPORTED_MODULE_4__.performance.now() : 0)\n  }\n\n  function connected() {\n    try {\n      statements = {}\n      needsTypes = options.fetch_types\n      statementId = Math.random().toString(36).slice(2)\n      statementCount = 1\n      lifeTimer.start()\n      socket.on('data', data)\n      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive)\n      const s = StartupMessage()\n      write(s)\n    } catch (err) {\n      error(err)\n    }\n  }\n\n  function error(err) {\n    if (connection.queue === queues.connecting && options.host[retries + 1])\n      return\n\n    errored(err)\n    while (sent.length)\n      queryError(sent.shift(), err)\n  }\n\n  function errored(err) {\n    stream && (stream.destroy(err), stream = null)\n    query && queryError(query, err)\n    initial && (queryError(initial, err), initial = null)\n  }\n\n  function queryError(query, err) {\n    query.reject(Object.create(err, {\n      stack: { value: err.stack + query.origin.replace(/.*\\n/, '\\n'), enumerable: options.debug },\n      query: { value: query.string, enumerable: options.debug },\n      parameters: { value: query.parameters, enumerable: options.debug },\n      args: { value: query.args, enumerable: options.debug },\n      types: { value: query.statement && query.statement.types, enumerable: options.debug }\n    }))\n  }\n\n  function end() {\n    return ending || (\n      !connection.reserved && onend(connection),\n      !connection.reserved && !initial && !query && sent.length === 0\n        ? (terminate(), new Promise(r => socket && socket.readyState !== 'closed' ? socket.once('close', r) : r()))\n        : ending = new Promise(r => ended = r)\n    )\n  }\n\n  function terminate() {\n    terminated = true\n    if (stream || query || initial || sent.length)\n      error(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_DESTROYED', options))\n\n    clearImmediate(nextWriteTimer)\n    if (socket) {\n      socket.removeListener('data', data)\n      socket.removeListener('connect', connected)\n      socket.readyState === 'open' && socket.end((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().X().end())\n    }\n    ended && (ended(), ending = ended = null)\n  }\n\n  async function closed(hadError) {\n    incoming = Buffer.alloc(0)\n    remaining = 0\n    incomings = null\n    clearImmediate(nextWriteTimer)\n    socket.removeListener('data', data)\n    socket.removeListener('connect', connected)\n    idleTimer.cancel()\n    lifeTimer.cancel()\n    connectTimer.cancel()\n\n    if (socket.encrypted) {\n      socket.removeAllListeners()\n      socket = null\n    }\n\n    if (initial)\n      return reconnect()\n\n    !hadError && (query || sent.length) && error(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_CLOSED', options, socket))\n    closedDate = perf_hooks__WEBPACK_IMPORTED_MODULE_4__.performance.now()\n    hadError && options.shared.retries++\n    delay = (typeof backoff === 'function' ? backoff(options.shared.retries) : backoff) * 1000\n    onclose(connection)\n  }\n\n  /* Handlers */\n  function handle(xs, x = xs[0]) {\n    (\n      x === 68 ? DataRow :                   // D\n      x === 100 ? CopyData :                 // d\n      x === 65 ? NotificationResponse :      // A\n      x === 83 ? ParameterStatus :           // S\n      x === 90 ? ReadyForQuery :             // Z\n      x === 67 ? CommandComplete :           // C\n      x === 50 ? BindComplete :              // 2\n      x === 49 ? ParseComplete :             // 1\n      x === 116 ? ParameterDescription :     // t\n      x === 84 ? RowDescription :            // T\n      x === 82 ? Authentication :            // R\n      x === 110 ? NoData :                   // n\n      x === 75 ? BackendKeyData :            // K\n      x === 69 ? ErrorResponse :             // E\n      x === 115 ? PortalSuspended :          // s\n      x === 51 ? CloseComplete :             // 3\n      x === 71 ? CopyInResponse :            // G\n      x === 78 ? NoticeResponse :            // N\n      x === 72 ? CopyOutResponse :           // H\n      x === 99 ? CopyDone :                  // c\n      x === 73 ? EmptyQueryResponse :        // I\n      x === 86 ? FunctionCallResponse :      // V\n      x === 118 ? NegotiateProtocolVersion : // v\n      x === 87 ? CopyBothResponse :          // W\n      /* c8 ignore next */\n      UnknownMessage\n    )(xs)\n  }\n\n  function DataRow(x) {\n    let index = 7\n    let length\n    let column\n    let value\n\n    const row = query.isRaw ? new Array(query.statement.columns.length) : {}\n    for (let i = 0; i < query.statement.columns.length; i++) {\n      column = query.statement.columns[i]\n      length = x.readInt32BE(index)\n      index += 4\n\n      value = length === -1\n        ? null\n        : query.isRaw === true\n          ? x.subarray(index, index += length)\n          : column.parser === undefined\n            ? x.toString('utf8', index, index += length)\n            : column.parser.array === true\n              ? column.parser(x.toString('utf8', index + 1, index += length))\n              : column.parser(x.toString('utf8', index, index += length))\n\n      query.isRaw\n        ? (row[i] = query.isRaw === true\n          ? value\n          : transform.value.from ? transform.value.from(value, column) : value)\n        : (row[column.name] = transform.value.from ? transform.value.from(value, column) : value)\n    }\n\n    query.forEachFn\n      ? query.forEachFn(transform.row.from ? transform.row.from(row) : row, result)\n      : (result[rows++] = transform.row.from ? transform.row.from(row) : row)\n  }\n\n  function ParameterStatus(x) {\n    const [k, v] = x.toString('utf8', 5, x.length - 1).split(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N)\n    backendParameters[k] = v\n    if (options.parameters[k] !== v) {\n      options.parameters[k] = v\n      onparameter && onparameter(k, v)\n    }\n  }\n\n  function ReadyForQuery(x) {\n    query && query.options.simple && query.resolve(results || result)\n    query = results = null\n    result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]()\n    connectTimer.cancel()\n\n    if (initial) {\n      if (target_session_attrs) {\n        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)\n          return fetchState()\n        else if (tryNext(target_session_attrs, backendParameters))\n          return terminate()\n      }\n\n      if (needsTypes)\n        return fetchArrayTypes()\n\n      execute(initial)\n      options.shared.retries = retries = initial = 0\n      return\n    }\n\n    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))\n      Connection(options).cancel(query.state, query.cancelled.resolve, query.cancelled.reject)\n\n    if (query)\n      return // Consider opening if able and sent.length < 50\n\n    connection.reserved\n      ? !connection.reserved.release && x[5] === 73 // I\n        ? ending\n          ? terminate()\n          : (connection.reserved = null, onopen(connection))\n        : connection.reserved()\n      : ending\n        ? terminate()\n        : onopen(connection)\n  }\n\n  function CommandComplete(x) {\n    rows = 0\n\n    for (let i = x.length - 1; i > 0; i--) {\n      if (x[i] === 32 && x[i + 1] < 58 && result.count === null)\n        result.count = +x.toString('utf8', i + 1, x.length - 1)\n      if (x[i - 1] >= 65) {\n        result.command = x.toString('utf8', 5, i)\n        result.state = backend\n        break\n      }\n    }\n\n    final && (final(), final = null)\n\n    if (result.command === 'BEGIN' && max !== 1 && !connection.reserved)\n      return errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('UNSAFE_TRANSACTION', 'Only use sql.begin, sql.reserved or max: 1'))\n\n    if (query.options.simple)\n      return BindComplete()\n\n    if (query.cursorFn) {\n      result.count && query.cursorFn(result)\n      write(Sync)\n    }\n\n    query.resolve(result)\n  }\n\n  function ParseComplete() {\n    query.parsing = false\n  }\n\n  function BindComplete() {\n    !result.statement && (result.statement = query.statement)\n    result.columns = query.statement.columns\n  }\n\n  function ParameterDescription(x) {\n    const length = x.readUInt16BE(5)\n\n    for (let i = 0; i < length; ++i)\n      !query.statement.types[i] && (query.statement.types[i] = x.readUInt32BE(7 + i * 4))\n\n    query.prepare && (statements[query.signature] = query.statement)\n    query.describeFirst && !query.onlyDescribe && (write(prepared(query)), query.describeFirst = false)\n  }\n\n  function RowDescription(x) {\n    if (result.command) {\n      results = results || [result]\n      results.push(result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]())\n      result.count = null\n      query.statement.columns = null\n    }\n\n    const length = x.readUInt16BE(5)\n    let index = 7\n    let start\n\n    query.statement.columns = Array(length)\n\n    for (let i = 0; i < length; ++i) {\n      start = index\n      while (x[index++] !== 0);\n      const table = x.readUInt32BE(index)\n      const number = x.readUInt16BE(index + 4)\n      const type = x.readUInt32BE(index + 6)\n      query.statement.columns[i] = {\n        name: transform.column.from\n          ? transform.column.from(x.toString('utf8', start, index - 1))\n          : x.toString('utf8', start, index - 1),\n        parser: parsers[type],\n        table,\n        number,\n        type\n      }\n      index += 18\n    }\n\n    result.statement = query.statement\n    if (query.onlyDescribe)\n      return (query.resolve(query.statement), write(Sync))\n  }\n\n  async function Authentication(x, type = x.readUInt32BE(5)) {\n    (\n      type === 3 ? AuthenticationCleartextPassword :\n      type === 5 ? AuthenticationMD5Password :\n      type === 10 ? SASL :\n      type === 11 ? SASLContinue :\n      type === 12 ? SASLFinal :\n      type !== 0 ? UnknownAuth :\n      noop\n    )(x, type)\n  }\n\n  /* c8 ignore next 5 */\n  async function AuthenticationCleartextPassword() {\n    write(\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str(await Pass()).z(1).end()\n    )\n  }\n\n  async function AuthenticationMD5Password(x) {\n    write(\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str(\n        'md5' +\n        (await md5(Buffer.concat([\n          Buffer.from(await md5((await Pass()) + user)),\n          x.subarray(9)\n        ])))\n      ).z(1).end()\n    )\n  }\n\n  async function SASL() {\n    (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str('SCRAM-SHA-256' + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N)\n    const i = _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i\n    nonce = (await crypto__WEBPACK_IMPORTED_MODULE_2__.randomBytes(18)).toString('base64')\n    write(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].inc(4).str('n,,n=*,r=' + nonce).i32(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i - i - 4, i).end())\n  }\n\n  async function SASLContinue(x) {\n    const res = x.toString('utf8', 9).split(',').reduce((acc, x) => (acc[x[0]] = x.slice(2), acc), {})\n\n    const saltedPassword = await crypto__WEBPACK_IMPORTED_MODULE_2__.pbkdf2Sync(\n      await Pass(),\n      Buffer.from(res.s, 'base64'),\n      parseInt(res.i), 32,\n      'sha256'\n    )\n\n    const clientKey = await hmac(saltedPassword, 'Client Key')\n\n    const auth = 'n=*,r=' + nonce + ','\n               + 'r=' + res.r + ',s=' + res.s + ',i=' + res.i\n               + ',c=biws,r=' + res.r\n\n    serverSignature = (await hmac(await hmac(saltedPassword, 'Server Key'), auth)).toString('base64')\n\n    write(\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().p().str(\n        'c=biws,r=' + res.r + ',p=' + xor(\n          clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))\n        ).toString('base64')\n      ).end()\n    )\n  }\n\n  function SASLFinal(x) {\n    if (x.toString('utf8', 9).split(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N, 1)[0].slice(2) === serverSignature)\n      return\n    /* c8 ignore next 5 */\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('SASL_SIGNATURE_MISMATCH', 'The server did not return the correct signature'))\n    socket.destroy()\n  }\n\n  function Pass() {\n    return Promise.resolve(typeof options.pass === 'function'\n      ? options.pass()\n      : options.pass\n    )\n  }\n\n  function NoData() {\n    result.statement = query.statement\n    result.statement.columns = []\n    if (query.onlyDescribe)\n      return (query.resolve(query.statement), write(Sync))\n  }\n\n  function BackendKeyData(x) {\n    backend.pid = x.readUInt32BE(5)\n    backend.secret = x.readUInt32BE(9)\n  }\n\n  async function fetchArrayTypes() {\n    needsTypes = false\n    const types = await new _query_js__WEBPACK_IMPORTED_MODULE_9__.Query([`\n      select b.oid, b.typarray\n      from pg_catalog.pg_type a\n      left join pg_catalog.pg_type b on b.oid = a.typelem\n      where a.typcategory = 'A'\n      group by b.oid, b.typarray\n      order by b.oid\n    `], [], execute)\n    types.forEach(({ oid, typarray }) => addArrayType(oid, typarray))\n  }\n\n  function addArrayType(oid, typarray) {\n    if (!!options.parsers[typarray] && !!options.serializers[typarray]) return\n    const parser = options.parsers[oid]\n    options.shared.typeArrayMap[oid] = typarray\n    options.parsers[typarray] = (xs) => (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.arrayParser)(xs, parser, typarray)\n    options.parsers[typarray].array = true\n    options.serializers[typarray] = (xs) => (0,_types_js__WEBPACK_IMPORTED_MODULE_5__.arraySerializer)(xs, options.serializers[oid], options, typarray)\n  }\n\n  function tryNext(x, xs) {\n    return (\n      (x === 'read-write' && xs.default_transaction_read_only === 'on') ||\n      (x === 'read-only' && xs.default_transaction_read_only === 'off') ||\n      (x === 'primary' && xs.in_hot_standby === 'on') ||\n      (x === 'standby' && xs.in_hot_standby === 'off') ||\n      (x === 'prefer-standby' && xs.in_hot_standby === 'off' && options.host[retries])\n    )\n  }\n\n  function fetchState() {\n    const query = new _query_js__WEBPACK_IMPORTED_MODULE_9__.Query([`\n      show transaction_read_only;\n      select pg_catalog.pg_is_in_recovery()\n    `], [], execute, null, { simple: true })\n    query.resolve = ([[a], [b]]) => {\n      backendParameters.default_transaction_read_only = a.transaction_read_only\n      backendParameters.in_hot_standby = b.pg_is_in_recovery ? 'on' : 'off'\n    }\n    query.execute()\n  }\n\n  function ErrorResponse(x) {\n    query && (query.cursorFn || query.describeFirst) && write(Sync)\n    const error = _errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.postgres(parseError(x))\n    query && query.retried\n      ? errored(query.retried)\n      : query && retryRoutines.has(error.routine)\n        ? retry(query, error)\n        : errored(error)\n  }\n\n  function retry(q, error) {\n    delete statements[q.signature]\n    q.retried = error\n    execute(q)\n  }\n\n  function NotificationResponse(x) {\n    if (!onnotify)\n      return\n\n    let index = 9\n    while (x[index++] !== 0);\n    onnotify(\n      x.toString('utf8', 9, index - 1),\n      x.toString('utf8', index, x.length - 1)\n    )\n  }\n\n  async function PortalSuspended() {\n    try {\n      const x = await Promise.resolve(query.cursorFn(result))\n      rows = 0\n      x === _query_js__WEBPACK_IMPORTED_MODULE_9__.CLOSE\n        ? write(Close(query.portal))\n        : (result = new _result_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](), write(Execute('', query.cursorRows)))\n    } catch (err) {\n      write(Sync)\n      query.reject(err)\n    }\n  }\n\n  function CloseComplete() {\n    result.count && query.cursorFn(result)\n    query.resolve(result)\n  }\n\n  function CopyInResponse() {\n    stream = new stream__WEBPACK_IMPORTED_MODULE_3__.Writable({\n      autoDestroy: true,\n      write(chunk, encoding, callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().d().raw(chunk).end(), callback)\n      },\n      destroy(error, callback) {\n        callback(error)\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().f().str(error + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end())\n        stream = null\n      },\n      final(callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().c().end())\n        final = callback\n      }\n    })\n    query.resolve(stream)\n  }\n\n  function CopyOutResponse() {\n    stream = new stream__WEBPACK_IMPORTED_MODULE_3__.Readable({\n      read() { socket.resume() }\n    })\n    query.resolve(stream)\n  }\n\n  /* c8 ignore next 3 */\n  function CopyBothResponse() {\n    stream = new stream__WEBPACK_IMPORTED_MODULE_3__.Duplex({\n      autoDestroy: true,\n      read() { socket.resume() },\n      /* c8 ignore next 11 */\n      write(chunk, encoding, callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().d().raw(chunk).end(), callback)\n      },\n      destroy(error, callback) {\n        callback(error)\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().f().str(error + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end())\n        stream = null\n      },\n      final(callback) {\n        socket.write((0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().c().end())\n        final = callback\n      }\n    })\n    query.resolve(stream)\n  }\n\n  function CopyData(x) {\n    stream && (stream.push(x.subarray(5)) || socket.pause())\n  }\n\n  function CopyDone() {\n    stream && stream.push(null)\n    stream = null\n  }\n\n  function NoticeResponse(x) {\n    onnotice\n      ? onnotice(parseError(x))\n      : console.log(parseError(x)) // eslint-disable-line\n\n  }\n\n  /* c8 ignore next 3 */\n  function EmptyQueryResponse() {\n    /* noop */\n  }\n\n  /* c8 ignore next 3 */\n  function FunctionCallResponse() {\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.notSupported('FunctionCallResponse'))\n  }\n\n  /* c8 ignore next 3 */\n  function NegotiateProtocolVersion() {\n    errored(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.notSupported('NegotiateProtocolVersion'))\n  }\n\n  /* c8 ignore next 3 */\n  function UnknownMessage(x) {\n    console.error('Postgres.js : Unknown Message:', x[0]) // eslint-disable-line\n  }\n\n  /* c8 ignore next 3 */\n  function UnknownAuth(x, type) {\n    console.error('Postgres.js : Unknown Auth:', type) // eslint-disable-line\n  }\n\n  /* Messages */\n  function Bind(parameters, types, statement = '', portal = '') {\n    let prev\n      , type\n\n    ;(0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().B().str(portal + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).str(statement + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i16(0).i16(parameters.length)\n\n    parameters.forEach((x, i) => {\n      if (x === null)\n        return _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i32(0xFFFFFFFF)\n\n      type = types[i]\n      parameters[i] = x = type in options.serializers\n        ? options.serializers[type](x)\n        : '' + x\n\n      prev = _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i\n      _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].inc(4).str(x).i32(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i - prev - 4, prev)\n    })\n\n    _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i16(0)\n\n    return _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].end()\n  }\n\n  function Parse(str, parameters, types, name = '') {\n    (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().P().str(name + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).str(str + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i16(parameters.length)\n    parameters.forEach((x, i) => _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].i32(types[i] || 0))\n    return _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].end()\n  }\n\n  function Describe(x, name = '') {\n    return (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().D().str(x).str(name + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end()\n  }\n\n  function Execute(portal = '', rows = 0) {\n    return Buffer.concat([\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().E().str(portal + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).i32(rows).end(),\n      Flush\n    ])\n  }\n\n  function Close(portal = '') {\n    return Buffer.concat([\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().C().str('P').str(portal + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N).end(),\n      (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().S().end()\n    ])\n  }\n\n  function StartupMessage() {\n    return cancelMessage || (0,_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])().inc(4).i16(3).z(2).str(\n      Object.entries(Object.assign({\n        user,\n        database,\n        client_encoding: 'UTF8'\n      },\n        options.connection\n      )).filter(([, v]) => v).map(([k, v]) => k + _bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N + v).join(_bytes_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].N)\n    ).z(2).end(0)\n  }\n\n}\n\nfunction parseError(x) {\n  const error = {}\n  let start = 5\n  for (let i = 5; i < x.length - 1; i++) {\n    if (x[i] === 0) {\n      error[errorFields[x[start]]] = x.toString('utf8', start + 1, i)\n      start = i + 1\n    }\n  }\n  return error\n}\n\nfunction md5(x) {\n  return crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('md5').update(x).digest('hex')\n}\n\nfunction hmac(key, x) {\n  return crypto__WEBPACK_IMPORTED_MODULE_2__.createHmac('sha256', key).update(x).digest()\n}\n\nfunction sha256(x) {\n  return crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('sha256').update(x).digest()\n}\n\nfunction xor(a, b) {\n  const length = Math.max(a.length, b.length)\n  const buffer = Buffer.allocUnsafe(length)\n  for (let i = 0; i < length; i++)\n    buffer[i] = a[i] ^ b[i]\n  return buffer\n}\n\nfunction timer(fn, seconds) {\n  seconds = typeof seconds === 'function' ? seconds() : seconds\n  if (!seconds)\n    return { cancel: noop, start: noop }\n\n  let timer\n  return {\n    cancel() {\n      timer && (clearTimeout(timer), timer = null)\n    },\n    start() {\n      timer && clearTimeout(timer)\n      timer = setTimeout(done, seconds * 1000, arguments)\n    }\n  }\n\n  function done(args) {\n    fn.apply(null, args)\n    timer = null\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXFCO0FBQ0E7QUFDTTtBQUNBO0FBQ2E7O0FBRXlDO0FBQzdDO0FBQ0o7QUFDRjtBQUNXO0FBQ2Y7O0FBRTFCLGlFQUFlLFVBQVU7O0FBRXpCOztBQUVBLGFBQWEsc0RBQUM7QUFDZCxjQUFjLHNEQUFDO0FBQ2YsbUJBQW1CLHNEQUFDO0FBQ3BCLHNDQUFzQyxzREFBQyxXQUFXLGtEQUFDO0FBQ25ELHdCQUF3QixzREFBQyxvQkFBb0Isa0RBQUM7QUFDOUMscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLElBQUksOENBQThDLElBQUk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGVBQWUscURBQUs7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQVU7QUFDeEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQSxzQkFBc0Isc0RBQUM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFNOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksOENBQU07O0FBRWxCO0FBQ0EsUUFBUSxzREFBQyxnQ0FBZ0Msa0RBQUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9EQUFTOztBQUU1QixxQ0FBcUMsc0RBQVc7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhDQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdDQUFXO0FBQ3hCO0FBQ0Esa0JBQWtCLHFDQUFRO0FBQzFCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsbURBQVc7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0ZBQWtGO0FBQ2pHLGVBQWUsZ0RBQWdEO0FBQy9ELG9CQUFvQixvREFBb0Q7QUFDeEUsY0FBYyw4Q0FBOEM7QUFDNUQsZUFBZTtBQUNmLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQU07O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNEQUFDO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCw4Q0FBTTtBQUN2RCxpQkFBaUIsbURBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsa0RBQUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrREFBTTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsOENBQU07O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFNO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFDO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHNEQUFDLDZCQUE2QixrREFBQztBQUNuQyxjQUFjLGtEQUFDO0FBQ2YsbUJBQW1CLCtDQUFrQjtBQUNyQyxVQUFVLGtEQUFDLHFDQUFxQyxrREFBQztBQUNqRDs7QUFFQTtBQUNBLHFHQUFxRzs7QUFFckcsaUNBQWlDLDhDQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sc0RBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msa0RBQUM7QUFDckM7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsNENBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzREFBVztBQUNuRDtBQUNBLDRDQUE0QywwREFBZTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNENBQUs7QUFDM0I7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQUs7QUFDakI7QUFDQSx3QkFBd0Isa0RBQU07QUFDOUIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDRDQUFlO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUM7QUFDdEIsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUMsbUJBQW1CLGtEQUFDO0FBQzFDO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUJBQXFCLHNEQUFDO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0Q0FBZTtBQUNoQyxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBYTtBQUM5QjtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUM7QUFDdEIsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQUMsbUJBQW1CLGtEQUFDO0FBQzFDO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUJBQXFCLHNEQUFDO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSx1REFBQyxvQkFBb0Isa0RBQUMsb0JBQW9CLGtEQUFDOztBQUUvQztBQUNBO0FBQ0EsZUFBZSxrREFBQzs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrREFBQztBQUNkLE1BQU0sa0RBQUMsbUJBQW1CLGtEQUFDO0FBQzNCLEtBQUs7O0FBRUwsSUFBSSxrREFBQzs7QUFFTCxXQUFXLGtEQUFDO0FBQ1o7O0FBRUE7QUFDQSxJQUFJLHNEQUFDLGtCQUFrQixrREFBQyxjQUFjLGtEQUFDO0FBQ3ZDLGlDQUFpQyxrREFBQztBQUNsQyxXQUFXLGtEQUFDO0FBQ1o7O0FBRUE7QUFDQSxXQUFXLHNEQUFDLHlCQUF5QixrREFBQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxzREFBQyxvQkFBb0Isa0RBQUM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHNEQUFDLDZCQUE2QixrREFBQztBQUNyQyxNQUFNLHNEQUFDO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixzREFBQztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtEQUFrRCxrREFBQyxhQUFhLGtEQUFDO0FBQ2pFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsOENBQWlCO0FBQzFCOztBQUVBO0FBQ0EsU0FBUyw4Q0FBaUI7QUFDMUI7O0FBRUE7QUFDQSxTQUFTLDhDQUFpQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmVjYXJkLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzL3NyYy9jb25uZWN0aW9uLmpzP2I1NjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5ldCBmcm9tICduZXQnXG5pbXBvcnQgdGxzIGZyb20gJ3RscydcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJ1xuaW1wb3J0IFN0cmVhbSBmcm9tICdzdHJlYW0nXG5pbXBvcnQgeyBwZXJmb3JtYW5jZSB9IGZyb20gJ3BlcmZfaG9va3MnXG5cbmltcG9ydCB7IHN0cmluZ2lmeSwgaGFuZGxlVmFsdWUsIGFycmF5UGFyc2VyLCBhcnJheVNlcmlhbGl6ZXIgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSAnLi9lcnJvcnMuanMnXG5pbXBvcnQgUmVzdWx0IGZyb20gJy4vcmVzdWx0LmpzJ1xuaW1wb3J0IFF1ZXVlIGZyb20gJy4vcXVldWUuanMnXG5pbXBvcnQgeyBRdWVyeSwgQ0xPU0UgfSBmcm9tICcuL3F1ZXJ5LmpzJ1xuaW1wb3J0IGIgZnJvbSAnLi9ieXRlcy5qcydcblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdGlvblxuXG5sZXQgdWlkID0gMVxuXG5jb25zdCBTeW5jID0gYigpLlMoKS5lbmQoKVxuICAgICwgRmx1c2ggPSBiKCkuSCgpLmVuZCgpXG4gICAgLCBTU0xSZXF1ZXN0ID0gYigpLmkzMig4KS5pMzIoODA4NzcxMDMpLmVuZCg4KVxuICAgICwgRXhlY3V0ZVVubmFtZWQgPSBCdWZmZXIuY29uY2F0KFtiKCkuRSgpLnN0cihiLk4pLmkzMigwKS5lbmQoKSwgU3luY10pXG4gICAgLCBEZXNjcmliZVVubmFtZWQgPSBiKCkuRCgpLnN0cignUycpLnN0cihiLk4pLmVuZCgpXG4gICAgLCBub29wID0gKCkgPT4geyAvKiBub29wICovIH1cblxuY29uc3QgcmV0cnlSb3V0aW5lcyA9IG5ldyBTZXQoW1xuICAnRmV0Y2hQcmVwYXJlZFN0YXRlbWVudCcsXG4gICdSZXZhbGlkYXRlQ2FjaGVkUXVlcnknLFxuICAndHJhbnNmb3JtQXNzaWduZWRFeHByJ1xuXSlcblxuY29uc3QgZXJyb3JGaWVsZHMgPSB7XG4gIDgzICA6ICdzZXZlcml0eV9sb2NhbCcsICAgIC8vIFNcbiAgODYgIDogJ3NldmVyaXR5JywgICAgICAgICAgLy8gVlxuICA2NyAgOiAnY29kZScsICAgICAgICAgICAgICAvLyBDXG4gIDc3ICA6ICdtZXNzYWdlJywgICAgICAgICAgIC8vIE1cbiAgNjggIDogJ2RldGFpbCcsICAgICAgICAgICAgLy8gRFxuICA3MiAgOiAnaGludCcsICAgICAgICAgICAgICAvLyBIXG4gIDgwICA6ICdwb3NpdGlvbicsICAgICAgICAgIC8vIFBcbiAgMTEyIDogJ2ludGVybmFsX3Bvc2l0aW9uJywgLy8gcFxuICAxMTMgOiAnaW50ZXJuYWxfcXVlcnknLCAgICAvLyBxXG4gIDg3ICA6ICd3aGVyZScsICAgICAgICAgICAgIC8vIFdcbiAgMTE1IDogJ3NjaGVtYV9uYW1lJywgICAgICAgLy8gc1xuICAxMTYgOiAndGFibGVfbmFtZScsICAgICAgICAvLyB0XG4gIDk5ICA6ICdjb2x1bW5fbmFtZScsICAgICAgIC8vIGNcbiAgMTAwIDogJ2RhdGEgdHlwZV9uYW1lJywgICAgLy8gZFxuICAxMTAgOiAnY29uc3RyYWludF9uYW1lJywgICAvLyBuXG4gIDcwICA6ICdmaWxlJywgICAgICAgICAgICAgIC8vIEZcbiAgNzYgIDogJ2xpbmUnLCAgICAgICAgICAgICAgLy8gTFxuICA4MiAgOiAncm91dGluZScgICAgICAgICAgICAvLyBSXG59XG5cbmZ1bmN0aW9uIENvbm5lY3Rpb24ob3B0aW9ucywgcXVldWVzID0ge30sIHsgb25vcGVuID0gbm9vcCwgb25lbmQgPSBub29wLCBvbmNsb3NlID0gbm9vcCB9ID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNzbCxcbiAgICBtYXgsXG4gICAgdXNlcixcbiAgICBob3N0LFxuICAgIHBvcnQsXG4gICAgZGF0YWJhc2UsXG4gICAgcGFyc2VycyxcbiAgICB0cmFuc2Zvcm0sXG4gICAgb25ub3RpY2UsXG4gICAgb25ub3RpZnksXG4gICAgb25wYXJhbWV0ZXIsXG4gICAgbWF4X3BpcGVsaW5lLFxuICAgIGtlZXBfYWxpdmUsXG4gICAgYmFja29mZixcbiAgICB0YXJnZXRfc2Vzc2lvbl9hdHRyc1xuICB9ID0gb3B0aW9uc1xuXG4gIGNvbnN0IHNlbnQgPSBRdWV1ZSgpXG4gICAgICAsIGlkID0gdWlkKytcbiAgICAgICwgYmFja2VuZCA9IHsgcGlkOiBudWxsLCBzZWNyZXQ6IG51bGwgfVxuICAgICAgLCBpZGxlVGltZXIgPSB0aW1lcihlbmQsIG9wdGlvbnMuaWRsZV90aW1lb3V0KVxuICAgICAgLCBsaWZlVGltZXIgPSB0aW1lcihlbmQsIG9wdGlvbnMubWF4X2xpZmV0aW1lKVxuICAgICAgLCBjb25uZWN0VGltZXIgPSB0aW1lcihjb25uZWN0VGltZWRPdXQsIG9wdGlvbnMuY29ubmVjdF90aW1lb3V0KVxuXG4gIGxldCBzb2NrZXQgPSBudWxsXG4gICAgLCBjYW5jZWxNZXNzYWdlXG4gICAgLCByZXN1bHQgPSBuZXcgUmVzdWx0KClcbiAgICAsIGluY29taW5nID0gQnVmZmVyLmFsbG9jKDApXG4gICAgLCBuZWVkc1R5cGVzID0gb3B0aW9ucy5mZXRjaF90eXBlc1xuICAgICwgYmFja2VuZFBhcmFtZXRlcnMgPSB7fVxuICAgICwgc3RhdGVtZW50cyA9IHt9XG4gICAgLCBzdGF0ZW1lbnRJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpXG4gICAgLCBzdGF0ZW1lbnRDb3VudCA9IDFcbiAgICAsIGNsb3NlZERhdGUgPSAwXG4gICAgLCByZW1haW5pbmcgPSAwXG4gICAgLCBob3N0SW5kZXggPSAwXG4gICAgLCByZXRyaWVzID0gMFxuICAgICwgbGVuZ3RoID0gMFxuICAgICwgZGVsYXkgPSAwXG4gICAgLCByb3dzID0gMFxuICAgICwgc2VydmVyU2lnbmF0dXJlID0gbnVsbFxuICAgICwgbmV4dFdyaXRlVGltZXIgPSBudWxsXG4gICAgLCB0ZXJtaW5hdGVkID0gZmFsc2VcbiAgICAsIGluY29taW5ncyA9IG51bGxcbiAgICAsIHJlc3VsdHMgPSBudWxsXG4gICAgLCBpbml0aWFsID0gbnVsbFxuICAgICwgZW5kaW5nID0gbnVsbFxuICAgICwgc3RyZWFtID0gbnVsbFxuICAgICwgY2h1bmsgPSBudWxsXG4gICAgLCBlbmRlZCA9IG51bGxcbiAgICAsIG5vbmNlID0gbnVsbFxuICAgICwgcXVlcnkgPSBudWxsXG4gICAgLCBmaW5hbCA9IG51bGxcblxuICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgIHF1ZXVlOiBxdWV1ZXMuY2xvc2VkLFxuICAgIGlkbGVUaW1lcixcbiAgICBjb25uZWN0KHF1ZXJ5KSB7XG4gICAgICBpbml0aWFsID0gcXVlcnlcbiAgICAgIHJlY29ubmVjdCgpXG4gICAgfSxcbiAgICB0ZXJtaW5hdGUsXG4gICAgZXhlY3V0ZSxcbiAgICBjYW5jZWwsXG4gICAgZW5kLFxuICAgIGNvdW50OiAwLFxuICAgIGlkXG4gIH1cblxuICBxdWV1ZXMuY2xvc2VkICYmIHF1ZXVlcy5jbG9zZWQucHVzaChjb25uZWN0aW9uKVxuXG4gIHJldHVybiBjb25uZWN0aW9uXG5cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU29ja2V0KCkge1xuICAgIGxldCB4XG4gICAgdHJ5IHtcbiAgICAgIHggPSBvcHRpb25zLnNvY2tldFxuICAgICAgICA/IChhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5zb2NrZXQob3B0aW9ucykpKVxuICAgICAgICA6IG5ldyBuZXQuU29ja2V0KClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHgub24oJ2Vycm9yJywgZXJyb3IpXG4gICAgeC5vbignY2xvc2UnLCBjbG9zZWQpXG4gICAgeC5vbignZHJhaW4nLCBkcmFpbilcbiAgICByZXR1cm4geFxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2FuY2VsKHsgcGlkLCBzZWNyZXQgfSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbmNlbE1lc3NhZ2UgPSBiKCkuaTMyKDE2KS5pMzIoODA4NzcxMDIpLmkzMihwaWQpLmkzMihzZWNyZXQpLmVuZCgxNilcbiAgICAgIGF3YWl0IGNvbm5lY3QoKVxuICAgICAgc29ja2V0Lm9uY2UoJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgc29ja2V0Lm9uY2UoJ2Nsb3NlJywgcmVzb2x2ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4ZWN1dGUocSkge1xuICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgcmV0dXJuIHF1ZXJ5RXJyb3IocSwgRXJyb3JzLmNvbm5lY3Rpb24oJ0NPTk5FQ1RJT05fREVTVFJPWUVEJywgb3B0aW9ucykpXG5cbiAgICBpZiAocS5jYW5jZWxsZWQpXG4gICAgICByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBxLnN0YXRlID0gYmFja2VuZFxuICAgICAgcXVlcnlcbiAgICAgICAgPyBzZW50LnB1c2gocSlcbiAgICAgICAgOiAocXVlcnkgPSBxLCBxdWVyeS5hY3RpdmUgPSB0cnVlKVxuXG4gICAgICBidWlsZChxKVxuICAgICAgcmV0dXJuIHdyaXRlKHRvQnVmZmVyKHEpKVxuICAgICAgICAmJiAhcS5kZXNjcmliZUZpcnN0XG4gICAgICAgICYmICFxLmN1cnNvckZuXG4gICAgICAgICYmIHNlbnQubGVuZ3RoIDwgbWF4X3BpcGVsaW5lXG4gICAgICAgICYmICghcS5vcHRpb25zLm9uZXhlY3V0ZSB8fCBxLm9wdGlvbnMub25leGVjdXRlKGNvbm5lY3Rpb24pKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZW50Lmxlbmd0aCA9PT0gMCAmJiB3cml0ZShTeW5jKVxuICAgICAgZXJyb3JlZChlcnJvcilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9CdWZmZXIocSkge1xuICAgIGlmIChxLnBhcmFtZXRlcnMubGVuZ3RoID49IDY1NTM0KVxuICAgICAgdGhyb3cgRXJyb3JzLmdlbmVyaWMoJ01BWF9QQVJBTUVURVJTX0VYQ0VFREVEJywgJ01heCBudW1iZXIgb2YgcGFyYW1ldGVycyAoNjU1MzQpIGV4Y2VlZGVkJylcblxuICAgIHJldHVybiBxLm9wdGlvbnMuc2ltcGxlXG4gICAgICA/IGIoKS5RKCkuc3RyKHEuc3RhdGVtZW50LnN0cmluZyArIGIuTikuZW5kKClcbiAgICAgIDogcS5kZXNjcmliZUZpcnN0XG4gICAgICAgID8gQnVmZmVyLmNvbmNhdChbZGVzY3JpYmUocSksIEZsdXNoXSlcbiAgICAgICAgOiBxLnByZXBhcmVcbiAgICAgICAgICA/IHEucHJlcGFyZWRcbiAgICAgICAgICAgID8gcHJlcGFyZWQocSlcbiAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdChbZGVzY3JpYmUocSksIHByZXBhcmVkKHEpXSlcbiAgICAgICAgICA6IHVubmFtZWQocSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc2NyaWJlKHEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICBQYXJzZShxLnN0YXRlbWVudC5zdHJpbmcsIHEucGFyYW1ldGVycywgcS5zdGF0ZW1lbnQudHlwZXMsIHEuc3RhdGVtZW50Lm5hbWUpLFxuICAgICAgRGVzY3JpYmUoJ1MnLCBxLnN0YXRlbWVudC5uYW1lKVxuICAgIF0pXG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlZChxKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQmluZChxLnBhcmFtZXRlcnMsIHEuc3RhdGVtZW50LnR5cGVzLCBxLnN0YXRlbWVudC5uYW1lLCBxLmN1cnNvck5hbWUpLFxuICAgICAgcS5jdXJzb3JGblxuICAgICAgICA/IEV4ZWN1dGUoJycsIHEuY3Vyc29yUm93cylcbiAgICAgICAgOiBFeGVjdXRlVW5uYW1lZFxuICAgIF0pXG4gIH1cblxuICBmdW5jdGlvbiB1bm5hbWVkKHEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICBQYXJzZShxLnN0YXRlbWVudC5zdHJpbmcsIHEucGFyYW1ldGVycywgcS5zdGF0ZW1lbnQudHlwZXMpLFxuICAgICAgRGVzY3JpYmVVbm5hbWVkLFxuICAgICAgcHJlcGFyZWQocSlcbiAgICBdKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGQocSkge1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbXVxuICAgICAgICAsIHR5cGVzID0gW11cblxuICAgIGNvbnN0IHN0cmluZyA9IHN0cmluZ2lmeShxLCBxLnN0cmluZ3NbMF0sIHEuYXJnc1swXSwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpXG5cbiAgICAhcS50YWdnZWQgJiYgcS5hcmdzLmZvckVhY2goeCA9PiBoYW5kbGVWYWx1ZSh4LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykpXG5cbiAgICBxLnByZXBhcmUgPSBvcHRpb25zLnByZXBhcmUgJiYgKCdwcmVwYXJlJyBpbiBxLm9wdGlvbnMgPyBxLm9wdGlvbnMucHJlcGFyZSA6IHRydWUpXG4gICAgcS5zdHJpbmcgPSBzdHJpbmdcbiAgICBxLnNpZ25hdHVyZSA9IHEucHJlcGFyZSAmJiB0eXBlcyArIHN0cmluZ1xuICAgIHEub25seURlc2NyaWJlICYmIChkZWxldGUgc3RhdGVtZW50c1txLnNpZ25hdHVyZV0pXG4gICAgcS5wYXJhbWV0ZXJzID0gcS5wYXJhbWV0ZXJzIHx8IHBhcmFtZXRlcnNcbiAgICBxLnByZXBhcmVkID0gcS5wcmVwYXJlICYmIHEuc2lnbmF0dXJlIGluIHN0YXRlbWVudHNcbiAgICBxLmRlc2NyaWJlRmlyc3QgPSBxLm9ubHlEZXNjcmliZSB8fCAocGFyYW1ldGVycy5sZW5ndGggJiYgIXEucHJlcGFyZWQpXG4gICAgcS5zdGF0ZW1lbnQgPSBxLnByZXBhcmVkXG4gICAgICA/IHN0YXRlbWVudHNbcS5zaWduYXR1cmVdXG4gICAgICA6IHsgc3RyaW5nLCB0eXBlcywgbmFtZTogcS5wcmVwYXJlID8gc3RhdGVtZW50SWQgKyBzdGF0ZW1lbnRDb3VudCsrIDogJycgfVxuXG4gICAgdHlwZW9mIG9wdGlvbnMuZGVidWcgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5kZWJ1ZyhpZCwgc3RyaW5nLCBwYXJhbWV0ZXJzLCB0eXBlcylcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlKHgsIGZuKSB7XG4gICAgY2h1bmsgPSBjaHVuayA/IEJ1ZmZlci5jb25jYXQoW2NodW5rLCB4XSkgOiBCdWZmZXIuZnJvbSh4KVxuICAgIGlmIChmbiB8fCBjaHVuay5sZW5ndGggPj0gMTAyNClcbiAgICAgIHJldHVybiBuZXh0V3JpdGUoZm4pXG4gICAgbmV4dFdyaXRlVGltZXIgPT09IG51bGwgJiYgKG5leHRXcml0ZVRpbWVyID0gc2V0SW1tZWRpYXRlKG5leHRXcml0ZSkpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRXcml0ZShmbikge1xuICAgIGNvbnN0IHggPSBzb2NrZXQud3JpdGUoY2h1bmssIGZuKVxuICAgIG5leHRXcml0ZVRpbWVyICE9PSBudWxsICYmIGNsZWFySW1tZWRpYXRlKG5leHRXcml0ZVRpbWVyKVxuICAgIGNodW5rID0gbmV4dFdyaXRlVGltZXIgPSBudWxsXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbm5lY3RUaW1lZE91dCgpIHtcbiAgICBlcnJvcmVkKEVycm9ycy5jb25uZWN0aW9uKCdDT05ORUNUX1RJTUVPVVQnLCBvcHRpb25zLCBzb2NrZXQpKVxuICAgIHNvY2tldC5kZXN0cm95KClcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNlY3VyZSgpIHtcbiAgICB3cml0ZShTU0xSZXF1ZXN0KVxuICAgIGNvbnN0IGNhblNTTCA9IGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc29ja2V0Lm9uY2UoJ2RhdGEnLCB4ID0+IHIoeFswXSA9PT0gODMpKSkgLy8gU1xuXG4gICAgaWYgKCFjYW5TU0wgJiYgc3NsID09PSAncHJlZmVyJylcbiAgICAgIHJldHVybiBjb25uZWN0ZWQoKVxuXG4gICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpXG4gICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgc29ja2V0LFxuICAgICAgc2VydmVybmFtZTogbmV0LmlzSVAoc29ja2V0Lmhvc3QpID8gdW5kZWZpbmVkIDogc29ja2V0Lmhvc3QsXG4gICAgICAuLi4oc3NsID09PSAncmVxdWlyZScgfHwgc3NsID09PSAnYWxsb3cnIHx8IHNzbCA9PT0gJ3ByZWZlcidcbiAgICAgICAgPyB7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfVxuICAgICAgICA6IHNzbCA9PT0gJ3ZlcmlmeS1mdWxsJ1xuICAgICAgICAgID8ge31cbiAgICAgICAgICA6IHR5cGVvZiBzc2wgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IHNzbFxuICAgICAgICAgICAgOiB7fVxuICAgICAgKVxuICAgIH0pXG4gICAgc29ja2V0Lm9uKCdzZWN1cmVDb25uZWN0JywgY29ubmVjdGVkKVxuICAgIHNvY2tldC5vbignZXJyb3InLCBlcnJvcilcbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgY2xvc2VkKVxuICAgIHNvY2tldC5vbignZHJhaW4nLCBkcmFpbilcbiAgfVxuXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgIXF1ZXJ5ICYmIG9ub3Blbihjb25uZWN0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gZGF0YSh4KSB7XG4gICAgaWYgKGluY29taW5ncykge1xuICAgICAgaW5jb21pbmdzLnB1c2goeClcbiAgICAgIHJlbWFpbmluZyAtPSB4Lmxlbmd0aFxuICAgICAgaWYgKHJlbWFpbmluZyA+PSAwKVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpbmNvbWluZyA9IGluY29taW5nc1xuICAgICAgPyBCdWZmZXIuY29uY2F0KGluY29taW5ncywgbGVuZ3RoIC0gcmVtYWluaW5nKVxuICAgICAgOiBpbmNvbWluZy5sZW5ndGggPT09IDBcbiAgICAgICAgPyB4XG4gICAgICAgIDogQnVmZmVyLmNvbmNhdChbaW5jb21pbmcsIHhdLCBpbmNvbWluZy5sZW5ndGggKyB4Lmxlbmd0aClcblxuICAgIHdoaWxlIChpbmNvbWluZy5sZW5ndGggPiA0KSB7XG4gICAgICBsZW5ndGggPSBpbmNvbWluZy5yZWFkVUludDMyQkUoMSlcbiAgICAgIGlmIChsZW5ndGggPj0gaW5jb21pbmcubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZyA9IGxlbmd0aCAtIGluY29taW5nLmxlbmd0aFxuICAgICAgICBpbmNvbWluZ3MgPSBbaW5jb21pbmddXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZShpbmNvbWluZy5zdWJhcnJheSgwLCBsZW5ndGggKyAxKSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcXVlcnkgJiYgKHF1ZXJ5LmN1cnNvckZuIHx8IHF1ZXJ5LmRlc2NyaWJlRmlyc3QpICYmIHdyaXRlKFN5bmMpXG4gICAgICAgIGVycm9yZWQoZSlcbiAgICAgIH1cbiAgICAgIGluY29taW5nID0gaW5jb21pbmcuc3ViYXJyYXkobGVuZ3RoICsgMSlcbiAgICAgIHJlbWFpbmluZyA9IDBcbiAgICAgIGluY29taW5ncyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIHRlcm1pbmF0ZWQgPSBmYWxzZVxuICAgIGJhY2tlbmRQYXJhbWV0ZXJzID0ge31cbiAgICBzb2NrZXQgfHwgKHNvY2tldCA9IGF3YWl0IGNyZWF0ZVNvY2tldCgpKVxuXG4gICAgaWYgKCFzb2NrZXQpXG4gICAgICByZXR1cm5cblxuICAgIGNvbm5lY3RUaW1lci5zdGFydCgpXG5cbiAgICBpZiAob3B0aW9ucy5zb2NrZXQpXG4gICAgICByZXR1cm4gc3NsID8gc2VjdXJlKCkgOiBjb25uZWN0ZWQoKVxuXG4gICAgc29ja2V0Lm9uKCdjb25uZWN0Jywgc3NsID8gc2VjdXJlIDogY29ubmVjdGVkKVxuXG4gICAgaWYgKG9wdGlvbnMucGF0aClcbiAgICAgIHJldHVybiBzb2NrZXQuY29ubmVjdChvcHRpb25zLnBhdGgpXG5cbiAgICBzb2NrZXQuc3NsID0gc3NsXG4gICAgc29ja2V0LmNvbm5lY3QocG9ydFtob3N0SW5kZXhdLCBob3N0W2hvc3RJbmRleF0pXG4gICAgc29ja2V0Lmhvc3QgPSBob3N0W2hvc3RJbmRleF1cbiAgICBzb2NrZXQucG9ydCA9IHBvcnRbaG9zdEluZGV4XVxuXG4gICAgaG9zdEluZGV4ID0gKGhvc3RJbmRleCArIDEpICUgcG9ydC5sZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcbiAgICBzZXRUaW1lb3V0KGNvbm5lY3QsIGNsb3NlZERhdGUgPyBjbG9zZWREYXRlICsgZGVsYXkgLSBwZXJmb3JtYW5jZS5ub3coKSA6IDApXG4gIH1cblxuICBmdW5jdGlvbiBjb25uZWN0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXRlbWVudHMgPSB7fVxuICAgICAgbmVlZHNUeXBlcyA9IG9wdGlvbnMuZmV0Y2hfdHlwZXNcbiAgICAgIHN0YXRlbWVudElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMilcbiAgICAgIHN0YXRlbWVudENvdW50ID0gMVxuICAgICAgbGlmZVRpbWVyLnN0YXJ0KClcbiAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEpXG4gICAgICBrZWVwX2FsaXZlICYmIHNvY2tldC5zZXRLZWVwQWxpdmUgJiYgc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlLCAxMDAwICoga2VlcF9hbGl2ZSlcbiAgICAgIGNvbnN0IHMgPSBTdGFydHVwTWVzc2FnZSgpXG4gICAgICB3cml0ZShzKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IoZXJyKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChjb25uZWN0aW9uLnF1ZXVlID09PSBxdWV1ZXMuY29ubmVjdGluZyAmJiBvcHRpb25zLmhvc3RbcmV0cmllcyArIDFdKVxuICAgICAgcmV0dXJuXG5cbiAgICBlcnJvcmVkKGVycilcbiAgICB3aGlsZSAoc2VudC5sZW5ndGgpXG4gICAgICBxdWVyeUVycm9yKHNlbnQuc2hpZnQoKSwgZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3JlZChlcnIpIHtcbiAgICBzdHJlYW0gJiYgKHN0cmVhbS5kZXN0cm95KGVyciksIHN0cmVhbSA9IG51bGwpXG4gICAgcXVlcnkgJiYgcXVlcnlFcnJvcihxdWVyeSwgZXJyKVxuICAgIGluaXRpYWwgJiYgKHF1ZXJ5RXJyb3IoaW5pdGlhbCwgZXJyKSwgaW5pdGlhbCA9IG51bGwpXG4gIH1cblxuICBmdW5jdGlvbiBxdWVyeUVycm9yKHF1ZXJ5LCBlcnIpIHtcbiAgICBxdWVyeS5yZWplY3QoT2JqZWN0LmNyZWF0ZShlcnIsIHtcbiAgICAgIHN0YWNrOiB7IHZhbHVlOiBlcnIuc3RhY2sgKyBxdWVyeS5vcmlnaW4ucmVwbGFjZSgvLipcXG4vLCAnXFxuJyksIGVudW1lcmFibGU6IG9wdGlvbnMuZGVidWcgfSxcbiAgICAgIHF1ZXJ5OiB7IHZhbHVlOiBxdWVyeS5zdHJpbmcsIGVudW1lcmFibGU6IG9wdGlvbnMuZGVidWcgfSxcbiAgICAgIHBhcmFtZXRlcnM6IHsgdmFsdWU6IHF1ZXJ5LnBhcmFtZXRlcnMsIGVudW1lcmFibGU6IG9wdGlvbnMuZGVidWcgfSxcbiAgICAgIGFyZ3M6IHsgdmFsdWU6IHF1ZXJ5LmFyZ3MsIGVudW1lcmFibGU6IG9wdGlvbnMuZGVidWcgfSxcbiAgICAgIHR5cGVzOiB7IHZhbHVlOiBxdWVyeS5zdGF0ZW1lbnQgJiYgcXVlcnkuc3RhdGVtZW50LnR5cGVzLCBlbnVtZXJhYmxlOiBvcHRpb25zLmRlYnVnIH1cbiAgICB9KSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCgpIHtcbiAgICByZXR1cm4gZW5kaW5nIHx8IChcbiAgICAgICFjb25uZWN0aW9uLnJlc2VydmVkICYmIG9uZW5kKGNvbm5lY3Rpb24pLFxuICAgICAgIWNvbm5lY3Rpb24ucmVzZXJ2ZWQgJiYgIWluaXRpYWwgJiYgIXF1ZXJ5ICYmIHNlbnQubGVuZ3RoID09PSAwXG4gICAgICAgID8gKHRlcm1pbmF0ZSgpLCBuZXcgUHJvbWlzZShyID0+IHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSAhPT0gJ2Nsb3NlZCcgPyBzb2NrZXQub25jZSgnY2xvc2UnLCByKSA6IHIoKSkpXG4gICAgICAgIDogZW5kaW5nID0gbmV3IFByb21pc2UociA9PiBlbmRlZCA9IHIpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gdGVybWluYXRlKCkge1xuICAgIHRlcm1pbmF0ZWQgPSB0cnVlXG4gICAgaWYgKHN0cmVhbSB8fCBxdWVyeSB8fCBpbml0aWFsIHx8IHNlbnQubGVuZ3RoKVxuICAgICAgZXJyb3IoRXJyb3JzLmNvbm5lY3Rpb24oJ0NPTk5FQ1RJT05fREVTVFJPWUVEJywgb3B0aW9ucykpXG5cbiAgICBjbGVhckltbWVkaWF0ZShuZXh0V3JpdGVUaW1lcilcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBkYXRhKVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdGVkKVxuICAgICAgc29ja2V0LnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJiBzb2NrZXQuZW5kKGIoKS5YKCkuZW5kKCkpXG4gICAgfVxuICAgIGVuZGVkICYmIChlbmRlZCgpLCBlbmRpbmcgPSBlbmRlZCA9IG51bGwpXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjbG9zZWQoaGFkRXJyb3IpIHtcbiAgICBpbmNvbWluZyA9IEJ1ZmZlci5hbGxvYygwKVxuICAgIHJlbWFpbmluZyA9IDBcbiAgICBpbmNvbWluZ3MgPSBudWxsXG4gICAgY2xlYXJJbW1lZGlhdGUobmV4dFdyaXRlVGltZXIpXG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgZGF0YSlcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0ZWQpXG4gICAgaWRsZVRpbWVyLmNhbmNlbCgpXG4gICAgbGlmZVRpbWVyLmNhbmNlbCgpXG4gICAgY29ubmVjdFRpbWVyLmNhbmNlbCgpXG5cbiAgICBpZiAoc29ja2V0LmVuY3J5cHRlZCkge1xuICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpXG4gICAgICBzb2NrZXQgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWwpXG4gICAgICByZXR1cm4gcmVjb25uZWN0KClcblxuICAgICFoYWRFcnJvciAmJiAocXVlcnkgfHwgc2VudC5sZW5ndGgpICYmIGVycm9yKEVycm9ycy5jb25uZWN0aW9uKCdDT05ORUNUSU9OX0NMT1NFRCcsIG9wdGlvbnMsIHNvY2tldCkpXG4gICAgY2xvc2VkRGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgaGFkRXJyb3IgJiYgb3B0aW9ucy5zaGFyZWQucmV0cmllcysrXG4gICAgZGVsYXkgPSAodHlwZW9mIGJhY2tvZmYgPT09ICdmdW5jdGlvbicgPyBiYWNrb2ZmKG9wdGlvbnMuc2hhcmVkLnJldHJpZXMpIDogYmFja29mZikgKiAxMDAwXG4gICAgb25jbG9zZShjb25uZWN0aW9uKVxuICB9XG5cbiAgLyogSGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlKHhzLCB4ID0geHNbMF0pIHtcbiAgICAoXG4gICAgICB4ID09PSA2OCA/IERhdGFSb3cgOiAgICAgICAgICAgICAgICAgICAvLyBEXG4gICAgICB4ID09PSAxMDAgPyBDb3B5RGF0YSA6ICAgICAgICAgICAgICAgICAvLyBkXG4gICAgICB4ID09PSA2NSA/IE5vdGlmaWNhdGlvblJlc3BvbnNlIDogICAgICAvLyBBXG4gICAgICB4ID09PSA4MyA/IFBhcmFtZXRlclN0YXR1cyA6ICAgICAgICAgICAvLyBTXG4gICAgICB4ID09PSA5MCA/IFJlYWR5Rm9yUXVlcnkgOiAgICAgICAgICAgICAvLyBaXG4gICAgICB4ID09PSA2NyA/IENvbW1hbmRDb21wbGV0ZSA6ICAgICAgICAgICAvLyBDXG4gICAgICB4ID09PSA1MCA/IEJpbmRDb21wbGV0ZSA6ICAgICAgICAgICAgICAvLyAyXG4gICAgICB4ID09PSA0OSA/IFBhcnNlQ29tcGxldGUgOiAgICAgICAgICAgICAvLyAxXG4gICAgICB4ID09PSAxMTYgPyBQYXJhbWV0ZXJEZXNjcmlwdGlvbiA6ICAgICAvLyB0XG4gICAgICB4ID09PSA4NCA/IFJvd0Rlc2NyaXB0aW9uIDogICAgICAgICAgICAvLyBUXG4gICAgICB4ID09PSA4MiA/IEF1dGhlbnRpY2F0aW9uIDogICAgICAgICAgICAvLyBSXG4gICAgICB4ID09PSAxMTAgPyBOb0RhdGEgOiAgICAgICAgICAgICAgICAgICAvLyBuXG4gICAgICB4ID09PSA3NSA/IEJhY2tlbmRLZXlEYXRhIDogICAgICAgICAgICAvLyBLXG4gICAgICB4ID09PSA2OSA/IEVycm9yUmVzcG9uc2UgOiAgICAgICAgICAgICAvLyBFXG4gICAgICB4ID09PSAxMTUgPyBQb3J0YWxTdXNwZW5kZWQgOiAgICAgICAgICAvLyBzXG4gICAgICB4ID09PSA1MSA/IENsb3NlQ29tcGxldGUgOiAgICAgICAgICAgICAvLyAzXG4gICAgICB4ID09PSA3MSA/IENvcHlJblJlc3BvbnNlIDogICAgICAgICAgICAvLyBHXG4gICAgICB4ID09PSA3OCA/IE5vdGljZVJlc3BvbnNlIDogICAgICAgICAgICAvLyBOXG4gICAgICB4ID09PSA3MiA/IENvcHlPdXRSZXNwb25zZSA6ICAgICAgICAgICAvLyBIXG4gICAgICB4ID09PSA5OSA/IENvcHlEb25lIDogICAgICAgICAgICAgICAgICAvLyBjXG4gICAgICB4ID09PSA3MyA/IEVtcHR5UXVlcnlSZXNwb25zZSA6ICAgICAgICAvLyBJXG4gICAgICB4ID09PSA4NiA/IEZ1bmN0aW9uQ2FsbFJlc3BvbnNlIDogICAgICAvLyBWXG4gICAgICB4ID09PSAxMTggPyBOZWdvdGlhdGVQcm90b2NvbFZlcnNpb24gOiAvLyB2XG4gICAgICB4ID09PSA4NyA/IENvcHlCb3RoUmVzcG9uc2UgOiAgICAgICAgICAvLyBXXG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgVW5rbm93bk1lc3NhZ2VcbiAgICApKHhzKVxuICB9XG5cbiAgZnVuY3Rpb24gRGF0YVJvdyh4KSB7XG4gICAgbGV0IGluZGV4ID0gN1xuICAgIGxldCBsZW5ndGhcbiAgICBsZXQgY29sdW1uXG4gICAgbGV0IHZhbHVlXG5cbiAgICBjb25zdCByb3cgPSBxdWVyeS5pc1JhdyA/IG5ldyBBcnJheShxdWVyeS5zdGF0ZW1lbnQuY29sdW1ucy5sZW5ndGgpIDoge31cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXJ5LnN0YXRlbWVudC5jb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2x1bW4gPSBxdWVyeS5zdGF0ZW1lbnQuY29sdW1uc1tpXVxuICAgICAgbGVuZ3RoID0geC5yZWFkSW50MzJCRShpbmRleClcbiAgICAgIGluZGV4ICs9IDRcblxuICAgICAgdmFsdWUgPSBsZW5ndGggPT09IC0xXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHF1ZXJ5LmlzUmF3ID09PSB0cnVlXG4gICAgICAgICAgPyB4LnN1YmFycmF5KGluZGV4LCBpbmRleCArPSBsZW5ndGgpXG4gICAgICAgICAgOiBjb2x1bW4ucGFyc2VyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geC50b1N0cmluZygndXRmOCcsIGluZGV4LCBpbmRleCArPSBsZW5ndGgpXG4gICAgICAgICAgICA6IGNvbHVtbi5wYXJzZXIuYXJyYXkgPT09IHRydWVcbiAgICAgICAgICAgICAgPyBjb2x1bW4ucGFyc2VyKHgudG9TdHJpbmcoJ3V0ZjgnLCBpbmRleCArIDEsIGluZGV4ICs9IGxlbmd0aCkpXG4gICAgICAgICAgICAgIDogY29sdW1uLnBhcnNlcih4LnRvU3RyaW5nKCd1dGY4JywgaW5kZXgsIGluZGV4ICs9IGxlbmd0aCkpXG5cbiAgICAgIHF1ZXJ5LmlzUmF3XG4gICAgICAgID8gKHJvd1tpXSA9IHF1ZXJ5LmlzUmF3ID09PSB0cnVlXG4gICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgIDogdHJhbnNmb3JtLnZhbHVlLmZyb20gPyB0cmFuc2Zvcm0udmFsdWUuZnJvbSh2YWx1ZSwgY29sdW1uKSA6IHZhbHVlKVxuICAgICAgICA6IChyb3dbY29sdW1uLm5hbWVdID0gdHJhbnNmb3JtLnZhbHVlLmZyb20gPyB0cmFuc2Zvcm0udmFsdWUuZnJvbSh2YWx1ZSwgY29sdW1uKSA6IHZhbHVlKVxuICAgIH1cblxuICAgIHF1ZXJ5LmZvckVhY2hGblxuICAgICAgPyBxdWVyeS5mb3JFYWNoRm4odHJhbnNmb3JtLnJvdy5mcm9tID8gdHJhbnNmb3JtLnJvdy5mcm9tKHJvdykgOiByb3csIHJlc3VsdClcbiAgICAgIDogKHJlc3VsdFtyb3dzKytdID0gdHJhbnNmb3JtLnJvdy5mcm9tID8gdHJhbnNmb3JtLnJvdy5mcm9tKHJvdykgOiByb3cpXG4gIH1cblxuICBmdW5jdGlvbiBQYXJhbWV0ZXJTdGF0dXMoeCkge1xuICAgIGNvbnN0IFtrLCB2XSA9IHgudG9TdHJpbmcoJ3V0ZjgnLCA1LCB4Lmxlbmd0aCAtIDEpLnNwbGl0KGIuTilcbiAgICBiYWNrZW5kUGFyYW1ldGVyc1trXSA9IHZcbiAgICBpZiAob3B0aW9ucy5wYXJhbWV0ZXJzW2tdICE9PSB2KSB7XG4gICAgICBvcHRpb25zLnBhcmFtZXRlcnNba10gPSB2XG4gICAgICBvbnBhcmFtZXRlciAmJiBvbnBhcmFtZXRlcihrLCB2KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWR5Rm9yUXVlcnkoeCkge1xuICAgIHF1ZXJ5ICYmIHF1ZXJ5Lm9wdGlvbnMuc2ltcGxlICYmIHF1ZXJ5LnJlc29sdmUocmVzdWx0cyB8fCByZXN1bHQpXG4gICAgcXVlcnkgPSByZXN1bHRzID0gbnVsbFxuICAgIHJlc3VsdCA9IG5ldyBSZXN1bHQoKVxuICAgIGNvbm5lY3RUaW1lci5jYW5jZWwoKVxuXG4gICAgaWYgKGluaXRpYWwpIHtcbiAgICAgIGlmICh0YXJnZXRfc2Vzc2lvbl9hdHRycykge1xuICAgICAgICBpZiAoIWJhY2tlbmRQYXJhbWV0ZXJzLmluX2hvdF9zdGFuZGJ5IHx8ICFiYWNrZW5kUGFyYW1ldGVycy5kZWZhdWx0X3RyYW5zYWN0aW9uX3JlYWRfb25seSlcbiAgICAgICAgICByZXR1cm4gZmV0Y2hTdGF0ZSgpXG4gICAgICAgIGVsc2UgaWYgKHRyeU5leHQodGFyZ2V0X3Nlc3Npb25fYXR0cnMsIGJhY2tlbmRQYXJhbWV0ZXJzKSlcbiAgICAgICAgICByZXR1cm4gdGVybWluYXRlKClcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRzVHlwZXMpXG4gICAgICAgIHJldHVybiBmZXRjaEFycmF5VHlwZXMoKVxuXG4gICAgICBleGVjdXRlKGluaXRpYWwpXG4gICAgICBvcHRpb25zLnNoYXJlZC5yZXRyaWVzID0gcmV0cmllcyA9IGluaXRpYWwgPSAwXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB3aGlsZSAoc2VudC5sZW5ndGggJiYgKHF1ZXJ5ID0gc2VudC5zaGlmdCgpKSAmJiAocXVlcnkuYWN0aXZlID0gdHJ1ZSwgcXVlcnkuY2FuY2VsbGVkKSlcbiAgICAgIENvbm5lY3Rpb24ob3B0aW9ucykuY2FuY2VsKHF1ZXJ5LnN0YXRlLCBxdWVyeS5jYW5jZWxsZWQucmVzb2x2ZSwgcXVlcnkuY2FuY2VsbGVkLnJlamVjdClcblxuICAgIGlmIChxdWVyeSlcbiAgICAgIHJldHVybiAvLyBDb25zaWRlciBvcGVuaW5nIGlmIGFibGUgYW5kIHNlbnQubGVuZ3RoIDwgNTBcblxuICAgIGNvbm5lY3Rpb24ucmVzZXJ2ZWRcbiAgICAgID8gIWNvbm5lY3Rpb24ucmVzZXJ2ZWQucmVsZWFzZSAmJiB4WzVdID09PSA3MyAvLyBJXG4gICAgICAgID8gZW5kaW5nXG4gICAgICAgICAgPyB0ZXJtaW5hdGUoKVxuICAgICAgICAgIDogKGNvbm5lY3Rpb24ucmVzZXJ2ZWQgPSBudWxsLCBvbm9wZW4oY29ubmVjdGlvbikpXG4gICAgICAgIDogY29ubmVjdGlvbi5yZXNlcnZlZCgpXG4gICAgICA6IGVuZGluZ1xuICAgICAgICA/IHRlcm1pbmF0ZSgpXG4gICAgICAgIDogb25vcGVuKGNvbm5lY3Rpb24pXG4gIH1cblxuICBmdW5jdGlvbiBDb21tYW5kQ29tcGxldGUoeCkge1xuICAgIHJvd3MgPSAwXG5cbiAgICBmb3IgKGxldCBpID0geC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICBpZiAoeFtpXSA9PT0gMzIgJiYgeFtpICsgMV0gPCA1OCAmJiByZXN1bHQuY291bnQgPT09IG51bGwpXG4gICAgICAgIHJlc3VsdC5jb3VudCA9ICt4LnRvU3RyaW5nKCd1dGY4JywgaSArIDEsIHgubGVuZ3RoIC0gMSlcbiAgICAgIGlmICh4W2kgLSAxXSA+PSA2NSkge1xuICAgICAgICByZXN1bHQuY29tbWFuZCA9IHgudG9TdHJpbmcoJ3V0ZjgnLCA1LCBpKVxuICAgICAgICByZXN1bHQuc3RhdGUgPSBiYWNrZW5kXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgZmluYWwgJiYgKGZpbmFsKCksIGZpbmFsID0gbnVsbClcblxuICAgIGlmIChyZXN1bHQuY29tbWFuZCA9PT0gJ0JFR0lOJyAmJiBtYXggIT09IDEgJiYgIWNvbm5lY3Rpb24ucmVzZXJ2ZWQpXG4gICAgICByZXR1cm4gZXJyb3JlZChFcnJvcnMuZ2VuZXJpYygnVU5TQUZFX1RSQU5TQUNUSU9OJywgJ09ubHkgdXNlIHNxbC5iZWdpbiwgc3FsLnJlc2VydmVkIG9yIG1heDogMScpKVxuXG4gICAgaWYgKHF1ZXJ5Lm9wdGlvbnMuc2ltcGxlKVxuICAgICAgcmV0dXJuIEJpbmRDb21wbGV0ZSgpXG5cbiAgICBpZiAocXVlcnkuY3Vyc29yRm4pIHtcbiAgICAgIHJlc3VsdC5jb3VudCAmJiBxdWVyeS5jdXJzb3JGbihyZXN1bHQpXG4gICAgICB3cml0ZShTeW5jKVxuICAgIH1cblxuICAgIHF1ZXJ5LnJlc29sdmUocmVzdWx0KVxuICB9XG5cbiAgZnVuY3Rpb24gUGFyc2VDb21wbGV0ZSgpIHtcbiAgICBxdWVyeS5wYXJzaW5nID0gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIEJpbmRDb21wbGV0ZSgpIHtcbiAgICAhcmVzdWx0LnN0YXRlbWVudCAmJiAocmVzdWx0LnN0YXRlbWVudCA9IHF1ZXJ5LnN0YXRlbWVudClcbiAgICByZXN1bHQuY29sdW1ucyA9IHF1ZXJ5LnN0YXRlbWVudC5jb2x1bW5zXG4gIH1cblxuICBmdW5jdGlvbiBQYXJhbWV0ZXJEZXNjcmlwdGlvbih4KSB7XG4gICAgY29uc3QgbGVuZ3RoID0geC5yZWFkVUludDE2QkUoNSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpXG4gICAgICAhcXVlcnkuc3RhdGVtZW50LnR5cGVzW2ldICYmIChxdWVyeS5zdGF0ZW1lbnQudHlwZXNbaV0gPSB4LnJlYWRVSW50MzJCRSg3ICsgaSAqIDQpKVxuXG4gICAgcXVlcnkucHJlcGFyZSAmJiAoc3RhdGVtZW50c1txdWVyeS5zaWduYXR1cmVdID0gcXVlcnkuc3RhdGVtZW50KVxuICAgIHF1ZXJ5LmRlc2NyaWJlRmlyc3QgJiYgIXF1ZXJ5Lm9ubHlEZXNjcmliZSAmJiAod3JpdGUocHJlcGFyZWQocXVlcnkpKSwgcXVlcnkuZGVzY3JpYmVGaXJzdCA9IGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gUm93RGVzY3JpcHRpb24oeCkge1xuICAgIGlmIChyZXN1bHQuY29tbWFuZCkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW3Jlc3VsdF1cbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQgPSBuZXcgUmVzdWx0KCkpXG4gICAgICByZXN1bHQuY291bnQgPSBudWxsXG4gICAgICBxdWVyeS5zdGF0ZW1lbnQuY29sdW1ucyA9IG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSB4LnJlYWRVSW50MTZCRSg1KVxuICAgIGxldCBpbmRleCA9IDdcbiAgICBsZXQgc3RhcnRcblxuICAgIHF1ZXJ5LnN0YXRlbWVudC5jb2x1bW5zID0gQXJyYXkobGVuZ3RoKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgc3RhcnQgPSBpbmRleFxuICAgICAgd2hpbGUgKHhbaW5kZXgrK10gIT09IDApO1xuICAgICAgY29uc3QgdGFibGUgPSB4LnJlYWRVSW50MzJCRShpbmRleClcbiAgICAgIGNvbnN0IG51bWJlciA9IHgucmVhZFVJbnQxNkJFKGluZGV4ICsgNClcbiAgICAgIGNvbnN0IHR5cGUgPSB4LnJlYWRVSW50MzJCRShpbmRleCArIDYpXG4gICAgICBxdWVyeS5zdGF0ZW1lbnQuY29sdW1uc1tpXSA9IHtcbiAgICAgICAgbmFtZTogdHJhbnNmb3JtLmNvbHVtbi5mcm9tXG4gICAgICAgICAgPyB0cmFuc2Zvcm0uY29sdW1uLmZyb20oeC50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBpbmRleCAtIDEpKVxuICAgICAgICAgIDogeC50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBpbmRleCAtIDEpLFxuICAgICAgICBwYXJzZXI6IHBhcnNlcnNbdHlwZV0sXG4gICAgICAgIHRhYmxlLFxuICAgICAgICBudW1iZXIsXG4gICAgICAgIHR5cGVcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IDE4XG4gICAgfVxuXG4gICAgcmVzdWx0LnN0YXRlbWVudCA9IHF1ZXJ5LnN0YXRlbWVudFxuICAgIGlmIChxdWVyeS5vbmx5RGVzY3JpYmUpXG4gICAgICByZXR1cm4gKHF1ZXJ5LnJlc29sdmUocXVlcnkuc3RhdGVtZW50KSwgd3JpdGUoU3luYykpXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBBdXRoZW50aWNhdGlvbih4LCB0eXBlID0geC5yZWFkVUludDMyQkUoNSkpIHtcbiAgICAoXG4gICAgICB0eXBlID09PSAzID8gQXV0aGVudGljYXRpb25DbGVhcnRleHRQYXNzd29yZCA6XG4gICAgICB0eXBlID09PSA1ID8gQXV0aGVudGljYXRpb25NRDVQYXNzd29yZCA6XG4gICAgICB0eXBlID09PSAxMCA/IFNBU0wgOlxuICAgICAgdHlwZSA9PT0gMTEgPyBTQVNMQ29udGludWUgOlxuICAgICAgdHlwZSA9PT0gMTIgPyBTQVNMRmluYWwgOlxuICAgICAgdHlwZSAhPT0gMCA/IFVua25vd25BdXRoIDpcbiAgICAgIG5vb3BcbiAgICApKHgsIHR5cGUpXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gIGFzeW5jIGZ1bmN0aW9uIEF1dGhlbnRpY2F0aW9uQ2xlYXJ0ZXh0UGFzc3dvcmQoKSB7XG4gICAgd3JpdGUoXG4gICAgICBiKCkucCgpLnN0cihhd2FpdCBQYXNzKCkpLnooMSkuZW5kKClcbiAgICApXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBBdXRoZW50aWNhdGlvbk1ENVBhc3N3b3JkKHgpIHtcbiAgICB3cml0ZShcbiAgICAgIGIoKS5wKCkuc3RyKFxuICAgICAgICAnbWQ1JyArXG4gICAgICAgIChhd2FpdCBtZDUoQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgQnVmZmVyLmZyb20oYXdhaXQgbWQ1KChhd2FpdCBQYXNzKCkpICsgdXNlcikpLFxuICAgICAgICAgIHguc3ViYXJyYXkoOSlcbiAgICAgICAgXSkpKVxuICAgICAgKS56KDEpLmVuZCgpXG4gICAgKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gU0FTTCgpIHtcbiAgICBiKCkucCgpLnN0cignU0NSQU0tU0hBLTI1NicgKyBiLk4pXG4gICAgY29uc3QgaSA9IGIuaVxuICAgIG5vbmNlID0gKGF3YWl0IGNyeXB0by5yYW5kb21CeXRlcygxOCkpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIHdyaXRlKGIuaW5jKDQpLnN0cignbiwsbj0qLHI9JyArIG5vbmNlKS5pMzIoYi5pIC0gaSAtIDQsIGkpLmVuZCgpKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gU0FTTENvbnRpbnVlKHgpIHtcbiAgICBjb25zdCByZXMgPSB4LnRvU3RyaW5nKCd1dGY4JywgOSkuc3BsaXQoJywnKS5yZWR1Y2UoKGFjYywgeCkgPT4gKGFjY1t4WzBdXSA9IHguc2xpY2UoMiksIGFjYyksIHt9KVxuXG4gICAgY29uc3Qgc2FsdGVkUGFzc3dvcmQgPSBhd2FpdCBjcnlwdG8ucGJrZGYyU3luYyhcbiAgICAgIGF3YWl0IFBhc3MoKSxcbiAgICAgIEJ1ZmZlci5mcm9tKHJlcy5zLCAnYmFzZTY0JyksXG4gICAgICBwYXJzZUludChyZXMuaSksIDMyLFxuICAgICAgJ3NoYTI1NidcbiAgICApXG5cbiAgICBjb25zdCBjbGllbnRLZXkgPSBhd2FpdCBobWFjKHNhbHRlZFBhc3N3b3JkLCAnQ2xpZW50IEtleScpXG5cbiAgICBjb25zdCBhdXRoID0gJ249KixyPScgKyBub25jZSArICcsJ1xuICAgICAgICAgICAgICAgKyAncj0nICsgcmVzLnIgKyAnLHM9JyArIHJlcy5zICsgJyxpPScgKyByZXMuaVxuICAgICAgICAgICAgICAgKyAnLGM9Yml3cyxyPScgKyByZXMuclxuXG4gICAgc2VydmVyU2lnbmF0dXJlID0gKGF3YWl0IGhtYWMoYXdhaXQgaG1hYyhzYWx0ZWRQYXNzd29yZCwgJ1NlcnZlciBLZXknKSwgYXV0aCkpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gICAgd3JpdGUoXG4gICAgICBiKCkucCgpLnN0cihcbiAgICAgICAgJ2M9Yml3cyxyPScgKyByZXMuciArICcscD0nICsgeG9yKFxuICAgICAgICAgIGNsaWVudEtleSwgQnVmZmVyLmZyb20oYXdhaXQgaG1hYyhhd2FpdCBzaGEyNTYoY2xpZW50S2V5KSwgYXV0aCkpXG4gICAgICAgICkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICApLmVuZCgpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gU0FTTEZpbmFsKHgpIHtcbiAgICBpZiAoeC50b1N0cmluZygndXRmOCcsIDkpLnNwbGl0KGIuTiwgMSlbMF0uc2xpY2UoMikgPT09IHNlcnZlclNpZ25hdHVyZSlcbiAgICAgIHJldHVyblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICBlcnJvcmVkKEVycm9ycy5nZW5lcmljKCdTQVNMX1NJR05BVFVSRV9NSVNNQVRDSCcsICdUaGUgc2VydmVyIGRpZCBub3QgcmV0dXJuIHRoZSBjb3JyZWN0IHNpZ25hdHVyZScpKVxuICAgIHNvY2tldC5kZXN0cm95KClcbiAgfVxuXG4gIGZ1bmN0aW9uIFBhc3MoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlb2Ygb3B0aW9ucy5wYXNzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG9wdGlvbnMucGFzcygpXG4gICAgICA6IG9wdGlvbnMucGFzc1xuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIE5vRGF0YSgpIHtcbiAgICByZXN1bHQuc3RhdGVtZW50ID0gcXVlcnkuc3RhdGVtZW50XG4gICAgcmVzdWx0LnN0YXRlbWVudC5jb2x1bW5zID0gW11cbiAgICBpZiAocXVlcnkub25seURlc2NyaWJlKVxuICAgICAgcmV0dXJuIChxdWVyeS5yZXNvbHZlKHF1ZXJ5LnN0YXRlbWVudCksIHdyaXRlKFN5bmMpKVxuICB9XG5cbiAgZnVuY3Rpb24gQmFja2VuZEtleURhdGEoeCkge1xuICAgIGJhY2tlbmQucGlkID0geC5yZWFkVUludDMyQkUoNSlcbiAgICBiYWNrZW5kLnNlY3JldCA9IHgucmVhZFVJbnQzMkJFKDkpXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBmZXRjaEFycmF5VHlwZXMoKSB7XG4gICAgbmVlZHNUeXBlcyA9IGZhbHNlXG4gICAgY29uc3QgdHlwZXMgPSBhd2FpdCBuZXcgUXVlcnkoW2BcbiAgICAgIHNlbGVjdCBiLm9pZCwgYi50eXBhcnJheVxuICAgICAgZnJvbSBwZ19jYXRhbG9nLnBnX3R5cGUgYVxuICAgICAgbGVmdCBqb2luIHBnX2NhdGFsb2cucGdfdHlwZSBiIG9uIGIub2lkID0gYS50eXBlbGVtXG4gICAgICB3aGVyZSBhLnR5cGNhdGVnb3J5ID0gJ0EnXG4gICAgICBncm91cCBieSBiLm9pZCwgYi50eXBhcnJheVxuICAgICAgb3JkZXIgYnkgYi5vaWRcbiAgICBgXSwgW10sIGV4ZWN1dGUpXG4gICAgdHlwZXMuZm9yRWFjaCgoeyBvaWQsIHR5cGFycmF5IH0pID0+IGFkZEFycmF5VHlwZShvaWQsIHR5cGFycmF5KSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEFycmF5VHlwZShvaWQsIHR5cGFycmF5KSB7XG4gICAgaWYgKCEhb3B0aW9ucy5wYXJzZXJzW3R5cGFycmF5XSAmJiAhIW9wdGlvbnMuc2VyaWFsaXplcnNbdHlwYXJyYXldKSByZXR1cm5cbiAgICBjb25zdCBwYXJzZXIgPSBvcHRpb25zLnBhcnNlcnNbb2lkXVxuICAgIG9wdGlvbnMuc2hhcmVkLnR5cGVBcnJheU1hcFtvaWRdID0gdHlwYXJyYXlcbiAgICBvcHRpb25zLnBhcnNlcnNbdHlwYXJyYXldID0gKHhzKSA9PiBhcnJheVBhcnNlcih4cywgcGFyc2VyLCB0eXBhcnJheSlcbiAgICBvcHRpb25zLnBhcnNlcnNbdHlwYXJyYXldLmFycmF5ID0gdHJ1ZVxuICAgIG9wdGlvbnMuc2VyaWFsaXplcnNbdHlwYXJyYXldID0gKHhzKSA9PiBhcnJheVNlcmlhbGl6ZXIoeHMsIG9wdGlvbnMuc2VyaWFsaXplcnNbb2lkXSwgb3B0aW9ucywgdHlwYXJyYXkpXG4gIH1cblxuICBmdW5jdGlvbiB0cnlOZXh0KHgsIHhzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh4ID09PSAncmVhZC13cml0ZScgJiYgeHMuZGVmYXVsdF90cmFuc2FjdGlvbl9yZWFkX29ubHkgPT09ICdvbicpIHx8XG4gICAgICAoeCA9PT0gJ3JlYWQtb25seScgJiYgeHMuZGVmYXVsdF90cmFuc2FjdGlvbl9yZWFkX29ubHkgPT09ICdvZmYnKSB8fFxuICAgICAgKHggPT09ICdwcmltYXJ5JyAmJiB4cy5pbl9ob3Rfc3RhbmRieSA9PT0gJ29uJykgfHxcbiAgICAgICh4ID09PSAnc3RhbmRieScgJiYgeHMuaW5faG90X3N0YW5kYnkgPT09ICdvZmYnKSB8fFxuICAgICAgKHggPT09ICdwcmVmZXItc3RhbmRieScgJiYgeHMuaW5faG90X3N0YW5kYnkgPT09ICdvZmYnICYmIG9wdGlvbnMuaG9zdFtyZXRyaWVzXSlcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaFN0YXRlKCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KFtgXG4gICAgICBzaG93IHRyYW5zYWN0aW9uX3JlYWRfb25seTtcbiAgICAgIHNlbGVjdCBwZ19jYXRhbG9nLnBnX2lzX2luX3JlY292ZXJ5KClcbiAgICBgXSwgW10sIGV4ZWN1dGUsIG51bGwsIHsgc2ltcGxlOiB0cnVlIH0pXG4gICAgcXVlcnkucmVzb2x2ZSA9IChbW2FdLCBbYl1dKSA9PiB7XG4gICAgICBiYWNrZW5kUGFyYW1ldGVycy5kZWZhdWx0X3RyYW5zYWN0aW9uX3JlYWRfb25seSA9IGEudHJhbnNhY3Rpb25fcmVhZF9vbmx5XG4gICAgICBiYWNrZW5kUGFyYW1ldGVycy5pbl9ob3Rfc3RhbmRieSA9IGIucGdfaXNfaW5fcmVjb3ZlcnkgPyAnb24nIDogJ29mZidcbiAgICB9XG4gICAgcXVlcnkuZXhlY3V0ZSgpXG4gIH1cblxuICBmdW5jdGlvbiBFcnJvclJlc3BvbnNlKHgpIHtcbiAgICBxdWVyeSAmJiAocXVlcnkuY3Vyc29yRm4gfHwgcXVlcnkuZGVzY3JpYmVGaXJzdCkgJiYgd3JpdGUoU3luYylcbiAgICBjb25zdCBlcnJvciA9IEVycm9ycy5wb3N0Z3JlcyhwYXJzZUVycm9yKHgpKVxuICAgIHF1ZXJ5ICYmIHF1ZXJ5LnJldHJpZWRcbiAgICAgID8gZXJyb3JlZChxdWVyeS5yZXRyaWVkKVxuICAgICAgOiBxdWVyeSAmJiByZXRyeVJvdXRpbmVzLmhhcyhlcnJvci5yb3V0aW5lKVxuICAgICAgICA/IHJldHJ5KHF1ZXJ5LCBlcnJvcilcbiAgICAgICAgOiBlcnJvcmVkKGVycm9yKVxuICB9XG5cbiAgZnVuY3Rpb24gcmV0cnkocSwgZXJyb3IpIHtcbiAgICBkZWxldGUgc3RhdGVtZW50c1txLnNpZ25hdHVyZV1cbiAgICBxLnJldHJpZWQgPSBlcnJvclxuICAgIGV4ZWN1dGUocSlcbiAgfVxuXG4gIGZ1bmN0aW9uIE5vdGlmaWNhdGlvblJlc3BvbnNlKHgpIHtcbiAgICBpZiAoIW9ubm90aWZ5KVxuICAgICAgcmV0dXJuXG5cbiAgICBsZXQgaW5kZXggPSA5XG4gICAgd2hpbGUgKHhbaW5kZXgrK10gIT09IDApO1xuICAgIG9ubm90aWZ5KFxuICAgICAgeC50b1N0cmluZygndXRmOCcsIDksIGluZGV4IC0gMSksXG4gICAgICB4LnRvU3RyaW5nKCd1dGY4JywgaW5kZXgsIHgubGVuZ3RoIC0gMSlcbiAgICApXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBQb3J0YWxTdXNwZW5kZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHggPSBhd2FpdCBQcm9taXNlLnJlc29sdmUocXVlcnkuY3Vyc29yRm4ocmVzdWx0KSlcbiAgICAgIHJvd3MgPSAwXG4gICAgICB4ID09PSBDTE9TRVxuICAgICAgICA/IHdyaXRlKENsb3NlKHF1ZXJ5LnBvcnRhbCkpXG4gICAgICAgIDogKHJlc3VsdCA9IG5ldyBSZXN1bHQoKSwgd3JpdGUoRXhlY3V0ZSgnJywgcXVlcnkuY3Vyc29yUm93cykpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgd3JpdGUoU3luYylcbiAgICAgIHF1ZXJ5LnJlamVjdChlcnIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQ2xvc2VDb21wbGV0ZSgpIHtcbiAgICByZXN1bHQuY291bnQgJiYgcXVlcnkuY3Vyc29yRm4ocmVzdWx0KVxuICAgIHF1ZXJ5LnJlc29sdmUocmVzdWx0KVxuICB9XG5cbiAgZnVuY3Rpb24gQ29weUluUmVzcG9uc2UoKSB7XG4gICAgc3RyZWFtID0gbmV3IFN0cmVhbS5Xcml0YWJsZSh7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGIoKS5kKCkucmF3KGNodW5rKS5lbmQoKSwgY2FsbGJhY2spXG4gICAgICB9LFxuICAgICAgZGVzdHJveShlcnJvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpXG4gICAgICAgIHNvY2tldC53cml0ZShiKCkuZigpLnN0cihlcnJvciArIGIuTikuZW5kKCkpXG4gICAgICAgIHN0cmVhbSA9IG51bGxcbiAgICAgIH0sXG4gICAgICBmaW5hbChjYWxsYmFjaykge1xuICAgICAgICBzb2NrZXQud3JpdGUoYigpLmMoKS5lbmQoKSlcbiAgICAgICAgZmluYWwgPSBjYWxsYmFja1xuICAgICAgfVxuICAgIH0pXG4gICAgcXVlcnkucmVzb2x2ZShzdHJlYW0pXG4gIH1cblxuICBmdW5jdGlvbiBDb3B5T3V0UmVzcG9uc2UoKSB7XG4gICAgc3RyZWFtID0gbmV3IFN0cmVhbS5SZWFkYWJsZSh7XG4gICAgICByZWFkKCkgeyBzb2NrZXQucmVzdW1lKCkgfVxuICAgIH0pXG4gICAgcXVlcnkucmVzb2x2ZShzdHJlYW0pXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIENvcHlCb3RoUmVzcG9uc2UoKSB7XG4gICAgc3RyZWFtID0gbmV3IFN0cmVhbS5EdXBsZXgoe1xuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkKCkgeyBzb2NrZXQucmVzdW1lKCkgfSxcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDExICovXG4gICAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShiKCkuZCgpLnJhdyhjaHVuaykuZW5kKCksIGNhbGxiYWNrKVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3koZXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKVxuICAgICAgICBzb2NrZXQud3JpdGUoYigpLmYoKS5zdHIoZXJyb3IgKyBiLk4pLmVuZCgpKVxuICAgICAgICBzdHJlYW0gPSBudWxsXG4gICAgICB9LFxuICAgICAgZmluYWwoY2FsbGJhY2spIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGIoKS5jKCkuZW5kKCkpXG4gICAgICAgIGZpbmFsID0gY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9KVxuICAgIHF1ZXJ5LnJlc29sdmUoc3RyZWFtKVxuICB9XG5cbiAgZnVuY3Rpb24gQ29weURhdGEoeCkge1xuICAgIHN0cmVhbSAmJiAoc3RyZWFtLnB1c2goeC5zdWJhcnJheSg1KSkgfHwgc29ja2V0LnBhdXNlKCkpXG4gIH1cblxuICBmdW5jdGlvbiBDb3B5RG9uZSgpIHtcbiAgICBzdHJlYW0gJiYgc3RyZWFtLnB1c2gobnVsbClcbiAgICBzdHJlYW0gPSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBOb3RpY2VSZXNwb25zZSh4KSB7XG4gICAgb25ub3RpY2VcbiAgICAgID8gb25ub3RpY2UocGFyc2VFcnJvcih4KSlcbiAgICAgIDogY29uc29sZS5sb2cocGFyc2VFcnJvcih4KSkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIEVtcHR5UXVlcnlSZXNwb25zZSgpIHtcbiAgICAvKiBub29wICovXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbFJlc3BvbnNlKCkge1xuICAgIGVycm9yZWQoRXJyb3JzLm5vdFN1cHBvcnRlZCgnRnVuY3Rpb25DYWxsUmVzcG9uc2UnKSlcbiAgfVxuXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgZnVuY3Rpb24gTmVnb3RpYXRlUHJvdG9jb2xWZXJzaW9uKCkge1xuICAgIGVycm9yZWQoRXJyb3JzLm5vdFN1cHBvcnRlZCgnTmVnb3RpYXRlUHJvdG9jb2xWZXJzaW9uJykpXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIFVua25vd25NZXNzYWdlKHgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdQb3N0Z3Jlcy5qcyA6IFVua25vd24gTWVzc2FnZTonLCB4WzBdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gIGZ1bmN0aW9uIFVua25vd25BdXRoKHgsIHR5cGUpIHtcbiAgICBjb25zb2xlLmVycm9yKCdQb3N0Z3Jlcy5qcyA6IFVua25vd24gQXV0aDonLCB0eXBlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cblxuICAvKiBNZXNzYWdlcyAqL1xuICBmdW5jdGlvbiBCaW5kKHBhcmFtZXRlcnMsIHR5cGVzLCBzdGF0ZW1lbnQgPSAnJywgcG9ydGFsID0gJycpIHtcbiAgICBsZXQgcHJldlxuICAgICAgLCB0eXBlXG5cbiAgICBiKCkuQigpLnN0cihwb3J0YWwgKyBiLk4pLnN0cihzdGF0ZW1lbnQgKyBiLk4pLmkxNigwKS5pMTYocGFyYW1ldGVycy5sZW5ndGgpXG5cbiAgICBwYXJhbWV0ZXJzLmZvckVhY2goKHgsIGkpID0+IHtcbiAgICAgIGlmICh4ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gYi5pMzIoMHhGRkZGRkZGRilcblxuICAgICAgdHlwZSA9IHR5cGVzW2ldXG4gICAgICBwYXJhbWV0ZXJzW2ldID0geCA9IHR5cGUgaW4gb3B0aW9ucy5zZXJpYWxpemVyc1xuICAgICAgICA/IG9wdGlvbnMuc2VyaWFsaXplcnNbdHlwZV0oeClcbiAgICAgICAgOiAnJyArIHhcblxuICAgICAgcHJldiA9IGIuaVxuICAgICAgYi5pbmMoNCkuc3RyKHgpLmkzMihiLmkgLSBwcmV2IC0gNCwgcHJldilcbiAgICB9KVxuXG4gICAgYi5pMTYoMClcblxuICAgIHJldHVybiBiLmVuZCgpXG4gIH1cblxuICBmdW5jdGlvbiBQYXJzZShzdHIsIHBhcmFtZXRlcnMsIHR5cGVzLCBuYW1lID0gJycpIHtcbiAgICBiKCkuUCgpLnN0cihuYW1lICsgYi5OKS5zdHIoc3RyICsgYi5OKS5pMTYocGFyYW1ldGVycy5sZW5ndGgpXG4gICAgcGFyYW1ldGVycy5mb3JFYWNoKCh4LCBpKSA9PiBiLmkzMih0eXBlc1tpXSB8fCAwKSlcbiAgICByZXR1cm4gYi5lbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gRGVzY3JpYmUoeCwgbmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIGIoKS5EKCkuc3RyKHgpLnN0cihuYW1lICsgYi5OKS5lbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gRXhlY3V0ZShwb3J0YWwgPSAnJywgcm93cyA9IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICBiKCkuRSgpLnN0cihwb3J0YWwgKyBiLk4pLmkzMihyb3dzKS5lbmQoKSxcbiAgICAgIEZsdXNoXG4gICAgXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIENsb3NlKHBvcnRhbCA9ICcnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgYigpLkMoKS5zdHIoJ1AnKS5zdHIocG9ydGFsICsgYi5OKS5lbmQoKSxcbiAgICAgIGIoKS5TKCkuZW5kKClcbiAgICBdKVxuICB9XG5cbiAgZnVuY3Rpb24gU3RhcnR1cE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIGNhbmNlbE1lc3NhZ2UgfHwgYigpLmluYyg0KS5pMTYoMykueigyKS5zdHIoXG4gICAgICBPYmplY3QuZW50cmllcyhPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdXNlcixcbiAgICAgICAgZGF0YWJhc2UsXG4gICAgICAgIGNsaWVudF9lbmNvZGluZzogJ1VURjgnXG4gICAgICB9LFxuICAgICAgICBvcHRpb25zLmNvbm5lY3Rpb25cbiAgICAgICkpLmZpbHRlcigoWywgdl0pID0+IHYpLm1hcCgoW2ssIHZdKSA9PiBrICsgYi5OICsgdikuam9pbihiLk4pXG4gICAgKS56KDIpLmVuZCgwKVxuICB9XG5cbn1cblxuZnVuY3Rpb24gcGFyc2VFcnJvcih4KSB7XG4gIGNvbnN0IGVycm9yID0ge31cbiAgbGV0IHN0YXJ0ID0gNVxuICBmb3IgKGxldCBpID0gNTsgaSA8IHgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKHhbaV0gPT09IDApIHtcbiAgICAgIGVycm9yW2Vycm9yRmllbGRzW3hbc3RhcnRdXV0gPSB4LnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQgKyAxLCBpKVxuICAgICAgc3RhcnQgPSBpICsgMVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXJyb3Jcbn1cblxuZnVuY3Rpb24gbWQ1KHgpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoeCkuZGlnZXN0KCdoZXgnKVxufVxuXG5mdW5jdGlvbiBobWFjKGtleSwgeCkge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSkudXBkYXRlKHgpLmRpZ2VzdCgpXG59XG5cbmZ1bmN0aW9uIHNoYTI1Nih4KSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHgpLmRpZ2VzdCgpXG59XG5cbmZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHRpbWVyKGZuLCBzZWNvbmRzKSB7XG4gIHNlY29uZHMgPSB0eXBlb2Ygc2Vjb25kcyA9PT0gJ2Z1bmN0aW9uJyA/IHNlY29uZHMoKSA6IHNlY29uZHNcbiAgaWYgKCFzZWNvbmRzKVxuICAgIHJldHVybiB7IGNhbmNlbDogbm9vcCwgc3RhcnQ6IG5vb3AgfVxuXG4gIGxldCB0aW1lclxuICByZXR1cm4ge1xuICAgIGNhbmNlbCgpIHtcbiAgICAgIHRpbWVyICYmIChjbGVhclRpbWVvdXQodGltZXIpLCB0aW1lciA9IG51bGwpXG4gICAgfSxcbiAgICBzdGFydCgpIHtcbiAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChkb25lLCBzZWNvbmRzICogMTAwMCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUoYXJncykge1xuICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgdGltZXIgPSBudWxsXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/connection.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/postgres/src/errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Errors: () => (/* binding */ Errors),\n/* harmony export */   PostgresError: () => (/* binding */ PostgresError)\n/* harmony export */ });\nclass PostgresError extends Error {\n  constructor(x) {\n    super(x.message)\n    this.name = this.constructor.name\n    Object.assign(this, x)\n  }\n}\n\nconst Errors = {\n  connection,\n  postgres,\n  generic,\n  notSupported\n}\n\nfunction connection(x, options, socket) {\n  const { host, port } = socket || options\n  const error = Object.assign(\n    new Error(('write ' + x + ' ' + (options.path || (host + ':' + port)))),\n    {\n      code: x,\n      errno: x,\n      address: options.path || host\n    }, options.path ? {} : { port: port }\n  )\n  Error.captureStackTrace(error, connection)\n  return error\n}\n\nfunction postgres(x) {\n  const error = new PostgresError(x)\n  Error.captureStackTrace(error, postgres)\n  return error\n}\n\nfunction generic(code, message) {\n  const error = Object.assign(new Error(code + ': ' + message), { code })\n  Error.captureStackTrace(error, generic)\n  return error\n}\n\n/* c8 ignore next 10 */\nfunction notSupported(x) {\n  const error = Object.assign(\n    new Error(x + ' (B) is not supported'),\n    {\n      code: 'MESSAGE_NOT_SUPPORTED',\n      name: x\n    }\n  )\n  Error.captureStackTrace(error, notSupported)\n  return error\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0JBQW9CLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmVjYXJkLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzL3NyYy9lcnJvcnMuanM/OWQyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgUG9zdGdyZXNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoeCkge1xuICAgIHN1cGVyKHgubWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHgpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEVycm9ycyA9IHtcbiAgY29ubmVjdGlvbixcbiAgcG9zdGdyZXMsXG4gIGdlbmVyaWMsXG4gIG5vdFN1cHBvcnRlZFxufVxuXG5mdW5jdGlvbiBjb25uZWN0aW9uKHgsIG9wdGlvbnMsIHNvY2tldCkge1xuICBjb25zdCB7IGhvc3QsIHBvcnQgfSA9IHNvY2tldCB8fCBvcHRpb25zXG4gIGNvbnN0IGVycm9yID0gT2JqZWN0LmFzc2lnbihcbiAgICBuZXcgRXJyb3IoKCd3cml0ZSAnICsgeCArICcgJyArIChvcHRpb25zLnBhdGggfHwgKGhvc3QgKyAnOicgKyBwb3J0KSkpKSxcbiAgICB7XG4gICAgICBjb2RlOiB4LFxuICAgICAgZXJybm86IHgsXG4gICAgICBhZGRyZXNzOiBvcHRpb25zLnBhdGggfHwgaG9zdFxuICAgIH0sIG9wdGlvbnMucGF0aCA/IHt9IDogeyBwb3J0OiBwb3J0IH1cbiAgKVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgY29ubmVjdGlvbilcbiAgcmV0dXJuIGVycm9yXG59XG5cbmZ1bmN0aW9uIHBvc3RncmVzKHgpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgUG9zdGdyZXNFcnJvcih4KVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgcG9zdGdyZXMpXG4gIHJldHVybiBlcnJvclxufVxuXG5mdW5jdGlvbiBnZW5lcmljKGNvZGUsIG1lc3NhZ2UpIHtcbiAgY29uc3QgZXJyb3IgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihjb2RlICsgJzogJyArIG1lc3NhZ2UpLCB7IGNvZGUgfSlcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGdlbmVyaWMpXG4gIHJldHVybiBlcnJvclxufVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAxMCAqL1xuZnVuY3Rpb24gbm90U3VwcG9ydGVkKHgpIHtcbiAgY29uc3QgZXJyb3IgPSBPYmplY3QuYXNzaWduKFxuICAgIG5ldyBFcnJvcih4ICsgJyAoQikgaXMgbm90IHN1cHBvcnRlZCcpLFxuICAgIHtcbiAgICAgIGNvZGU6ICdNRVNTQUdFX05PVF9TVVBQT1JURUQnLFxuICAgICAgbmFtZTogeFxuICAgIH1cbiAgKVxuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgbm90U3VwcG9ydGVkKVxuICByZXR1cm4gZXJyb3Jcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/postgres/src/errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Errors: () => (/* binding */ Errors),\n/* harmony export */   PostgresError: () => (/* binding */ PostgresError)\n/* harmony export */ });\nclass PostgresError extends Error {\n  constructor(x) {\n    super(x.message)\n    this.name = this.constructor.name\n    Object.assign(this, x)\n  }\n}\n\nconst Errors = {\n  connection,\n  postgres,\n  generic,\n  notSupported\n}\n\nfunction connection(x, options, socket) {\n  const { host, port } = socket || options\n  const error = Object.assign(\n    new Error(('write ' + x + ' ' + (options.path || (host + ':' + port)))),\n    {\n      code: x,\n      errno: x,\n      address: options.path || host\n    }, options.path ? {} : { port: port }\n  )\n  Error.captureStackTrace(error, connection)\n  return error\n}\n\nfunction postgres(x) {\n  const error = new PostgresError(x)\n  Error.captureStackTrace(error, postgres)\n  return error\n}\n\nfunction generic(code, message) {\n  const error = Object.assign(new Error(code + ': ' + message), { code })\n  Error.captureStackTrace(error, generic)\n  return error\n}\n\n/* c8 ignore next 10 */\nfunction notSupported(x) {\n  const error = Object.assign(\n    new Error(x + ' (B) is not supported'),\n    {\n      code: 'MESSAGE_NOT_SUPPORTED',\n      name: x\n    }\n  )\n  Error.captureStackTrace(error, notSupported)\n  return error\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsTUFBTTtBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvZXJyb3JzLmpzPzM3MDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFBvc3RncmVzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHgpIHtcbiAgICBzdXBlcih4Lm1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB4KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBFcnJvcnMgPSB7XG4gIGNvbm5lY3Rpb24sXG4gIHBvc3RncmVzLFxuICBnZW5lcmljLFxuICBub3RTdXBwb3J0ZWRcbn1cblxuZnVuY3Rpb24gY29ubmVjdGlvbih4LCBvcHRpb25zLCBzb2NrZXQpIHtcbiAgY29uc3QgeyBob3N0LCBwb3J0IH0gPSBzb2NrZXQgfHwgb3B0aW9uc1xuICBjb25zdCBlcnJvciA9IE9iamVjdC5hc3NpZ24oXG4gICAgbmV3IEVycm9yKCgnd3JpdGUgJyArIHggKyAnICcgKyAob3B0aW9ucy5wYXRoIHx8IChob3N0ICsgJzonICsgcG9ydCkpKSksXG4gICAge1xuICAgICAgY29kZTogeCxcbiAgICAgIGVycm5vOiB4LFxuICAgICAgYWRkcmVzczogb3B0aW9ucy5wYXRoIHx8IGhvc3RcbiAgICB9LCBvcHRpb25zLnBhdGggPyB7fSA6IHsgcG9ydDogcG9ydCB9XG4gIClcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGNvbm5lY3Rpb24pXG4gIHJldHVybiBlcnJvclxufVxuXG5mdW5jdGlvbiBwb3N0Z3Jlcyh4KSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IFBvc3RncmVzRXJyb3IoeClcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHBvc3RncmVzKVxuICByZXR1cm4gZXJyb3Jcbn1cblxuZnVuY3Rpb24gZ2VuZXJpYyhjb2RlLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGVycm9yID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoY29kZSArICc6ICcgKyBtZXNzYWdlKSwgeyBjb2RlIH0pXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBnZW5lcmljKVxuICByZXR1cm4gZXJyb3Jcbn1cblxuLyogYzggaWdub3JlIG5leHQgMTAgKi9cbmZ1bmN0aW9uIG5vdFN1cHBvcnRlZCh4KSB7XG4gIGNvbnN0IGVycm9yID0gT2JqZWN0LmFzc2lnbihcbiAgICBuZXcgRXJyb3IoeCArICcgKEIpIGlzIG5vdCBzdXBwb3J0ZWQnKSxcbiAgICB7XG4gICAgICBjb2RlOiAnTUVTU0FHRV9OT1RfU1VQUE9SVEVEJyxcbiAgICAgIG5hbWU6IHhcbiAgICB9XG4gIClcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIG5vdFN1cHBvcnRlZClcbiAgcmV0dXJuIGVycm9yXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/errors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(action-browser)/./node_modules/postgres/src/types.js\");\n/* harmony import */ var _connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connection.js */ \"(action-browser)/./node_modules/postgres/src/connection.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query.js */ \"(action-browser)/./node_modules/postgres/src/query.js\");\n/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./queue.js */ \"(action-browser)/./node_modules/postgres/src/queue.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors.js */ \"(action-browser)/./node_modules/postgres/src/errors.js\");\n/* harmony import */ var _subscribe_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./subscribe.js */ \"(action-browser)/./node_modules/postgres/src/subscribe.js\");\n/* harmony import */ var _large_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./large.js */ \"(action-browser)/./node_modules/postgres/src/large.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nObject.assign(Postgres, {\n  PostgresError: _errors_js__WEBPACK_IMPORTED_MODULE_6__.PostgresError,\n  toPascal: _types_js__WEBPACK_IMPORTED_MODULE_2__.toPascal,\n  pascal: _types_js__WEBPACK_IMPORTED_MODULE_2__.pascal,\n  toCamel: _types_js__WEBPACK_IMPORTED_MODULE_2__.toCamel,\n  camel: _types_js__WEBPACK_IMPORTED_MODULE_2__.camel,\n  toKebab: _types_js__WEBPACK_IMPORTED_MODULE_2__.toKebab,\n  kebab: _types_js__WEBPACK_IMPORTED_MODULE_2__.kebab,\n  fromPascal: _types_js__WEBPACK_IMPORTED_MODULE_2__.fromPascal,\n  fromCamel: _types_js__WEBPACK_IMPORTED_MODULE_2__.fromCamel,\n  fromKebab: _types_js__WEBPACK_IMPORTED_MODULE_2__.fromKebab,\n  BigInt: {\n    to: 20,\n    from: [20],\n    parse: x => BigInt(x), // eslint-disable-line\n    serialize: x => x.toString()\n  }\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Postgres);\n\nfunction Postgres(a, b) {\n  const options = parseOptions(a, b)\n      , subscribe = options.no_subscribe || (0,_subscribe_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Postgres, { ...options })\n\n  let ending = false\n\n  const queries = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , connecting = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , reserved = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , closed = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , ended = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , open = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , busy = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , full = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , queues = { connecting, reserved, closed, ended, open, busy, full }\n\n  const connections = [...Array(options.max)].map(() => (0,_connection_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options, queues, { onopen, onend, onclose }))\n\n  const sql = Sql(handler)\n\n  Object.assign(sql, {\n    get parameters() { return options.parameters },\n    largeObject: _large_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].bind(null, sql),\n    subscribe,\n    CLOSE: _query_js__WEBPACK_IMPORTED_MODULE_4__.CLOSE,\n    END: _query_js__WEBPACK_IMPORTED_MODULE_4__.CLOSE,\n    PostgresError: _errors_js__WEBPACK_IMPORTED_MODULE_6__.PostgresError,\n    options,\n    reserve,\n    listen,\n    begin,\n    close,\n    end\n  })\n\n  return sql\n\n  function Sql(handler) {\n    handler.debug = options.debug\n\n    Object.entries(options.types).reduce((acc, [name, type]) => {\n      acc[name] = (x) => new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(x, type.to)\n      return acc\n    }, typed)\n\n    Object.assign(sql, {\n      types: typed,\n      typed,\n      unsafe,\n      notify,\n      array,\n      json,\n      file\n    })\n\n    return sql\n\n    function typed(value, type) {\n      return new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(value, type)\n    }\n\n    function sql(strings, ...args) {\n      const query = strings && Array.isArray(strings.raw)\n        ? new _query_js__WEBPACK_IMPORTED_MODULE_4__.Query(strings, args, handler, cancel)\n        : typeof strings === 'string' && !args.length\n          ? new _types_js__WEBPACK_IMPORTED_MODULE_2__.Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings)\n          : new _types_js__WEBPACK_IMPORTED_MODULE_2__.Builder(strings, args)\n      return query\n    }\n\n    function unsafe(string, args = [], options = {}) {\n      arguments.length === 2 && !Array.isArray(args) && (options = args, args = [])\n      const query = new _query_js__WEBPACK_IMPORTED_MODULE_4__.Query([string], args, handler, cancel, {\n        prepare: false,\n        ...options,\n        simple: 'simple' in options ? options.simple : args.length === 0\n      })\n      return query\n    }\n\n    function file(path, args = [], options = {}) {\n      arguments.length === 2 && !Array.isArray(args) && (options = args, args = [])\n      const query = new _query_js__WEBPACK_IMPORTED_MODULE_4__.Query([], args, (query) => {\n        fs__WEBPACK_IMPORTED_MODULE_1__.readFile(path, 'utf8', (err, string) => {\n          if (err)\n            return query.reject(err)\n\n          query.strings = [string]\n          handler(query)\n        })\n      }, cancel, {\n        ...options,\n        simple: 'simple' in options ? options.simple : args.length === 0\n      })\n      return query\n    }\n  }\n\n  async function listen(name, fn, onlisten) {\n    const listener = { fn, onlisten }\n\n    const sql = listen.sql || (listen.sql = Postgres({\n      ...options,\n      max: 1,\n      idle_timeout: null,\n      max_lifetime: null,\n      fetch_types: false,\n      onclose() {\n        Object.entries(listen.channels).forEach(([name, { listeners }]) => {\n          delete listen.channels[name]\n          Promise.all(listeners.map(l => listen(name, l.fn, l.onlisten).catch(() => { /* noop */ })))\n        })\n      },\n      onnotify(c, x) {\n        c in listen.channels && listen.channels[c].listeners.forEach(l => l.fn(x))\n      }\n    }))\n\n    const channels = listen.channels || (listen.channels = {})\n        , exists = name in channels\n\n    if (exists) {\n      channels[name].listeners.push(listener)\n      const result = await channels[name].result\n      listener.onlisten && listener.onlisten()\n      return { state: result.state, unlisten }\n    }\n\n    channels[name] = { result: sql`listen ${\n      sql.unsafe('\"' + name.replace(/\"/g, '\"\"') + '\"')\n    }`, listeners: [listener] }\n    const result = await channels[name].result\n    listener.onlisten && listener.onlisten()\n    return { state: result.state, unlisten }\n\n    async function unlisten() {\n      if (name in channels === false)\n        return\n\n      channels[name].listeners = channels[name].listeners.filter(x => x !== listener)\n      if (channels[name].listeners.length)\n        return\n\n      delete channels[name]\n      return sql`unlisten ${\n        sql.unsafe('\"' + name.replace(/\"/g, '\"\"') + '\"')\n      }`\n    }\n  }\n\n  async function notify(channel, payload) {\n    return await sql`select pg_notify(${ channel }, ${ '' + payload })`\n  }\n\n  async function reserve() {\n    const queue = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n    const c = open.length\n      ? open.shift()\n      : await new Promise(r => {\n        queries.push({ reserve: r })\n        closed.length && connect(closed.shift())\n      })\n\n    move(c, reserved)\n    c.reserved = () => queue.length\n      ? c.execute(queue.shift())\n      : move(c, reserved)\n    c.reserved.release = true\n\n    const sql = Sql(handler)\n    sql.release = () => {\n      c.reserved = null\n      onopen(c)\n    }\n\n    return sql\n\n    function handler(q) {\n      c.queue === full\n        ? queue.push(q)\n        : c.execute(q) || move(c, full)\n    }\n  }\n\n  async function begin(options, fn) {\n    !fn && (fn = options, options = '')\n    const queries = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n    let savepoints = 0\n      , connection\n      , prepare = null\n\n    try {\n      await sql.unsafe('begin ' + options.replace(/[^a-z ]/ig, ''), [], { onexecute }).execute()\n      return await scope(connection, fn)\n    } catch (error) {\n      throw error\n    }\n\n    async function scope(c, fn, name) {\n      const sql = Sql(handler)\n      sql.savepoint = savepoint\n      sql.prepare = x => prepare = x.replace(/[^a-z0-9$-_. ]/gi)\n      let uncaughtError\n        , result\n\n      name && await sql`savepoint ${ sql(name) }`\n      try {\n        result = await new Promise((resolve, reject) => {\n          const x = fn(sql)\n          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject)\n        })\n\n        if (uncaughtError)\n          throw uncaughtError\n      } catch (e) {\n        await (name\n          ? sql`rollback to ${ sql(name) }`\n          : sql`rollback`\n        )\n        throw e instanceof _errors_js__WEBPACK_IMPORTED_MODULE_6__.PostgresError && e.code === '25P02' && uncaughtError || e\n      }\n\n      if (!name) {\n        prepare\n          ? await sql`prepare transaction '${ sql.unsafe(prepare) }'`\n          : await sql`commit`\n      }\n\n      return result\n\n      function savepoint(name, fn) {\n        if (name && Array.isArray(name.raw))\n          return savepoint(sql => sql.apply(sql, arguments))\n\n        arguments.length === 1 && (fn = name, name = null)\n        return scope(c, fn, 's' + savepoints++ + (name ? '_' + name : ''))\n      }\n\n      function handler(q) {\n        q.catch(e => uncaughtError || (uncaughtError = e))\n        c.queue === full\n          ? queries.push(q)\n          : c.execute(q) || move(c, full)\n      }\n    }\n\n    function onexecute(c) {\n      connection = c\n      move(c, reserved)\n      c.reserved = () => queries.length\n        ? c.execute(queries.shift())\n        : move(c, reserved)\n    }\n  }\n\n  function move(c, queue) {\n    c.queue.remove(c)\n    queue.push(c)\n    c.queue = queue\n    queue === open\n      ? c.idleTimer.start()\n      : c.idleTimer.cancel()\n    return c\n  }\n\n  function json(x) {\n    return new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(x, 3802)\n  }\n\n  function array(x, type) {\n    if (!Array.isArray(x))\n      return array(Array.from(arguments))\n\n    return new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(x, type || (x.length ? (0,_types_js__WEBPACK_IMPORTED_MODULE_2__.inferType)(x) || 25 : 0), options.shared.typeArrayMap)\n  }\n\n  function handler(query) {\n    if (ending)\n      return query.reject(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_ENDED', options, options))\n\n    if (open.length)\n      return go(open.shift(), query)\n\n    if (closed.length)\n      return connect(closed.shift(), query)\n\n    busy.length\n      ? go(busy.shift(), query)\n      : queries.push(query)\n  }\n\n  function go(c, query) {\n    return c.execute(query)\n      ? move(c, busy)\n      : move(c, full)\n  }\n\n  function cancel(query) {\n    return new Promise((resolve, reject) => {\n      query.state\n        ? query.active\n          ? (0,_connection_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options).cancel(query.state, resolve, reject)\n          : query.cancelled = { resolve, reject }\n        : (\n          queries.remove(query),\n          query.cancelled = true,\n          query.reject(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('57014', 'canceling statement due to user request')),\n          resolve()\n        )\n    })\n  }\n\n  async function end({ timeout = null } = {}) {\n    if (ending)\n      return ending\n\n    await 1\n    let timer\n    return ending = Promise.race([\n      new Promise(r => timeout !== null && (timer = setTimeout(destroy, timeout * 1000, r))),\n      Promise.all(connections.map(c => c.end()).concat(\n        listen.sql ? listen.sql.end({ timeout: 0 }) : [],\n        subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []\n      ))\n    ]).then(() => clearTimeout(timer))\n  }\n\n  async function close() {\n    await Promise.all(connections.map(c => c.end()))\n  }\n\n  async function destroy(resolve) {\n    await Promise.all(connections.map(c => c.terminate()))\n    while (queries.length)\n      queries.shift().reject(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_DESTROYED', options))\n    resolve()\n  }\n\n  function connect(c, query) {\n    move(c, connecting)\n    c.connect(query)\n    return c\n  }\n\n  function onend(c) {\n    move(c, ended)\n  }\n\n  function onopen(c) {\n    if (queries.length === 0)\n      return move(c, open)\n\n    let max = Math.ceil(queries.length / (connecting.length + 1))\n      , ready = true\n\n    while (ready && queries.length && max-- > 0) {\n      const query = queries.shift()\n      if (query.reserve)\n        return query.reserve(c)\n\n      ready = c.execute(query)\n    }\n\n    ready\n      ? move(c, busy)\n      : move(c, full)\n  }\n\n  function onclose(c) {\n    move(c, closed)\n    c.reserved = null\n    options.onclose && options.onclose(c.id)\n    queries.length && connect(c, queries.shift())\n  }\n}\n\nfunction parseOptions(a, b) {\n  if (a && a.shared)\n    return a\n\n  const env = process.env // eslint-disable-line\n      , o = (!a || typeof a === 'string' ? b : a) || {}\n      , { url, multihost } = parseUrl(a)\n      , query = [...url.searchParams].reduce((a, [b, c]) => (a[b] = c, a), {})\n      , host = o.hostname || o.host || multihost || url.hostname || env.PGHOST || 'localhost'\n      , port = o.port || url.port || env.PGPORT || 5432\n      , user = o.user || o.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername()\n\n  o.no_prepare && (o.prepare = false)\n  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode)\n  'timeout' in o && (console.log('The timeout option is deprecated, use idle_timeout instead'), o.idle_timeout = o.timeout) // eslint-disable-line\n\n  const ints = ['idle_timeout', 'connect_timeout', 'max_lifetime', 'max_pipeline', 'backoff', 'keep_alive']\n  const defaults = {\n    max             : 10,\n    ssl             : false,\n    idle_timeout    : null,\n    connect_timeout : 30,\n    max_lifetime    : max_lifetime,\n    max_pipeline    : 100,\n    backoff         : backoff,\n    keep_alive      : 60,\n    prepare         : true,\n    debug           : false,\n    fetch_types     : true,\n    publications    : 'alltables',\n    target_session_attrs: null\n  }\n\n  return {\n    host            : Array.isArray(host) ? host : host.split(',').map(x => x.split(':')[0]),\n    port            : Array.isArray(port) ? port : host.split(',').map(x => parseInt(x.split(':')[1] || port)),\n    path            : o.path || host.indexOf('/') > -1 && host + '/.s.PGSQL.' + port,\n    database        : o.database || o.db || (url.pathname || '').slice(1) || env.PGDATABASE || user,\n    user            : user,\n    pass            : o.pass || o.password || url.password || env.PGPASSWORD || '',\n    ...Object.entries(defaults).reduce(\n      (acc, [k, d]) => {\n        const value = k in o ? o[k] : k in query\n          ? (query[k] === 'disable' || query[k] === 'false' ? false : query[k])\n          : env['PG' + k.toUpperCase()] || d\n        acc[k] = typeof value === 'string' && ints.includes(k)\n          ? +value\n          : value\n        return acc\n      },\n      {}\n    ),\n    connection      : {\n      application_name: 'postgres.js',\n      ...o.connection,\n      ...Object.entries(query).reduce((acc, [k, v]) => (k in defaults || (acc[k] = v), acc), {})\n    },\n    types           : o.types || {},\n    target_session_attrs: tsa(o, url, env),\n    onnotice        : o.onnotice,\n    onnotify        : o.onnotify,\n    onclose         : o.onclose,\n    onparameter     : o.onparameter,\n    socket          : o.socket,\n    transform       : parseTransform(o.transform || { undefined: undefined }),\n    parameters      : {},\n    shared          : { retries: 0, typeArrayMap: {} },\n    ...(0,_types_js__WEBPACK_IMPORTED_MODULE_2__.mergeUserTypes)(o.types)\n  }\n}\n\nfunction tsa(o, url, env) {\n  const x = o.target_session_attrs || url.searchParams.get('target_session_attrs') || env.PGTARGETSESSIONATTRS\n  if (!x || ['read-write', 'read-only', 'primary', 'standby', 'prefer-standby'].includes(x))\n    return x\n\n  throw new Error('target_session_attrs ' + x + ' is not supported')\n}\n\nfunction backoff(retries) {\n  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20)\n}\n\nfunction max_lifetime() {\n  return 60 * (30 + Math.random() * 30)\n}\n\nfunction parseTransform(x) {\n  return {\n    undefined: x.undefined,\n    column: {\n      from: typeof x.column === 'function' ? x.column : x.column && x.column.from,\n      to: x.column && x.column.to\n    },\n    value: {\n      from: typeof x.value === 'function' ? x.value : x.value && x.value.from,\n      to: x.value && x.value.to\n    },\n    row: {\n      from: typeof x.row === 'function' ? x.row : x.row && x.row.from,\n      to: x.row && x.row.to\n    }\n  }\n}\n\nfunction parseUrl(url) {\n  if (!url || typeof url !== 'string')\n    return { url: { searchParams: new Map() } }\n\n  let host = url\n  host = host.slice(host.indexOf('://') + 3).split(/[?/]/)[0]\n  host = decodeURIComponent(host.slice(host.indexOf('@') + 1))\n\n  const urlObj = new URL(url.replace(host, host.split(',')[0]))\n\n  return {\n    url: {\n      username: decodeURIComponent(urlObj.username),\n      password: decodeURIComponent(urlObj.password),\n      host: urlObj.host,\n      hostname: urlObj.hostname,\n      port: urlObj.port,\n      pathname: urlObj.pathname,\n      searchParams: urlObj.searchParams\n    },\n    multihost: host.indexOf(',') > -1 && host\n  }\n}\n\nfunction osUsername() {\n  try {\n    return os__WEBPACK_IMPORTED_MODULE_0__.userInfo().username // eslint-disable-line\n  } catch (_) {\n    return process.env.USERNAME || process.env.USER || process.env.LOGNAME  // eslint-disable-line\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFtQjtBQUNBOztBQWlCQTs7QUFFcUI7QUFDQztBQUNYO0FBQ3FCO0FBQ2I7QUFDRjs7QUFFcEM7QUFDQSxlQUFlO0FBQ2YsVUFBVTtBQUNWLFFBQVE7QUFDUixTQUFTO0FBQ1QsT0FBTztBQUNQLFNBQVM7QUFDVCxPQUFPO0FBQ1AsWUFBWTtBQUNaLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpRUFBZSxRQUFROztBQUV2QjtBQUNBO0FBQ0EsNENBQTRDLHlEQUFTLGFBQWEsWUFBWTs7QUFFOUU7O0FBRUEsa0JBQWtCLHFEQUFLO0FBQ3ZCLHFCQUFxQixxREFBSztBQUMxQixtQkFBbUIscURBQUs7QUFDeEIsaUJBQWlCLHFEQUFLO0FBQ3RCLGdCQUFnQixxREFBSztBQUNyQixlQUFlLHFEQUFLO0FBQ3BCLGVBQWUscURBQUs7QUFDcEIsZUFBZSxxREFBSztBQUNwQixtQkFBbUI7O0FBRW5CLHdEQUF3RCwwREFBVSxvQkFBb0Isd0JBQXdCOztBQUU5Rzs7QUFFQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQsaUJBQWlCLHNEQUFnQjtBQUNqQztBQUNBLFNBQVM7QUFDVCxTQUFTLDRDQUFLO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnREFBUztBQUN0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxpQkFBaUIsZ0RBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsNENBQUs7QUFDbkI7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUIsZ0JBQWdCLDhDQUFPO0FBQ3ZCO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0Esd0JBQXdCLDRDQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBLHdCQUF3Qiw0Q0FBSztBQUM3QixRQUFRLHdDQUFXO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQSxzRkFBc0YsWUFBWTtBQUNsRyxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVMsS0FBSyxjQUFjO0FBQ3JFOztBQUVBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscURBQUs7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLFdBQVc7QUFDckY7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0EsMkJBQTJCLHFEQUFhO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0RBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsZ0RBQVMsd0JBQXdCLG9EQUFTO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQU07O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBVTtBQUN0QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsdUJBQXVCLGlCQUFpQixJQUFJO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xELDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhDQUFNO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0YsS0FBSztBQUNMLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsc0JBQXNCO0FBQzVFLHdCQUF3QjtBQUN4Qix3QkFBd0IsOEJBQThCO0FBQ3RELE9BQU8seURBQWM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsd0NBQVc7QUFDdEIsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29uZWNhcmQvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2luZGV4LmpzPzcxMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9zIGZyb20gJ29zJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuXG5pbXBvcnQge1xuICBtZXJnZVVzZXJUeXBlcyxcbiAgaW5mZXJUeXBlLFxuICBQYXJhbWV0ZXIsXG4gIElkZW50aWZpZXIsXG4gIEJ1aWxkZXIsXG4gIHRvUGFzY2FsLFxuICBwYXNjYWwsXG4gIHRvQ2FtZWwsXG4gIGNhbWVsLFxuICB0b0tlYmFiLFxuICBrZWJhYixcbiAgZnJvbVBhc2NhbCxcbiAgZnJvbUNhbWVsLFxuICBmcm9tS2ViYWJcbn0gZnJvbSAnLi90eXBlcy5qcydcblxuaW1wb3J0IENvbm5lY3Rpb24gZnJvbSAnLi9jb25uZWN0aW9uLmpzJ1xuaW1wb3J0IHsgUXVlcnksIENMT1NFIH0gZnJvbSAnLi9xdWVyeS5qcydcbmltcG9ydCBRdWV1ZSBmcm9tICcuL3F1ZXVlLmpzJ1xuaW1wb3J0IHsgRXJyb3JzLCBQb3N0Z3Jlc0Vycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnXG5pbXBvcnQgU3Vic2NyaWJlIGZyb20gJy4vc3Vic2NyaWJlLmpzJ1xuaW1wb3J0IGxhcmdlT2JqZWN0IGZyb20gJy4vbGFyZ2UuanMnXG5cbk9iamVjdC5hc3NpZ24oUG9zdGdyZXMsIHtcbiAgUG9zdGdyZXNFcnJvcixcbiAgdG9QYXNjYWwsXG4gIHBhc2NhbCxcbiAgdG9DYW1lbCxcbiAgY2FtZWwsXG4gIHRvS2ViYWIsXG4gIGtlYmFiLFxuICBmcm9tUGFzY2FsLFxuICBmcm9tQ2FtZWwsXG4gIGZyb21LZWJhYixcbiAgQmlnSW50OiB7XG4gICAgdG86IDIwLFxuICAgIGZyb206IFsyMF0sXG4gICAgcGFyc2U6IHggPT4gQmlnSW50KHgpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgc2VyaWFsaXplOiB4ID0+IHgudG9TdHJpbmcoKVxuICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBQb3N0Z3Jlc1xuXG5mdW5jdGlvbiBQb3N0Z3JlcyhhLCBiKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMoYSwgYilcbiAgICAgICwgc3Vic2NyaWJlID0gb3B0aW9ucy5ub19zdWJzY3JpYmUgfHwgU3Vic2NyaWJlKFBvc3RncmVzLCB7IC4uLm9wdGlvbnMgfSlcblxuICBsZXQgZW5kaW5nID0gZmFsc2VcblxuICBjb25zdCBxdWVyaWVzID0gUXVldWUoKVxuICAgICAgLCBjb25uZWN0aW5nID0gUXVldWUoKVxuICAgICAgLCByZXNlcnZlZCA9IFF1ZXVlKClcbiAgICAgICwgY2xvc2VkID0gUXVldWUoKVxuICAgICAgLCBlbmRlZCA9IFF1ZXVlKClcbiAgICAgICwgb3BlbiA9IFF1ZXVlKClcbiAgICAgICwgYnVzeSA9IFF1ZXVlKClcbiAgICAgICwgZnVsbCA9IFF1ZXVlKClcbiAgICAgICwgcXVldWVzID0geyBjb25uZWN0aW5nLCByZXNlcnZlZCwgY2xvc2VkLCBlbmRlZCwgb3BlbiwgYnVzeSwgZnVsbCB9XG5cbiAgY29uc3QgY29ubmVjdGlvbnMgPSBbLi4uQXJyYXkob3B0aW9ucy5tYXgpXS5tYXAoKCkgPT4gQ29ubmVjdGlvbihvcHRpb25zLCBxdWV1ZXMsIHsgb25vcGVuLCBvbmVuZCwgb25jbG9zZSB9KSlcblxuICBjb25zdCBzcWwgPSBTcWwoaGFuZGxlcilcblxuICBPYmplY3QuYXNzaWduKHNxbCwge1xuICAgIGdldCBwYXJhbWV0ZXJzKCkgeyByZXR1cm4gb3B0aW9ucy5wYXJhbWV0ZXJzIH0sXG4gICAgbGFyZ2VPYmplY3Q6IGxhcmdlT2JqZWN0LmJpbmQobnVsbCwgc3FsKSxcbiAgICBzdWJzY3JpYmUsXG4gICAgQ0xPU0UsXG4gICAgRU5EOiBDTE9TRSxcbiAgICBQb3N0Z3Jlc0Vycm9yLFxuICAgIG9wdGlvbnMsXG4gICAgcmVzZXJ2ZSxcbiAgICBsaXN0ZW4sXG4gICAgYmVnaW4sXG4gICAgY2xvc2UsXG4gICAgZW5kXG4gIH0pXG5cbiAgcmV0dXJuIHNxbFxuXG4gIGZ1bmN0aW9uIFNxbChoYW5kbGVyKSB7XG4gICAgaGFuZGxlci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWdcblxuICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudHlwZXMpLnJlZHVjZSgoYWNjLCBbbmFtZSwgdHlwZV0pID0+IHtcbiAgICAgIGFjY1tuYW1lXSA9ICh4KSA9PiBuZXcgUGFyYW1ldGVyKHgsIHR5cGUudG8pXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgdHlwZWQpXG5cbiAgICBPYmplY3QuYXNzaWduKHNxbCwge1xuICAgICAgdHlwZXM6IHR5cGVkLFxuICAgICAgdHlwZWQsXG4gICAgICB1bnNhZmUsXG4gICAgICBub3RpZnksXG4gICAgICBhcnJheSxcbiAgICAgIGpzb24sXG4gICAgICBmaWxlXG4gICAgfSlcblxuICAgIHJldHVybiBzcWxcblxuICAgIGZ1bmN0aW9uIHR5cGVkKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gbmV3IFBhcmFtZXRlcih2YWx1ZSwgdHlwZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcWwoc3RyaW5ncywgLi4uYXJncykge1xuICAgICAgY29uc3QgcXVlcnkgPSBzdHJpbmdzICYmIEFycmF5LmlzQXJyYXkoc3RyaW5ncy5yYXcpXG4gICAgICAgID8gbmV3IFF1ZXJ5KHN0cmluZ3MsIGFyZ3MsIGhhbmRsZXIsIGNhbmNlbClcbiAgICAgICAgOiB0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycgJiYgIWFyZ3MubGVuZ3RoXG4gICAgICAgICAgPyBuZXcgSWRlbnRpZmllcihvcHRpb25zLnRyYW5zZm9ybS5jb2x1bW4udG8gPyBvcHRpb25zLnRyYW5zZm9ybS5jb2x1bW4udG8oc3RyaW5ncykgOiBzdHJpbmdzKVxuICAgICAgICAgIDogbmV3IEJ1aWxkZXIoc3RyaW5ncywgYXJncylcbiAgICAgIHJldHVybiBxdWVyeVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuc2FmZShzdHJpbmcsIGFyZ3MgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFBcnJheS5pc0FycmF5KGFyZ3MpICYmIChvcHRpb25zID0gYXJncywgYXJncyA9IFtdKVxuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoW3N0cmluZ10sIGFyZ3MsIGhhbmRsZXIsIGNhbmNlbCwge1xuICAgICAgICBwcmVwYXJlOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2ltcGxlOiAnc2ltcGxlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zaW1wbGUgOiBhcmdzLmxlbmd0aCA9PT0gMFxuICAgICAgfSlcbiAgICAgIHJldHVybiBxdWVyeVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGUocGF0aCwgYXJncyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIUFycmF5LmlzQXJyYXkoYXJncykgJiYgKG9wdGlvbnMgPSBhcmdzLCBhcmdzID0gW10pXG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeShbXSwgYXJncywgKHF1ZXJ5KSA9PiB7XG4gICAgICAgIGZzLnJlYWRGaWxlKHBhdGgsICd1dGY4JywgKGVyciwgc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5yZWplY3QoZXJyKVxuXG4gICAgICAgICAgcXVlcnkuc3RyaW5ncyA9IFtzdHJpbmddXG4gICAgICAgICAgaGFuZGxlcihxdWVyeSlcbiAgICAgICAgfSlcbiAgICAgIH0sIGNhbmNlbCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzaW1wbGU6ICdzaW1wbGUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnNpbXBsZSA6IGFyZ3MubGVuZ3RoID09PSAwXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHF1ZXJ5XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbGlzdGVuKG5hbWUsIGZuLCBvbmxpc3Rlbikge1xuICAgIGNvbnN0IGxpc3RlbmVyID0geyBmbiwgb25saXN0ZW4gfVxuXG4gICAgY29uc3Qgc3FsID0gbGlzdGVuLnNxbCB8fCAobGlzdGVuLnNxbCA9IFBvc3RncmVzKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBtYXg6IDEsXG4gICAgICBpZGxlX3RpbWVvdXQ6IG51bGwsXG4gICAgICBtYXhfbGlmZXRpbWU6IG51bGwsXG4gICAgICBmZXRjaF90eXBlczogZmFsc2UsXG4gICAgICBvbmNsb3NlKCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhsaXN0ZW4uY2hhbm5lbHMpLmZvckVhY2goKFtuYW1lLCB7IGxpc3RlbmVycyB9XSkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW4uY2hhbm5lbHNbbmFtZV1cbiAgICAgICAgICBQcm9taXNlLmFsbChsaXN0ZW5lcnMubWFwKGwgPT4gbGlzdGVuKG5hbWUsIGwuZm4sIGwub25saXN0ZW4pLmNhdGNoKCgpID0+IHsgLyogbm9vcCAqLyB9KSkpXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgb25ub3RpZnkoYywgeCkge1xuICAgICAgICBjIGluIGxpc3Rlbi5jaGFubmVscyAmJiBsaXN0ZW4uY2hhbm5lbHNbY10ubGlzdGVuZXJzLmZvckVhY2gobCA9PiBsLmZuKHgpKVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgY29uc3QgY2hhbm5lbHMgPSBsaXN0ZW4uY2hhbm5lbHMgfHwgKGxpc3Rlbi5jaGFubmVscyA9IHt9KVxuICAgICAgICAsIGV4aXN0cyA9IG5hbWUgaW4gY2hhbm5lbHNcblxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGNoYW5uZWxzW25hbWVdLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhbm5lbHNbbmFtZV0ucmVzdWx0XG4gICAgICBsaXN0ZW5lci5vbmxpc3RlbiAmJiBsaXN0ZW5lci5vbmxpc3RlbigpXG4gICAgICByZXR1cm4geyBzdGF0ZTogcmVzdWx0LnN0YXRlLCB1bmxpc3RlbiB9XG4gICAgfVxuXG4gICAgY2hhbm5lbHNbbmFtZV0gPSB7IHJlc3VsdDogc3FsYGxpc3RlbiAke1xuICAgICAgc3FsLnVuc2FmZSgnXCInICsgbmFtZS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpICsgJ1wiJylcbiAgICB9YCwgbGlzdGVuZXJzOiBbbGlzdGVuZXJdIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFubmVsc1tuYW1lXS5yZXN1bHRcbiAgICBsaXN0ZW5lci5vbmxpc3RlbiAmJiBsaXN0ZW5lci5vbmxpc3RlbigpXG4gICAgcmV0dXJuIHsgc3RhdGU6IHJlc3VsdC5zdGF0ZSwgdW5saXN0ZW4gfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdW5saXN0ZW4oKSB7XG4gICAgICBpZiAobmFtZSBpbiBjaGFubmVscyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBjaGFubmVsc1tuYW1lXS5saXN0ZW5lcnMgPSBjaGFubmVsc1tuYW1lXS5saXN0ZW5lcnMuZmlsdGVyKHggPT4geCAhPT0gbGlzdGVuZXIpXG4gICAgICBpZiAoY2hhbm5lbHNbbmFtZV0ubGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGRlbGV0ZSBjaGFubmVsc1tuYW1lXVxuICAgICAgcmV0dXJuIHNxbGB1bmxpc3RlbiAke1xuICAgICAgICBzcWwudW5zYWZlKCdcIicgKyBuYW1lLnJlcGxhY2UoL1wiL2csICdcIlwiJykgKyAnXCInKVxuICAgICAgfWBcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBub3RpZnkoY2hhbm5lbCwgcGF5bG9hZCkge1xuICAgIHJldHVybiBhd2FpdCBzcWxgc2VsZWN0IHBnX25vdGlmeSgkeyBjaGFubmVsIH0sICR7ICcnICsgcGF5bG9hZCB9KWBcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHJlc2VydmUoKSB7XG4gICAgY29uc3QgcXVldWUgPSBRdWV1ZSgpXG4gICAgY29uc3QgYyA9IG9wZW4ubGVuZ3RoXG4gICAgICA/IG9wZW4uc2hpZnQoKVxuICAgICAgOiBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHtcbiAgICAgICAgcXVlcmllcy5wdXNoKHsgcmVzZXJ2ZTogciB9KVxuICAgICAgICBjbG9zZWQubGVuZ3RoICYmIGNvbm5lY3QoY2xvc2VkLnNoaWZ0KCkpXG4gICAgICB9KVxuXG4gICAgbW92ZShjLCByZXNlcnZlZClcbiAgICBjLnJlc2VydmVkID0gKCkgPT4gcXVldWUubGVuZ3RoXG4gICAgICA/IGMuZXhlY3V0ZShxdWV1ZS5zaGlmdCgpKVxuICAgICAgOiBtb3ZlKGMsIHJlc2VydmVkKVxuICAgIGMucmVzZXJ2ZWQucmVsZWFzZSA9IHRydWVcblxuICAgIGNvbnN0IHNxbCA9IFNxbChoYW5kbGVyKVxuICAgIHNxbC5yZWxlYXNlID0gKCkgPT4ge1xuICAgICAgYy5yZXNlcnZlZCA9IG51bGxcbiAgICAgIG9ub3BlbihjKVxuICAgIH1cblxuICAgIHJldHVybiBzcWxcblxuICAgIGZ1bmN0aW9uIGhhbmRsZXIocSkge1xuICAgICAgYy5xdWV1ZSA9PT0gZnVsbFxuICAgICAgICA/IHF1ZXVlLnB1c2gocSlcbiAgICAgICAgOiBjLmV4ZWN1dGUocSkgfHwgbW92ZShjLCBmdWxsKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGJlZ2luKG9wdGlvbnMsIGZuKSB7XG4gICAgIWZuICYmIChmbiA9IG9wdGlvbnMsIG9wdGlvbnMgPSAnJylcbiAgICBjb25zdCBxdWVyaWVzID0gUXVldWUoKVxuICAgIGxldCBzYXZlcG9pbnRzID0gMFxuICAgICAgLCBjb25uZWN0aW9uXG4gICAgICAsIHByZXBhcmUgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3FsLnVuc2FmZSgnYmVnaW4gJyArIG9wdGlvbnMucmVwbGFjZSgvW15hLXogXS9pZywgJycpLCBbXSwgeyBvbmV4ZWN1dGUgfSkuZXhlY3V0ZSgpXG4gICAgICByZXR1cm4gYXdhaXQgc2NvcGUoY29ubmVjdGlvbiwgZm4pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2NvcGUoYywgZm4sIG5hbWUpIHtcbiAgICAgIGNvbnN0IHNxbCA9IFNxbChoYW5kbGVyKVxuICAgICAgc3FsLnNhdmVwb2ludCA9IHNhdmVwb2ludFxuICAgICAgc3FsLnByZXBhcmUgPSB4ID0+IHByZXBhcmUgPSB4LnJlcGxhY2UoL1teYS16MC05JC1fLiBdL2dpKVxuICAgICAgbGV0IHVuY2F1Z2h0RXJyb3JcbiAgICAgICAgLCByZXN1bHRcblxuICAgICAgbmFtZSAmJiBhd2FpdCBzcWxgc2F2ZXBvaW50ICR7IHNxbChuYW1lKSB9YFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHggPSBmbihzcWwpXG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKEFycmF5LmlzQXJyYXkoeCkgPyBQcm9taXNlLmFsbCh4KSA6IHgpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh1bmNhdWdodEVycm9yKVxuICAgICAgICAgIHRocm93IHVuY2F1Z2h0RXJyb3JcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXdhaXQgKG5hbWVcbiAgICAgICAgICA/IHNxbGByb2xsYmFjayB0byAkeyBzcWwobmFtZSkgfWBcbiAgICAgICAgICA6IHNxbGByb2xsYmFja2BcbiAgICAgICAgKVxuICAgICAgICB0aHJvdyBlIGluc3RhbmNlb2YgUG9zdGdyZXNFcnJvciAmJiBlLmNvZGUgPT09ICcyNVAwMicgJiYgdW5jYXVnaHRFcnJvciB8fCBlXG4gICAgICB9XG5cbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBwcmVwYXJlXG4gICAgICAgICAgPyBhd2FpdCBzcWxgcHJlcGFyZSB0cmFuc2FjdGlvbiAnJHsgc3FsLnVuc2FmZShwcmVwYXJlKSB9J2BcbiAgICAgICAgICA6IGF3YWl0IHNxbGBjb21taXRgXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcblxuICAgICAgZnVuY3Rpb24gc2F2ZXBvaW50KG5hbWUsIGZuKSB7XG4gICAgICAgIGlmIChuYW1lICYmIEFycmF5LmlzQXJyYXkobmFtZS5yYXcpKVxuICAgICAgICAgIHJldHVybiBzYXZlcG9pbnQoc3FsID0+IHNxbC5hcHBseShzcWwsIGFyZ3VtZW50cykpXG5cbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAoZm4gPSBuYW1lLCBuYW1lID0gbnVsbClcbiAgICAgICAgcmV0dXJuIHNjb3BlKGMsIGZuLCAncycgKyBzYXZlcG9pbnRzKysgKyAobmFtZSA/ICdfJyArIG5hbWUgOiAnJykpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIocSkge1xuICAgICAgICBxLmNhdGNoKGUgPT4gdW5jYXVnaHRFcnJvciB8fCAodW5jYXVnaHRFcnJvciA9IGUpKVxuICAgICAgICBjLnF1ZXVlID09PSBmdWxsXG4gICAgICAgICAgPyBxdWVyaWVzLnB1c2gocSlcbiAgICAgICAgICA6IGMuZXhlY3V0ZShxKSB8fCBtb3ZlKGMsIGZ1bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25leGVjdXRlKGMpIHtcbiAgICAgIGNvbm5lY3Rpb24gPSBjXG4gICAgICBtb3ZlKGMsIHJlc2VydmVkKVxuICAgICAgYy5yZXNlcnZlZCA9ICgpID0+IHF1ZXJpZXMubGVuZ3RoXG4gICAgICAgID8gYy5leGVjdXRlKHF1ZXJpZXMuc2hpZnQoKSlcbiAgICAgICAgOiBtb3ZlKGMsIHJlc2VydmVkKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmUoYywgcXVldWUpIHtcbiAgICBjLnF1ZXVlLnJlbW92ZShjKVxuICAgIHF1ZXVlLnB1c2goYylcbiAgICBjLnF1ZXVlID0gcXVldWVcbiAgICBxdWV1ZSA9PT0gb3BlblxuICAgICAgPyBjLmlkbGVUaW1lci5zdGFydCgpXG4gICAgICA6IGMuaWRsZVRpbWVyLmNhbmNlbCgpXG4gICAgcmV0dXJuIGNcbiAgfVxuXG4gIGZ1bmN0aW9uIGpzb24oeCkge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyKHgsIDM4MDIpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheSh4LCB0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHgpKVxuICAgICAgcmV0dXJuIGFycmF5KEFycmF5LmZyb20oYXJndW1lbnRzKSlcblxuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyKHgsIHR5cGUgfHwgKHgubGVuZ3RoID8gaW5mZXJUeXBlKHgpIHx8IDI1IDogMCksIG9wdGlvbnMuc2hhcmVkLnR5cGVBcnJheU1hcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZXIocXVlcnkpIHtcbiAgICBpZiAoZW5kaW5nKVxuICAgICAgcmV0dXJuIHF1ZXJ5LnJlamVjdChFcnJvcnMuY29ubmVjdGlvbignQ09OTkVDVElPTl9FTkRFRCcsIG9wdGlvbnMsIG9wdGlvbnMpKVxuXG4gICAgaWYgKG9wZW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIGdvKG9wZW4uc2hpZnQoKSwgcXVlcnkpXG5cbiAgICBpZiAoY2xvc2VkLmxlbmd0aClcbiAgICAgIHJldHVybiBjb25uZWN0KGNsb3NlZC5zaGlmdCgpLCBxdWVyeSlcblxuICAgIGJ1c3kubGVuZ3RoXG4gICAgICA/IGdvKGJ1c3kuc2hpZnQoKSwgcXVlcnkpXG4gICAgICA6IHF1ZXJpZXMucHVzaChxdWVyeSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGMuZXhlY3V0ZShxdWVyeSlcbiAgICAgID8gbW92ZShjLCBidXN5KVxuICAgICAgOiBtb3ZlKGMsIGZ1bGwpXG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwocXVlcnkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcXVlcnkuc3RhdGVcbiAgICAgICAgPyBxdWVyeS5hY3RpdmVcbiAgICAgICAgICA/IENvbm5lY3Rpb24ob3B0aW9ucykuY2FuY2VsKHF1ZXJ5LnN0YXRlLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgICAgOiBxdWVyeS5jYW5jZWxsZWQgPSB7IHJlc29sdmUsIHJlamVjdCB9XG4gICAgICAgIDogKFxuICAgICAgICAgIHF1ZXJpZXMucmVtb3ZlKHF1ZXJ5KSxcbiAgICAgICAgICBxdWVyeS5jYW5jZWxsZWQgPSB0cnVlLFxuICAgICAgICAgIHF1ZXJ5LnJlamVjdChFcnJvcnMuZ2VuZXJpYygnNTcwMTQnLCAnY2FuY2VsaW5nIHN0YXRlbWVudCBkdWUgdG8gdXNlciByZXF1ZXN0JykpLFxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICApXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGVuZCh7IHRpbWVvdXQgPSBudWxsIH0gPSB7fSkge1xuICAgIGlmIChlbmRpbmcpXG4gICAgICByZXR1cm4gZW5kaW5nXG5cbiAgICBhd2FpdCAxXG4gICAgbGV0IHRpbWVyXG4gICAgcmV0dXJuIGVuZGluZyA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZShyID0+IHRpbWVvdXQgIT09IG51bGwgJiYgKHRpbWVyID0gc2V0VGltZW91dChkZXN0cm95LCB0aW1lb3V0ICogMTAwMCwgcikpKSxcbiAgICAgIFByb21pc2UuYWxsKGNvbm5lY3Rpb25zLm1hcChjID0+IGMuZW5kKCkpLmNvbmNhdChcbiAgICAgICAgbGlzdGVuLnNxbCA/IGxpc3Rlbi5zcWwuZW5kKHsgdGltZW91dDogMCB9KSA6IFtdLFxuICAgICAgICBzdWJzY3JpYmUuc3FsID8gc3Vic2NyaWJlLnNxbC5lbmQoeyB0aW1lb3V0OiAwIH0pIDogW11cbiAgICAgICkpXG4gICAgXSkudGhlbigoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY29ubmVjdGlvbnMubWFwKGMgPT4gYy5lbmQoKSkpXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBkZXN0cm95KHJlc29sdmUpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChjb25uZWN0aW9ucy5tYXAoYyA9PiBjLnRlcm1pbmF0ZSgpKSlcbiAgICB3aGlsZSAocXVlcmllcy5sZW5ndGgpXG4gICAgICBxdWVyaWVzLnNoaWZ0KCkucmVqZWN0KEVycm9ycy5jb25uZWN0aW9uKCdDT05ORUNUSU9OX0RFU1RST1lFRCcsIG9wdGlvbnMpKVxuICAgIHJlc29sdmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gY29ubmVjdChjLCBxdWVyeSkge1xuICAgIG1vdmUoYywgY29ubmVjdGluZylcbiAgICBjLmNvbm5lY3QocXVlcnkpXG4gICAgcmV0dXJuIGNcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKGMpIHtcbiAgICBtb3ZlKGMsIGVuZGVkKVxuICB9XG5cbiAgZnVuY3Rpb24gb25vcGVuKGMpIHtcbiAgICBpZiAocXVlcmllcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbW92ZShjLCBvcGVuKVxuXG4gICAgbGV0IG1heCA9IE1hdGguY2VpbChxdWVyaWVzLmxlbmd0aCAvIChjb25uZWN0aW5nLmxlbmd0aCArIDEpKVxuICAgICAgLCByZWFkeSA9IHRydWVcblxuICAgIHdoaWxlIChyZWFkeSAmJiBxdWVyaWVzLmxlbmd0aCAmJiBtYXgtLSA+IDApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcmllcy5zaGlmdCgpXG4gICAgICBpZiAocXVlcnkucmVzZXJ2ZSlcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnJlc2VydmUoYylcblxuICAgICAgcmVhZHkgPSBjLmV4ZWN1dGUocXVlcnkpXG4gICAgfVxuXG4gICAgcmVhZHlcbiAgICAgID8gbW92ZShjLCBidXN5KVxuICAgICAgOiBtb3ZlKGMsIGZ1bGwpXG4gIH1cblxuICBmdW5jdGlvbiBvbmNsb3NlKGMpIHtcbiAgICBtb3ZlKGMsIGNsb3NlZClcbiAgICBjLnJlc2VydmVkID0gbnVsbFxuICAgIG9wdGlvbnMub25jbG9zZSAmJiBvcHRpb25zLm9uY2xvc2UoYy5pZClcbiAgICBxdWVyaWVzLmxlbmd0aCAmJiBjb25uZWN0KGMsIHF1ZXJpZXMuc2hpZnQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoYSwgYikge1xuICBpZiAoYSAmJiBhLnNoYXJlZClcbiAgICByZXR1cm4gYVxuXG4gIGNvbnN0IGVudiA9IHByb2Nlc3MuZW52IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICwgbyA9ICghYSB8fCB0eXBlb2YgYSA9PT0gJ3N0cmluZycgPyBiIDogYSkgfHwge31cbiAgICAgICwgeyB1cmwsIG11bHRpaG9zdCB9ID0gcGFyc2VVcmwoYSlcbiAgICAgICwgcXVlcnkgPSBbLi4udXJsLnNlYXJjaFBhcmFtc10ucmVkdWNlKChhLCBbYiwgY10pID0+IChhW2JdID0gYywgYSksIHt9KVxuICAgICAgLCBob3N0ID0gby5ob3N0bmFtZSB8fCBvLmhvc3QgfHwgbXVsdGlob3N0IHx8IHVybC5ob3N0bmFtZSB8fCBlbnYuUEdIT1NUIHx8ICdsb2NhbGhvc3QnXG4gICAgICAsIHBvcnQgPSBvLnBvcnQgfHwgdXJsLnBvcnQgfHwgZW52LlBHUE9SVCB8fCA1NDMyXG4gICAgICAsIHVzZXIgPSBvLnVzZXIgfHwgby51c2VybmFtZSB8fCB1cmwudXNlcm5hbWUgfHwgZW52LlBHVVNFUk5BTUUgfHwgZW52LlBHVVNFUiB8fCBvc1VzZXJuYW1lKClcblxuICBvLm5vX3ByZXBhcmUgJiYgKG8ucHJlcGFyZSA9IGZhbHNlKVxuICBxdWVyeS5zc2xtb2RlICYmIChxdWVyeS5zc2wgPSBxdWVyeS5zc2xtb2RlLCBkZWxldGUgcXVlcnkuc3NsbW9kZSlcbiAgJ3RpbWVvdXQnIGluIG8gJiYgKGNvbnNvbGUubG9nKCdUaGUgdGltZW91dCBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIGlkbGVfdGltZW91dCBpbnN0ZWFkJyksIG8uaWRsZV90aW1lb3V0ID0gby50aW1lb3V0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgY29uc3QgaW50cyA9IFsnaWRsZV90aW1lb3V0JywgJ2Nvbm5lY3RfdGltZW91dCcsICdtYXhfbGlmZXRpbWUnLCAnbWF4X3BpcGVsaW5lJywgJ2JhY2tvZmYnLCAna2VlcF9hbGl2ZSddXG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIG1heCAgICAgICAgICAgICA6IDEwLFxuICAgIHNzbCAgICAgICAgICAgICA6IGZhbHNlLFxuICAgIGlkbGVfdGltZW91dCAgICA6IG51bGwsXG4gICAgY29ubmVjdF90aW1lb3V0IDogMzAsXG4gICAgbWF4X2xpZmV0aW1lICAgIDogbWF4X2xpZmV0aW1lLFxuICAgIG1heF9waXBlbGluZSAgICA6IDEwMCxcbiAgICBiYWNrb2ZmICAgICAgICAgOiBiYWNrb2ZmLFxuICAgIGtlZXBfYWxpdmUgICAgICA6IDYwLFxuICAgIHByZXBhcmUgICAgICAgICA6IHRydWUsXG4gICAgZGVidWcgICAgICAgICAgIDogZmFsc2UsXG4gICAgZmV0Y2hfdHlwZXMgICAgIDogdHJ1ZSxcbiAgICBwdWJsaWNhdGlvbnMgICAgOiAnYWxsdGFibGVzJyxcbiAgICB0YXJnZXRfc2Vzc2lvbl9hdHRyczogbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBob3N0ICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGhvc3QpID8gaG9zdCA6IGhvc3Quc3BsaXQoJywnKS5tYXAoeCA9PiB4LnNwbGl0KCc6JylbMF0pLFxuICAgIHBvcnQgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkocG9ydCkgPyBwb3J0IDogaG9zdC5zcGxpdCgnLCcpLm1hcCh4ID0+IHBhcnNlSW50KHguc3BsaXQoJzonKVsxXSB8fCBwb3J0KSksXG4gICAgcGF0aCAgICAgICAgICAgIDogby5wYXRoIHx8IGhvc3QuaW5kZXhPZignLycpID4gLTEgJiYgaG9zdCArICcvLnMuUEdTUUwuJyArIHBvcnQsXG4gICAgZGF0YWJhc2UgICAgICAgIDogby5kYXRhYmFzZSB8fCBvLmRiIHx8ICh1cmwucGF0aG5hbWUgfHwgJycpLnNsaWNlKDEpIHx8IGVudi5QR0RBVEFCQVNFIHx8IHVzZXIsXG4gICAgdXNlciAgICAgICAgICAgIDogdXNlcixcbiAgICBwYXNzICAgICAgICAgICAgOiBvLnBhc3MgfHwgby5wYXNzd29yZCB8fCB1cmwucGFzc3dvcmQgfHwgZW52LlBHUEFTU1dPUkQgfHwgJycsXG4gICAgLi4uT2JqZWN0LmVudHJpZXMoZGVmYXVsdHMpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrLCBkXSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGsgaW4gbyA/IG9ba10gOiBrIGluIHF1ZXJ5XG4gICAgICAgICAgPyAocXVlcnlba10gPT09ICdkaXNhYmxlJyB8fCBxdWVyeVtrXSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogcXVlcnlba10pXG4gICAgICAgICAgOiBlbnZbJ1BHJyArIGsudG9VcHBlckNhc2UoKV0gfHwgZFxuICAgICAgICBhY2Nba10gPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGludHMuaW5jbHVkZXMoaylcbiAgICAgICAgICA/ICt2YWx1ZVxuICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICBjb25uZWN0aW9uICAgICAgOiB7XG4gICAgICBhcHBsaWNhdGlvbl9uYW1lOiAncG9zdGdyZXMuanMnLFxuICAgICAgLi4uby5jb25uZWN0aW9uLFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXMocXVlcnkpLnJlZHVjZSgoYWNjLCBbaywgdl0pID0+IChrIGluIGRlZmF1bHRzIHx8IChhY2Nba10gPSB2KSwgYWNjKSwge30pXG4gICAgfSxcbiAgICB0eXBlcyAgICAgICAgICAgOiBvLnR5cGVzIHx8IHt9LFxuICAgIHRhcmdldF9zZXNzaW9uX2F0dHJzOiB0c2EobywgdXJsLCBlbnYpLFxuICAgIG9ubm90aWNlICAgICAgICA6IG8ub25ub3RpY2UsXG4gICAgb25ub3RpZnkgICAgICAgIDogby5vbm5vdGlmeSxcbiAgICBvbmNsb3NlICAgICAgICAgOiBvLm9uY2xvc2UsXG4gICAgb25wYXJhbWV0ZXIgICAgIDogby5vbnBhcmFtZXRlcixcbiAgICBzb2NrZXQgICAgICAgICAgOiBvLnNvY2tldCxcbiAgICB0cmFuc2Zvcm0gICAgICAgOiBwYXJzZVRyYW5zZm9ybShvLnRyYW5zZm9ybSB8fCB7IHVuZGVmaW5lZDogdW5kZWZpbmVkIH0pLFxuICAgIHBhcmFtZXRlcnMgICAgICA6IHt9LFxuICAgIHNoYXJlZCAgICAgICAgICA6IHsgcmV0cmllczogMCwgdHlwZUFycmF5TWFwOiB7fSB9LFxuICAgIC4uLm1lcmdlVXNlclR5cGVzKG8udHlwZXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gdHNhKG8sIHVybCwgZW52KSB7XG4gIGNvbnN0IHggPSBvLnRhcmdldF9zZXNzaW9uX2F0dHJzIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0YXJnZXRfc2Vzc2lvbl9hdHRycycpIHx8IGVudi5QR1RBUkdFVFNFU1NJT05BVFRSU1xuICBpZiAoIXggfHwgWydyZWFkLXdyaXRlJywgJ3JlYWQtb25seScsICdwcmltYXJ5JywgJ3N0YW5kYnknLCAncHJlZmVyLXN0YW5kYnknXS5pbmNsdWRlcyh4KSlcbiAgICByZXR1cm4geFxuXG4gIHRocm93IG5ldyBFcnJvcigndGFyZ2V0X3Nlc3Npb25fYXR0cnMgJyArIHggKyAnIGlzIG5vdCBzdXBwb3J0ZWQnKVxufVxuXG5mdW5jdGlvbiBiYWNrb2ZmKHJldHJpZXMpIHtcbiAgcmV0dXJuICgwLjUgKyBNYXRoLnJhbmRvbSgpIC8gMikgKiBNYXRoLm1pbigzICoqIHJldHJpZXMgLyAxMDAsIDIwKVxufVxuXG5mdW5jdGlvbiBtYXhfbGlmZXRpbWUoKSB7XG4gIHJldHVybiA2MCAqICgzMCArIE1hdGgucmFuZG9tKCkgKiAzMClcbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0oeCkge1xuICByZXR1cm4ge1xuICAgIHVuZGVmaW5lZDogeC51bmRlZmluZWQsXG4gICAgY29sdW1uOiB7XG4gICAgICBmcm9tOiB0eXBlb2YgeC5jb2x1bW4gPT09ICdmdW5jdGlvbicgPyB4LmNvbHVtbiA6IHguY29sdW1uICYmIHguY29sdW1uLmZyb20sXG4gICAgICB0bzogeC5jb2x1bW4gJiYgeC5jb2x1bW4udG9cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBmcm9tOiB0eXBlb2YgeC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHgudmFsdWUgOiB4LnZhbHVlICYmIHgudmFsdWUuZnJvbSxcbiAgICAgIHRvOiB4LnZhbHVlICYmIHgudmFsdWUudG9cbiAgICB9LFxuICAgIHJvdzoge1xuICAgICAgZnJvbTogdHlwZW9mIHgucm93ID09PSAnZnVuY3Rpb24nID8geC5yb3cgOiB4LnJvdyAmJiB4LnJvdy5mcm9tLFxuICAgICAgdG86IHgucm93ICYmIHgucm93LnRvXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4geyB1cmw6IHsgc2VhcmNoUGFyYW1zOiBuZXcgTWFwKCkgfSB9XG5cbiAgbGV0IGhvc3QgPSB1cmxcbiAgaG9zdCA9IGhvc3Quc2xpY2UoaG9zdC5pbmRleE9mKCc6Ly8nKSArIDMpLnNwbGl0KC9bPy9dLylbMF1cbiAgaG9zdCA9IGRlY29kZVVSSUNvbXBvbmVudChob3N0LnNsaWNlKGhvc3QuaW5kZXhPZignQCcpICsgMSkpXG5cbiAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwucmVwbGFjZShob3N0LCBob3N0LnNwbGl0KCcsJylbMF0pKVxuXG4gIHJldHVybiB7XG4gICAgdXJsOiB7XG4gICAgICB1c2VybmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iai51c2VybmFtZSksXG4gICAgICBwYXNzd29yZDogZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iai5wYXNzd29yZCksXG4gICAgICBob3N0OiB1cmxPYmouaG9zdCxcbiAgICAgIGhvc3RuYW1lOiB1cmxPYmouaG9zdG5hbWUsXG4gICAgICBwb3J0OiB1cmxPYmoucG9ydCxcbiAgICAgIHBhdGhuYW1lOiB1cmxPYmoucGF0aG5hbWUsXG4gICAgICBzZWFyY2hQYXJhbXM6IHVybE9iai5zZWFyY2hQYXJhbXNcbiAgICB9LFxuICAgIG11bHRpaG9zdDogaG9zdC5pbmRleE9mKCcsJykgPiAtMSAmJiBob3N0XG4gIH1cbn1cblxuZnVuY3Rpb24gb3NVc2VybmFtZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb3MudXNlckluZm8oKS51c2VybmFtZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuVVNFUk5BTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUiB8fCBwcm9jZXNzLmVudi5MT0dOQU1FICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/postgres/src/types.js\");\n/* harmony import */ var _connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connection.js */ \"(rsc)/./node_modules/postgres/src/connection.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query.js */ \"(rsc)/./node_modules/postgres/src/query.js\");\n/* harmony import */ var _queue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./queue.js */ \"(rsc)/./node_modules/postgres/src/queue.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/postgres/src/errors.js\");\n/* harmony import */ var _subscribe_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./subscribe.js */ \"(rsc)/./node_modules/postgres/src/subscribe.js\");\n/* harmony import */ var _large_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./large.js */ \"(rsc)/./node_modules/postgres/src/large.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nObject.assign(Postgres, {\n  PostgresError: _errors_js__WEBPACK_IMPORTED_MODULE_6__.PostgresError,\n  toPascal: _types_js__WEBPACK_IMPORTED_MODULE_2__.toPascal,\n  pascal: _types_js__WEBPACK_IMPORTED_MODULE_2__.pascal,\n  toCamel: _types_js__WEBPACK_IMPORTED_MODULE_2__.toCamel,\n  camel: _types_js__WEBPACK_IMPORTED_MODULE_2__.camel,\n  toKebab: _types_js__WEBPACK_IMPORTED_MODULE_2__.toKebab,\n  kebab: _types_js__WEBPACK_IMPORTED_MODULE_2__.kebab,\n  fromPascal: _types_js__WEBPACK_IMPORTED_MODULE_2__.fromPascal,\n  fromCamel: _types_js__WEBPACK_IMPORTED_MODULE_2__.fromCamel,\n  fromKebab: _types_js__WEBPACK_IMPORTED_MODULE_2__.fromKebab,\n  BigInt: {\n    to: 20,\n    from: [20],\n    parse: x => BigInt(x), // eslint-disable-line\n    serialize: x => x.toString()\n  }\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Postgres);\n\nfunction Postgres(a, b) {\n  const options = parseOptions(a, b)\n      , subscribe = options.no_subscribe || (0,_subscribe_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(Postgres, { ...options })\n\n  let ending = false\n\n  const queries = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , connecting = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , reserved = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , closed = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , ended = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , open = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , busy = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , full = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n      , queues = { connecting, reserved, closed, ended, open, busy, full }\n\n  const connections = [...Array(options.max)].map(() => (0,_connection_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options, queues, { onopen, onend, onclose }))\n\n  const sql = Sql(handler)\n\n  Object.assign(sql, {\n    get parameters() { return options.parameters },\n    largeObject: _large_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].bind(null, sql),\n    subscribe,\n    CLOSE: _query_js__WEBPACK_IMPORTED_MODULE_4__.CLOSE,\n    END: _query_js__WEBPACK_IMPORTED_MODULE_4__.CLOSE,\n    PostgresError: _errors_js__WEBPACK_IMPORTED_MODULE_6__.PostgresError,\n    options,\n    reserve,\n    listen,\n    begin,\n    close,\n    end\n  })\n\n  return sql\n\n  function Sql(handler) {\n    handler.debug = options.debug\n\n    Object.entries(options.types).reduce((acc, [name, type]) => {\n      acc[name] = (x) => new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(x, type.to)\n      return acc\n    }, typed)\n\n    Object.assign(sql, {\n      types: typed,\n      typed,\n      unsafe,\n      notify,\n      array,\n      json,\n      file\n    })\n\n    return sql\n\n    function typed(value, type) {\n      return new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(value, type)\n    }\n\n    function sql(strings, ...args) {\n      const query = strings && Array.isArray(strings.raw)\n        ? new _query_js__WEBPACK_IMPORTED_MODULE_4__.Query(strings, args, handler, cancel)\n        : typeof strings === 'string' && !args.length\n          ? new _types_js__WEBPACK_IMPORTED_MODULE_2__.Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings)\n          : new _types_js__WEBPACK_IMPORTED_MODULE_2__.Builder(strings, args)\n      return query\n    }\n\n    function unsafe(string, args = [], options = {}) {\n      arguments.length === 2 && !Array.isArray(args) && (options = args, args = [])\n      const query = new _query_js__WEBPACK_IMPORTED_MODULE_4__.Query([string], args, handler, cancel, {\n        prepare: false,\n        ...options,\n        simple: 'simple' in options ? options.simple : args.length === 0\n      })\n      return query\n    }\n\n    function file(path, args = [], options = {}) {\n      arguments.length === 2 && !Array.isArray(args) && (options = args, args = [])\n      const query = new _query_js__WEBPACK_IMPORTED_MODULE_4__.Query([], args, (query) => {\n        fs__WEBPACK_IMPORTED_MODULE_1__.readFile(path, 'utf8', (err, string) => {\n          if (err)\n            return query.reject(err)\n\n          query.strings = [string]\n          handler(query)\n        })\n      }, cancel, {\n        ...options,\n        simple: 'simple' in options ? options.simple : args.length === 0\n      })\n      return query\n    }\n  }\n\n  async function listen(name, fn, onlisten) {\n    const listener = { fn, onlisten }\n\n    const sql = listen.sql || (listen.sql = Postgres({\n      ...options,\n      max: 1,\n      idle_timeout: null,\n      max_lifetime: null,\n      fetch_types: false,\n      onclose() {\n        Object.entries(listen.channels).forEach(([name, { listeners }]) => {\n          delete listen.channels[name]\n          Promise.all(listeners.map(l => listen(name, l.fn, l.onlisten).catch(() => { /* noop */ })))\n        })\n      },\n      onnotify(c, x) {\n        c in listen.channels && listen.channels[c].listeners.forEach(l => l.fn(x))\n      }\n    }))\n\n    const channels = listen.channels || (listen.channels = {})\n        , exists = name in channels\n\n    if (exists) {\n      channels[name].listeners.push(listener)\n      const result = await channels[name].result\n      listener.onlisten && listener.onlisten()\n      return { state: result.state, unlisten }\n    }\n\n    channels[name] = { result: sql`listen ${\n      sql.unsafe('\"' + name.replace(/\"/g, '\"\"') + '\"')\n    }`, listeners: [listener] }\n    const result = await channels[name].result\n    listener.onlisten && listener.onlisten()\n    return { state: result.state, unlisten }\n\n    async function unlisten() {\n      if (name in channels === false)\n        return\n\n      channels[name].listeners = channels[name].listeners.filter(x => x !== listener)\n      if (channels[name].listeners.length)\n        return\n\n      delete channels[name]\n      return sql`unlisten ${\n        sql.unsafe('\"' + name.replace(/\"/g, '\"\"') + '\"')\n      }`\n    }\n  }\n\n  async function notify(channel, payload) {\n    return await sql`select pg_notify(${ channel }, ${ '' + payload })`\n  }\n\n  async function reserve() {\n    const queue = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n    const c = open.length\n      ? open.shift()\n      : await new Promise(r => {\n        queries.push({ reserve: r })\n        closed.length && connect(closed.shift())\n      })\n\n    move(c, reserved)\n    c.reserved = () => queue.length\n      ? c.execute(queue.shift())\n      : move(c, reserved)\n    c.reserved.release = true\n\n    const sql = Sql(handler)\n    sql.release = () => {\n      c.reserved = null\n      onopen(c)\n    }\n\n    return sql\n\n    function handler(q) {\n      c.queue === full\n        ? queue.push(q)\n        : c.execute(q) || move(c, full)\n    }\n  }\n\n  async function begin(options, fn) {\n    !fn && (fn = options, options = '')\n    const queries = (0,_queue_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])()\n    let savepoints = 0\n      , connection\n      , prepare = null\n\n    try {\n      await sql.unsafe('begin ' + options.replace(/[^a-z ]/ig, ''), [], { onexecute }).execute()\n      return await scope(connection, fn)\n    } catch (error) {\n      throw error\n    }\n\n    async function scope(c, fn, name) {\n      const sql = Sql(handler)\n      sql.savepoint = savepoint\n      sql.prepare = x => prepare = x.replace(/[^a-z0-9$-_. ]/gi)\n      let uncaughtError\n        , result\n\n      name && await sql`savepoint ${ sql(name) }`\n      try {\n        result = await new Promise((resolve, reject) => {\n          const x = fn(sql)\n          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject)\n        })\n\n        if (uncaughtError)\n          throw uncaughtError\n      } catch (e) {\n        await (name\n          ? sql`rollback to ${ sql(name) }`\n          : sql`rollback`\n        )\n        throw e instanceof _errors_js__WEBPACK_IMPORTED_MODULE_6__.PostgresError && e.code === '25P02' && uncaughtError || e\n      }\n\n      if (!name) {\n        prepare\n          ? await sql`prepare transaction '${ sql.unsafe(prepare) }'`\n          : await sql`commit`\n      }\n\n      return result\n\n      function savepoint(name, fn) {\n        if (name && Array.isArray(name.raw))\n          return savepoint(sql => sql.apply(sql, arguments))\n\n        arguments.length === 1 && (fn = name, name = null)\n        return scope(c, fn, 's' + savepoints++ + (name ? '_' + name : ''))\n      }\n\n      function handler(q) {\n        q.catch(e => uncaughtError || (uncaughtError = e))\n        c.queue === full\n          ? queries.push(q)\n          : c.execute(q) || move(c, full)\n      }\n    }\n\n    function onexecute(c) {\n      connection = c\n      move(c, reserved)\n      c.reserved = () => queries.length\n        ? c.execute(queries.shift())\n        : move(c, reserved)\n    }\n  }\n\n  function move(c, queue) {\n    c.queue.remove(c)\n    queue.push(c)\n    c.queue = queue\n    queue === open\n      ? c.idleTimer.start()\n      : c.idleTimer.cancel()\n    return c\n  }\n\n  function json(x) {\n    return new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(x, 3802)\n  }\n\n  function array(x, type) {\n    if (!Array.isArray(x))\n      return array(Array.from(arguments))\n\n    return new _types_js__WEBPACK_IMPORTED_MODULE_2__.Parameter(x, type || (x.length ? (0,_types_js__WEBPACK_IMPORTED_MODULE_2__.inferType)(x) || 25 : 0), options.shared.typeArrayMap)\n  }\n\n  function handler(query) {\n    if (ending)\n      return query.reject(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_ENDED', options, options))\n\n    if (open.length)\n      return go(open.shift(), query)\n\n    if (closed.length)\n      return connect(closed.shift(), query)\n\n    busy.length\n      ? go(busy.shift(), query)\n      : queries.push(query)\n  }\n\n  function go(c, query) {\n    return c.execute(query)\n      ? move(c, busy)\n      : move(c, full)\n  }\n\n  function cancel(query) {\n    return new Promise((resolve, reject) => {\n      query.state\n        ? query.active\n          ? (0,_connection_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options).cancel(query.state, resolve, reject)\n          : query.cancelled = { resolve, reject }\n        : (\n          queries.remove(query),\n          query.cancelled = true,\n          query.reject(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.generic('57014', 'canceling statement due to user request')),\n          resolve()\n        )\n    })\n  }\n\n  async function end({ timeout = null } = {}) {\n    if (ending)\n      return ending\n\n    await 1\n    let timer\n    return ending = Promise.race([\n      new Promise(r => timeout !== null && (timer = setTimeout(destroy, timeout * 1000, r))),\n      Promise.all(connections.map(c => c.end()).concat(\n        listen.sql ? listen.sql.end({ timeout: 0 }) : [],\n        subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []\n      ))\n    ]).then(() => clearTimeout(timer))\n  }\n\n  async function close() {\n    await Promise.all(connections.map(c => c.end()))\n  }\n\n  async function destroy(resolve) {\n    await Promise.all(connections.map(c => c.terminate()))\n    while (queries.length)\n      queries.shift().reject(_errors_js__WEBPACK_IMPORTED_MODULE_6__.Errors.connection('CONNECTION_DESTROYED', options))\n    resolve()\n  }\n\n  function connect(c, query) {\n    move(c, connecting)\n    c.connect(query)\n    return c\n  }\n\n  function onend(c) {\n    move(c, ended)\n  }\n\n  function onopen(c) {\n    if (queries.length === 0)\n      return move(c, open)\n\n    let max = Math.ceil(queries.length / (connecting.length + 1))\n      , ready = true\n\n    while (ready && queries.length && max-- > 0) {\n      const query = queries.shift()\n      if (query.reserve)\n        return query.reserve(c)\n\n      ready = c.execute(query)\n    }\n\n    ready\n      ? move(c, busy)\n      : move(c, full)\n  }\n\n  function onclose(c) {\n    move(c, closed)\n    c.reserved = null\n    options.onclose && options.onclose(c.id)\n    queries.length && connect(c, queries.shift())\n  }\n}\n\nfunction parseOptions(a, b) {\n  if (a && a.shared)\n    return a\n\n  const env = process.env // eslint-disable-line\n      , o = (!a || typeof a === 'string' ? b : a) || {}\n      , { url, multihost } = parseUrl(a)\n      , query = [...url.searchParams].reduce((a, [b, c]) => (a[b] = c, a), {})\n      , host = o.hostname || o.host || multihost || url.hostname || env.PGHOST || 'localhost'\n      , port = o.port || url.port || env.PGPORT || 5432\n      , user = o.user || o.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername()\n\n  o.no_prepare && (o.prepare = false)\n  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode)\n  'timeout' in o && (console.log('The timeout option is deprecated, use idle_timeout instead'), o.idle_timeout = o.timeout) // eslint-disable-line\n\n  const ints = ['idle_timeout', 'connect_timeout', 'max_lifetime', 'max_pipeline', 'backoff', 'keep_alive']\n  const defaults = {\n    max             : 10,\n    ssl             : false,\n    idle_timeout    : null,\n    connect_timeout : 30,\n    max_lifetime    : max_lifetime,\n    max_pipeline    : 100,\n    backoff         : backoff,\n    keep_alive      : 60,\n    prepare         : true,\n    debug           : false,\n    fetch_types     : true,\n    publications    : 'alltables',\n    target_session_attrs: null\n  }\n\n  return {\n    host            : Array.isArray(host) ? host : host.split(',').map(x => x.split(':')[0]),\n    port            : Array.isArray(port) ? port : host.split(',').map(x => parseInt(x.split(':')[1] || port)),\n    path            : o.path || host.indexOf('/') > -1 && host + '/.s.PGSQL.' + port,\n    database        : o.database || o.db || (url.pathname || '').slice(1) || env.PGDATABASE || user,\n    user            : user,\n    pass            : o.pass || o.password || url.password || env.PGPASSWORD || '',\n    ...Object.entries(defaults).reduce(\n      (acc, [k, d]) => {\n        const value = k in o ? o[k] : k in query\n          ? (query[k] === 'disable' || query[k] === 'false' ? false : query[k])\n          : env['PG' + k.toUpperCase()] || d\n        acc[k] = typeof value === 'string' && ints.includes(k)\n          ? +value\n          : value\n        return acc\n      },\n      {}\n    ),\n    connection      : {\n      application_name: 'postgres.js',\n      ...o.connection,\n      ...Object.entries(query).reduce((acc, [k, v]) => (k in defaults || (acc[k] = v), acc), {})\n    },\n    types           : o.types || {},\n    target_session_attrs: tsa(o, url, env),\n    onnotice        : o.onnotice,\n    onnotify        : o.onnotify,\n    onclose         : o.onclose,\n    onparameter     : o.onparameter,\n    socket          : o.socket,\n    transform       : parseTransform(o.transform || { undefined: undefined }),\n    parameters      : {},\n    shared          : { retries: 0, typeArrayMap: {} },\n    ...(0,_types_js__WEBPACK_IMPORTED_MODULE_2__.mergeUserTypes)(o.types)\n  }\n}\n\nfunction tsa(o, url, env) {\n  const x = o.target_session_attrs || url.searchParams.get('target_session_attrs') || env.PGTARGETSESSIONATTRS\n  if (!x || ['read-write', 'read-only', 'primary', 'standby', 'prefer-standby'].includes(x))\n    return x\n\n  throw new Error('target_session_attrs ' + x + ' is not supported')\n}\n\nfunction backoff(retries) {\n  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20)\n}\n\nfunction max_lifetime() {\n  return 60 * (30 + Math.random() * 30)\n}\n\nfunction parseTransform(x) {\n  return {\n    undefined: x.undefined,\n    column: {\n      from: typeof x.column === 'function' ? x.column : x.column && x.column.from,\n      to: x.column && x.column.to\n    },\n    value: {\n      from: typeof x.value === 'function' ? x.value : x.value && x.value.from,\n      to: x.value && x.value.to\n    },\n    row: {\n      from: typeof x.row === 'function' ? x.row : x.row && x.row.from,\n      to: x.row && x.row.to\n    }\n  }\n}\n\nfunction parseUrl(url) {\n  if (!url || typeof url !== 'string')\n    return { url: { searchParams: new Map() } }\n\n  let host = url\n  host = host.slice(host.indexOf('://') + 3).split(/[?/]/)[0]\n  host = decodeURIComponent(host.slice(host.indexOf('@') + 1))\n\n  const urlObj = new URL(url.replace(host, host.split(',')[0]))\n\n  return {\n    url: {\n      username: decodeURIComponent(urlObj.username),\n      password: decodeURIComponent(urlObj.password),\n      host: urlObj.host,\n      hostname: urlObj.hostname,\n      port: urlObj.port,\n      pathname: urlObj.pathname,\n      searchParams: urlObj.searchParams\n    },\n    multihost: host.indexOf(',') > -1 && host\n  }\n}\n\nfunction osUsername() {\n  try {\n    return os__WEBPACK_IMPORTED_MODULE_0__.userInfo().username // eslint-disable-line\n  } catch (_) {\n    return process.env.USERNAME || process.env.USER || process.env.LOGNAME  // eslint-disable-line\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBbUI7QUFDQTs7QUFpQkE7O0FBRXFCO0FBQ0M7QUFDWDtBQUNxQjtBQUNiO0FBQ0Y7O0FBRXBDO0FBQ0EsZUFBZTtBQUNmLFVBQVU7QUFDVixRQUFRO0FBQ1IsU0FBUztBQUNULE9BQU87QUFDUCxTQUFTO0FBQ1QsT0FBTztBQUNQLFlBQVk7QUFDWixXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsUUFBUTs7QUFFdkI7QUFDQTtBQUNBLDRDQUE0Qyx5REFBUyxhQUFhLFlBQVk7O0FBRTlFOztBQUVBLGtCQUFrQixxREFBSztBQUN2QixxQkFBcUIscURBQUs7QUFDMUIsbUJBQW1CLHFEQUFLO0FBQ3hCLGlCQUFpQixxREFBSztBQUN0QixnQkFBZ0IscURBQUs7QUFDckIsZUFBZSxxREFBSztBQUNwQixlQUFlLHFEQUFLO0FBQ3BCLGVBQWUscURBQUs7QUFDcEIsbUJBQW1COztBQUVuQix3REFBd0QsMERBQVUsb0JBQW9CLHdCQUF3Qjs7QUFFOUc7O0FBRUE7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xELGlCQUFpQixpREFBVztBQUM1QjtBQUNBLFNBQVM7QUFDVCxTQUFTLDRDQUFLO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnREFBUztBQUN0QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxpQkFBaUIsZ0RBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsNENBQUs7QUFDbkI7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUIsZ0JBQWdCLDhDQUFPO0FBQ3ZCO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0Esd0JBQXdCLDRDQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBLHdCQUF3Qiw0Q0FBSztBQUM3QixRQUFRLHdDQUFXO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQSxzRkFBc0YsWUFBWTtBQUNsRyxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVMsS0FBSyxjQUFjO0FBQ3JFOztBQUVBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscURBQUs7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLFdBQVc7QUFDckY7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0EsMkJBQTJCLHFEQUFhO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMscUJBQXFCO0FBQ25FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0RBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsZ0RBQVMsd0JBQXdCLG9EQUFTO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQU07O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBVTtBQUN0QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsdUJBQXVCLGlCQUFpQixJQUFJO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xELDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhDQUFNO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0YsS0FBSztBQUNMLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsc0JBQXNCO0FBQzVFLHdCQUF3QjtBQUN4Qix3QkFBd0IsOEJBQThCO0FBQ3RELE9BQU8seURBQWM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsd0NBQVc7QUFDdEIsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29uZWNhcmQvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2luZGV4LmpzPzkxMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG9zIGZyb20gJ29zJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuXG5pbXBvcnQge1xuICBtZXJnZVVzZXJUeXBlcyxcbiAgaW5mZXJUeXBlLFxuICBQYXJhbWV0ZXIsXG4gIElkZW50aWZpZXIsXG4gIEJ1aWxkZXIsXG4gIHRvUGFzY2FsLFxuICBwYXNjYWwsXG4gIHRvQ2FtZWwsXG4gIGNhbWVsLFxuICB0b0tlYmFiLFxuICBrZWJhYixcbiAgZnJvbVBhc2NhbCxcbiAgZnJvbUNhbWVsLFxuICBmcm9tS2ViYWJcbn0gZnJvbSAnLi90eXBlcy5qcydcblxuaW1wb3J0IENvbm5lY3Rpb24gZnJvbSAnLi9jb25uZWN0aW9uLmpzJ1xuaW1wb3J0IHsgUXVlcnksIENMT1NFIH0gZnJvbSAnLi9xdWVyeS5qcydcbmltcG9ydCBRdWV1ZSBmcm9tICcuL3F1ZXVlLmpzJ1xuaW1wb3J0IHsgRXJyb3JzLCBQb3N0Z3Jlc0Vycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnXG5pbXBvcnQgU3Vic2NyaWJlIGZyb20gJy4vc3Vic2NyaWJlLmpzJ1xuaW1wb3J0IGxhcmdlT2JqZWN0IGZyb20gJy4vbGFyZ2UuanMnXG5cbk9iamVjdC5hc3NpZ24oUG9zdGdyZXMsIHtcbiAgUG9zdGdyZXNFcnJvcixcbiAgdG9QYXNjYWwsXG4gIHBhc2NhbCxcbiAgdG9DYW1lbCxcbiAgY2FtZWwsXG4gIHRvS2ViYWIsXG4gIGtlYmFiLFxuICBmcm9tUGFzY2FsLFxuICBmcm9tQ2FtZWwsXG4gIGZyb21LZWJhYixcbiAgQmlnSW50OiB7XG4gICAgdG86IDIwLFxuICAgIGZyb206IFsyMF0sXG4gICAgcGFyc2U6IHggPT4gQmlnSW50KHgpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgc2VyaWFsaXplOiB4ID0+IHgudG9TdHJpbmcoKVxuICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBQb3N0Z3Jlc1xuXG5mdW5jdGlvbiBQb3N0Z3JlcyhhLCBiKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMoYSwgYilcbiAgICAgICwgc3Vic2NyaWJlID0gb3B0aW9ucy5ub19zdWJzY3JpYmUgfHwgU3Vic2NyaWJlKFBvc3RncmVzLCB7IC4uLm9wdGlvbnMgfSlcblxuICBsZXQgZW5kaW5nID0gZmFsc2VcblxuICBjb25zdCBxdWVyaWVzID0gUXVldWUoKVxuICAgICAgLCBjb25uZWN0aW5nID0gUXVldWUoKVxuICAgICAgLCByZXNlcnZlZCA9IFF1ZXVlKClcbiAgICAgICwgY2xvc2VkID0gUXVldWUoKVxuICAgICAgLCBlbmRlZCA9IFF1ZXVlKClcbiAgICAgICwgb3BlbiA9IFF1ZXVlKClcbiAgICAgICwgYnVzeSA9IFF1ZXVlKClcbiAgICAgICwgZnVsbCA9IFF1ZXVlKClcbiAgICAgICwgcXVldWVzID0geyBjb25uZWN0aW5nLCByZXNlcnZlZCwgY2xvc2VkLCBlbmRlZCwgb3BlbiwgYnVzeSwgZnVsbCB9XG5cbiAgY29uc3QgY29ubmVjdGlvbnMgPSBbLi4uQXJyYXkob3B0aW9ucy5tYXgpXS5tYXAoKCkgPT4gQ29ubmVjdGlvbihvcHRpb25zLCBxdWV1ZXMsIHsgb25vcGVuLCBvbmVuZCwgb25jbG9zZSB9KSlcblxuICBjb25zdCBzcWwgPSBTcWwoaGFuZGxlcilcblxuICBPYmplY3QuYXNzaWduKHNxbCwge1xuICAgIGdldCBwYXJhbWV0ZXJzKCkgeyByZXR1cm4gb3B0aW9ucy5wYXJhbWV0ZXJzIH0sXG4gICAgbGFyZ2VPYmplY3Q6IGxhcmdlT2JqZWN0LmJpbmQobnVsbCwgc3FsKSxcbiAgICBzdWJzY3JpYmUsXG4gICAgQ0xPU0UsXG4gICAgRU5EOiBDTE9TRSxcbiAgICBQb3N0Z3Jlc0Vycm9yLFxuICAgIG9wdGlvbnMsXG4gICAgcmVzZXJ2ZSxcbiAgICBsaXN0ZW4sXG4gICAgYmVnaW4sXG4gICAgY2xvc2UsXG4gICAgZW5kXG4gIH0pXG5cbiAgcmV0dXJuIHNxbFxuXG4gIGZ1bmN0aW9uIFNxbChoYW5kbGVyKSB7XG4gICAgaGFuZGxlci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWdcblxuICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudHlwZXMpLnJlZHVjZSgoYWNjLCBbbmFtZSwgdHlwZV0pID0+IHtcbiAgICAgIGFjY1tuYW1lXSA9ICh4KSA9PiBuZXcgUGFyYW1ldGVyKHgsIHR5cGUudG8pXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwgdHlwZWQpXG5cbiAgICBPYmplY3QuYXNzaWduKHNxbCwge1xuICAgICAgdHlwZXM6IHR5cGVkLFxuICAgICAgdHlwZWQsXG4gICAgICB1bnNhZmUsXG4gICAgICBub3RpZnksXG4gICAgICBhcnJheSxcbiAgICAgIGpzb24sXG4gICAgICBmaWxlXG4gICAgfSlcblxuICAgIHJldHVybiBzcWxcblxuICAgIGZ1bmN0aW9uIHR5cGVkKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gbmV3IFBhcmFtZXRlcih2YWx1ZSwgdHlwZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcWwoc3RyaW5ncywgLi4uYXJncykge1xuICAgICAgY29uc3QgcXVlcnkgPSBzdHJpbmdzICYmIEFycmF5LmlzQXJyYXkoc3RyaW5ncy5yYXcpXG4gICAgICAgID8gbmV3IFF1ZXJ5KHN0cmluZ3MsIGFyZ3MsIGhhbmRsZXIsIGNhbmNlbClcbiAgICAgICAgOiB0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycgJiYgIWFyZ3MubGVuZ3RoXG4gICAgICAgICAgPyBuZXcgSWRlbnRpZmllcihvcHRpb25zLnRyYW5zZm9ybS5jb2x1bW4udG8gPyBvcHRpb25zLnRyYW5zZm9ybS5jb2x1bW4udG8oc3RyaW5ncykgOiBzdHJpbmdzKVxuICAgICAgICAgIDogbmV3IEJ1aWxkZXIoc3RyaW5ncywgYXJncylcbiAgICAgIHJldHVybiBxdWVyeVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuc2FmZShzdHJpbmcsIGFyZ3MgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFBcnJheS5pc0FycmF5KGFyZ3MpICYmIChvcHRpb25zID0gYXJncywgYXJncyA9IFtdKVxuICAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoW3N0cmluZ10sIGFyZ3MsIGhhbmRsZXIsIGNhbmNlbCwge1xuICAgICAgICBwcmVwYXJlOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2ltcGxlOiAnc2ltcGxlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zaW1wbGUgOiBhcmdzLmxlbmd0aCA9PT0gMFxuICAgICAgfSlcbiAgICAgIHJldHVybiBxdWVyeVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGUocGF0aCwgYXJncyA9IFtdLCBvcHRpb25zID0ge30pIHtcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIUFycmF5LmlzQXJyYXkoYXJncykgJiYgKG9wdGlvbnMgPSBhcmdzLCBhcmdzID0gW10pXG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeShbXSwgYXJncywgKHF1ZXJ5KSA9PiB7XG4gICAgICAgIGZzLnJlYWRGaWxlKHBhdGgsICd1dGY4JywgKGVyciwgc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5yZWplY3QoZXJyKVxuXG4gICAgICAgICAgcXVlcnkuc3RyaW5ncyA9IFtzdHJpbmddXG4gICAgICAgICAgaGFuZGxlcihxdWVyeSlcbiAgICAgICAgfSlcbiAgICAgIH0sIGNhbmNlbCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzaW1wbGU6ICdzaW1wbGUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnNpbXBsZSA6IGFyZ3MubGVuZ3RoID09PSAwXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHF1ZXJ5XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbGlzdGVuKG5hbWUsIGZuLCBvbmxpc3Rlbikge1xuICAgIGNvbnN0IGxpc3RlbmVyID0geyBmbiwgb25saXN0ZW4gfVxuXG4gICAgY29uc3Qgc3FsID0gbGlzdGVuLnNxbCB8fCAobGlzdGVuLnNxbCA9IFBvc3RncmVzKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBtYXg6IDEsXG4gICAgICBpZGxlX3RpbWVvdXQ6IG51bGwsXG4gICAgICBtYXhfbGlmZXRpbWU6IG51bGwsXG4gICAgICBmZXRjaF90eXBlczogZmFsc2UsXG4gICAgICBvbmNsb3NlKCkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhsaXN0ZW4uY2hhbm5lbHMpLmZvckVhY2goKFtuYW1lLCB7IGxpc3RlbmVycyB9XSkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW4uY2hhbm5lbHNbbmFtZV1cbiAgICAgICAgICBQcm9taXNlLmFsbChsaXN0ZW5lcnMubWFwKGwgPT4gbGlzdGVuKG5hbWUsIGwuZm4sIGwub25saXN0ZW4pLmNhdGNoKCgpID0+IHsgLyogbm9vcCAqLyB9KSkpXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgb25ub3RpZnkoYywgeCkge1xuICAgICAgICBjIGluIGxpc3Rlbi5jaGFubmVscyAmJiBsaXN0ZW4uY2hhbm5lbHNbY10ubGlzdGVuZXJzLmZvckVhY2gobCA9PiBsLmZuKHgpKVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgY29uc3QgY2hhbm5lbHMgPSBsaXN0ZW4uY2hhbm5lbHMgfHwgKGxpc3Rlbi5jaGFubmVscyA9IHt9KVxuICAgICAgICAsIGV4aXN0cyA9IG5hbWUgaW4gY2hhbm5lbHNcblxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGNoYW5uZWxzW25hbWVdLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhbm5lbHNbbmFtZV0ucmVzdWx0XG4gICAgICBsaXN0ZW5lci5vbmxpc3RlbiAmJiBsaXN0ZW5lci5vbmxpc3RlbigpXG4gICAgICByZXR1cm4geyBzdGF0ZTogcmVzdWx0LnN0YXRlLCB1bmxpc3RlbiB9XG4gICAgfVxuXG4gICAgY2hhbm5lbHNbbmFtZV0gPSB7IHJlc3VsdDogc3FsYGxpc3RlbiAke1xuICAgICAgc3FsLnVuc2FmZSgnXCInICsgbmFtZS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpICsgJ1wiJylcbiAgICB9YCwgbGlzdGVuZXJzOiBbbGlzdGVuZXJdIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFubmVsc1tuYW1lXS5yZXN1bHRcbiAgICBsaXN0ZW5lci5vbmxpc3RlbiAmJiBsaXN0ZW5lci5vbmxpc3RlbigpXG4gICAgcmV0dXJuIHsgc3RhdGU6IHJlc3VsdC5zdGF0ZSwgdW5saXN0ZW4gfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gdW5saXN0ZW4oKSB7XG4gICAgICBpZiAobmFtZSBpbiBjaGFubmVscyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBjaGFubmVsc1tuYW1lXS5saXN0ZW5lcnMgPSBjaGFubmVsc1tuYW1lXS5saXN0ZW5lcnMuZmlsdGVyKHggPT4geCAhPT0gbGlzdGVuZXIpXG4gICAgICBpZiAoY2hhbm5lbHNbbmFtZV0ubGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGRlbGV0ZSBjaGFubmVsc1tuYW1lXVxuICAgICAgcmV0dXJuIHNxbGB1bmxpc3RlbiAke1xuICAgICAgICBzcWwudW5zYWZlKCdcIicgKyBuYW1lLnJlcGxhY2UoL1wiL2csICdcIlwiJykgKyAnXCInKVxuICAgICAgfWBcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBub3RpZnkoY2hhbm5lbCwgcGF5bG9hZCkge1xuICAgIHJldHVybiBhd2FpdCBzcWxgc2VsZWN0IHBnX25vdGlmeSgkeyBjaGFubmVsIH0sICR7ICcnICsgcGF5bG9hZCB9KWBcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHJlc2VydmUoKSB7XG4gICAgY29uc3QgcXVldWUgPSBRdWV1ZSgpXG4gICAgY29uc3QgYyA9IG9wZW4ubGVuZ3RoXG4gICAgICA/IG9wZW4uc2hpZnQoKVxuICAgICAgOiBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHtcbiAgICAgICAgcXVlcmllcy5wdXNoKHsgcmVzZXJ2ZTogciB9KVxuICAgICAgICBjbG9zZWQubGVuZ3RoICYmIGNvbm5lY3QoY2xvc2VkLnNoaWZ0KCkpXG4gICAgICB9KVxuXG4gICAgbW92ZShjLCByZXNlcnZlZClcbiAgICBjLnJlc2VydmVkID0gKCkgPT4gcXVldWUubGVuZ3RoXG4gICAgICA/IGMuZXhlY3V0ZShxdWV1ZS5zaGlmdCgpKVxuICAgICAgOiBtb3ZlKGMsIHJlc2VydmVkKVxuICAgIGMucmVzZXJ2ZWQucmVsZWFzZSA9IHRydWVcblxuICAgIGNvbnN0IHNxbCA9IFNxbChoYW5kbGVyKVxuICAgIHNxbC5yZWxlYXNlID0gKCkgPT4ge1xuICAgICAgYy5yZXNlcnZlZCA9IG51bGxcbiAgICAgIG9ub3BlbihjKVxuICAgIH1cblxuICAgIHJldHVybiBzcWxcblxuICAgIGZ1bmN0aW9uIGhhbmRsZXIocSkge1xuICAgICAgYy5xdWV1ZSA9PT0gZnVsbFxuICAgICAgICA/IHF1ZXVlLnB1c2gocSlcbiAgICAgICAgOiBjLmV4ZWN1dGUocSkgfHwgbW92ZShjLCBmdWxsKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGJlZ2luKG9wdGlvbnMsIGZuKSB7XG4gICAgIWZuICYmIChmbiA9IG9wdGlvbnMsIG9wdGlvbnMgPSAnJylcbiAgICBjb25zdCBxdWVyaWVzID0gUXVldWUoKVxuICAgIGxldCBzYXZlcG9pbnRzID0gMFxuICAgICAgLCBjb25uZWN0aW9uXG4gICAgICAsIHByZXBhcmUgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3FsLnVuc2FmZSgnYmVnaW4gJyArIG9wdGlvbnMucmVwbGFjZSgvW15hLXogXS9pZywgJycpLCBbXSwgeyBvbmV4ZWN1dGUgfSkuZXhlY3V0ZSgpXG4gICAgICByZXR1cm4gYXdhaXQgc2NvcGUoY29ubmVjdGlvbiwgZm4pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2NvcGUoYywgZm4sIG5hbWUpIHtcbiAgICAgIGNvbnN0IHNxbCA9IFNxbChoYW5kbGVyKVxuICAgICAgc3FsLnNhdmVwb2ludCA9IHNhdmVwb2ludFxuICAgICAgc3FsLnByZXBhcmUgPSB4ID0+IHByZXBhcmUgPSB4LnJlcGxhY2UoL1teYS16MC05JC1fLiBdL2dpKVxuICAgICAgbGV0IHVuY2F1Z2h0RXJyb3JcbiAgICAgICAgLCByZXN1bHRcblxuICAgICAgbmFtZSAmJiBhd2FpdCBzcWxgc2F2ZXBvaW50ICR7IHNxbChuYW1lKSB9YFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHggPSBmbihzcWwpXG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKEFycmF5LmlzQXJyYXkoeCkgPyBQcm9taXNlLmFsbCh4KSA6IHgpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmICh1bmNhdWdodEVycm9yKVxuICAgICAgICAgIHRocm93IHVuY2F1Z2h0RXJyb3JcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXdhaXQgKG5hbWVcbiAgICAgICAgICA/IHNxbGByb2xsYmFjayB0byAkeyBzcWwobmFtZSkgfWBcbiAgICAgICAgICA6IHNxbGByb2xsYmFja2BcbiAgICAgICAgKVxuICAgICAgICB0aHJvdyBlIGluc3RhbmNlb2YgUG9zdGdyZXNFcnJvciAmJiBlLmNvZGUgPT09ICcyNVAwMicgJiYgdW5jYXVnaHRFcnJvciB8fCBlXG4gICAgICB9XG5cbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBwcmVwYXJlXG4gICAgICAgICAgPyBhd2FpdCBzcWxgcHJlcGFyZSB0cmFuc2FjdGlvbiAnJHsgc3FsLnVuc2FmZShwcmVwYXJlKSB9J2BcbiAgICAgICAgICA6IGF3YWl0IHNxbGBjb21taXRgXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcblxuICAgICAgZnVuY3Rpb24gc2F2ZXBvaW50KG5hbWUsIGZuKSB7XG4gICAgICAgIGlmIChuYW1lICYmIEFycmF5LmlzQXJyYXkobmFtZS5yYXcpKVxuICAgICAgICAgIHJldHVybiBzYXZlcG9pbnQoc3FsID0+IHNxbC5hcHBseShzcWwsIGFyZ3VtZW50cykpXG5cbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiAoZm4gPSBuYW1lLCBuYW1lID0gbnVsbClcbiAgICAgICAgcmV0dXJuIHNjb3BlKGMsIGZuLCAncycgKyBzYXZlcG9pbnRzKysgKyAobmFtZSA/ICdfJyArIG5hbWUgOiAnJykpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIocSkge1xuICAgICAgICBxLmNhdGNoKGUgPT4gdW5jYXVnaHRFcnJvciB8fCAodW5jYXVnaHRFcnJvciA9IGUpKVxuICAgICAgICBjLnF1ZXVlID09PSBmdWxsXG4gICAgICAgICAgPyBxdWVyaWVzLnB1c2gocSlcbiAgICAgICAgICA6IGMuZXhlY3V0ZShxKSB8fCBtb3ZlKGMsIGZ1bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25leGVjdXRlKGMpIHtcbiAgICAgIGNvbm5lY3Rpb24gPSBjXG4gICAgICBtb3ZlKGMsIHJlc2VydmVkKVxuICAgICAgYy5yZXNlcnZlZCA9ICgpID0+IHF1ZXJpZXMubGVuZ3RoXG4gICAgICAgID8gYy5leGVjdXRlKHF1ZXJpZXMuc2hpZnQoKSlcbiAgICAgICAgOiBtb3ZlKGMsIHJlc2VydmVkKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmUoYywgcXVldWUpIHtcbiAgICBjLnF1ZXVlLnJlbW92ZShjKVxuICAgIHF1ZXVlLnB1c2goYylcbiAgICBjLnF1ZXVlID0gcXVldWVcbiAgICBxdWV1ZSA9PT0gb3BlblxuICAgICAgPyBjLmlkbGVUaW1lci5zdGFydCgpXG4gICAgICA6IGMuaWRsZVRpbWVyLmNhbmNlbCgpXG4gICAgcmV0dXJuIGNcbiAgfVxuXG4gIGZ1bmN0aW9uIGpzb24oeCkge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyKHgsIDM4MDIpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheSh4LCB0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHgpKVxuICAgICAgcmV0dXJuIGFycmF5KEFycmF5LmZyb20oYXJndW1lbnRzKSlcblxuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyKHgsIHR5cGUgfHwgKHgubGVuZ3RoID8gaW5mZXJUeXBlKHgpIHx8IDI1IDogMCksIG9wdGlvbnMuc2hhcmVkLnR5cGVBcnJheU1hcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZXIocXVlcnkpIHtcbiAgICBpZiAoZW5kaW5nKVxuICAgICAgcmV0dXJuIHF1ZXJ5LnJlamVjdChFcnJvcnMuY29ubmVjdGlvbignQ09OTkVDVElPTl9FTkRFRCcsIG9wdGlvbnMsIG9wdGlvbnMpKVxuXG4gICAgaWYgKG9wZW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIGdvKG9wZW4uc2hpZnQoKSwgcXVlcnkpXG5cbiAgICBpZiAoY2xvc2VkLmxlbmd0aClcbiAgICAgIHJldHVybiBjb25uZWN0KGNsb3NlZC5zaGlmdCgpLCBxdWVyeSlcblxuICAgIGJ1c3kubGVuZ3RoXG4gICAgICA/IGdvKGJ1c3kuc2hpZnQoKSwgcXVlcnkpXG4gICAgICA6IHF1ZXJpZXMucHVzaChxdWVyeSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIGMuZXhlY3V0ZShxdWVyeSlcbiAgICAgID8gbW92ZShjLCBidXN5KVxuICAgICAgOiBtb3ZlKGMsIGZ1bGwpXG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwocXVlcnkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcXVlcnkuc3RhdGVcbiAgICAgICAgPyBxdWVyeS5hY3RpdmVcbiAgICAgICAgICA/IENvbm5lY3Rpb24ob3B0aW9ucykuY2FuY2VsKHF1ZXJ5LnN0YXRlLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgICAgOiBxdWVyeS5jYW5jZWxsZWQgPSB7IHJlc29sdmUsIHJlamVjdCB9XG4gICAgICAgIDogKFxuICAgICAgICAgIHF1ZXJpZXMucmVtb3ZlKHF1ZXJ5KSxcbiAgICAgICAgICBxdWVyeS5jYW5jZWxsZWQgPSB0cnVlLFxuICAgICAgICAgIHF1ZXJ5LnJlamVjdChFcnJvcnMuZ2VuZXJpYygnNTcwMTQnLCAnY2FuY2VsaW5nIHN0YXRlbWVudCBkdWUgdG8gdXNlciByZXF1ZXN0JykpLFxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICApXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGVuZCh7IHRpbWVvdXQgPSBudWxsIH0gPSB7fSkge1xuICAgIGlmIChlbmRpbmcpXG4gICAgICByZXR1cm4gZW5kaW5nXG5cbiAgICBhd2FpdCAxXG4gICAgbGV0IHRpbWVyXG4gICAgcmV0dXJuIGVuZGluZyA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZShyID0+IHRpbWVvdXQgIT09IG51bGwgJiYgKHRpbWVyID0gc2V0VGltZW91dChkZXN0cm95LCB0aW1lb3V0ICogMTAwMCwgcikpKSxcbiAgICAgIFByb21pc2UuYWxsKGNvbm5lY3Rpb25zLm1hcChjID0+IGMuZW5kKCkpLmNvbmNhdChcbiAgICAgICAgbGlzdGVuLnNxbCA/IGxpc3Rlbi5zcWwuZW5kKHsgdGltZW91dDogMCB9KSA6IFtdLFxuICAgICAgICBzdWJzY3JpYmUuc3FsID8gc3Vic2NyaWJlLnNxbC5lbmQoeyB0aW1lb3V0OiAwIH0pIDogW11cbiAgICAgICkpXG4gICAgXSkudGhlbigoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpKVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY29ubmVjdGlvbnMubWFwKGMgPT4gYy5lbmQoKSkpXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBkZXN0cm95KHJlc29sdmUpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChjb25uZWN0aW9ucy5tYXAoYyA9PiBjLnRlcm1pbmF0ZSgpKSlcbiAgICB3aGlsZSAocXVlcmllcy5sZW5ndGgpXG4gICAgICBxdWVyaWVzLnNoaWZ0KCkucmVqZWN0KEVycm9ycy5jb25uZWN0aW9uKCdDT05ORUNUSU9OX0RFU1RST1lFRCcsIG9wdGlvbnMpKVxuICAgIHJlc29sdmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gY29ubmVjdChjLCBxdWVyeSkge1xuICAgIG1vdmUoYywgY29ubmVjdGluZylcbiAgICBjLmNvbm5lY3QocXVlcnkpXG4gICAgcmV0dXJuIGNcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKGMpIHtcbiAgICBtb3ZlKGMsIGVuZGVkKVxuICB9XG5cbiAgZnVuY3Rpb24gb25vcGVuKGMpIHtcbiAgICBpZiAocXVlcmllcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbW92ZShjLCBvcGVuKVxuXG4gICAgbGV0IG1heCA9IE1hdGguY2VpbChxdWVyaWVzLmxlbmd0aCAvIChjb25uZWN0aW5nLmxlbmd0aCArIDEpKVxuICAgICAgLCByZWFkeSA9IHRydWVcblxuICAgIHdoaWxlIChyZWFkeSAmJiBxdWVyaWVzLmxlbmd0aCAmJiBtYXgtLSA+IDApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcmllcy5zaGlmdCgpXG4gICAgICBpZiAocXVlcnkucmVzZXJ2ZSlcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnJlc2VydmUoYylcblxuICAgICAgcmVhZHkgPSBjLmV4ZWN1dGUocXVlcnkpXG4gICAgfVxuXG4gICAgcmVhZHlcbiAgICAgID8gbW92ZShjLCBidXN5KVxuICAgICAgOiBtb3ZlKGMsIGZ1bGwpXG4gIH1cblxuICBmdW5jdGlvbiBvbmNsb3NlKGMpIHtcbiAgICBtb3ZlKGMsIGNsb3NlZClcbiAgICBjLnJlc2VydmVkID0gbnVsbFxuICAgIG9wdGlvbnMub25jbG9zZSAmJiBvcHRpb25zLm9uY2xvc2UoYy5pZClcbiAgICBxdWVyaWVzLmxlbmd0aCAmJiBjb25uZWN0KGMsIHF1ZXJpZXMuc2hpZnQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoYSwgYikge1xuICBpZiAoYSAmJiBhLnNoYXJlZClcbiAgICByZXR1cm4gYVxuXG4gIGNvbnN0IGVudiA9IHByb2Nlc3MuZW52IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICwgbyA9ICghYSB8fCB0eXBlb2YgYSA9PT0gJ3N0cmluZycgPyBiIDogYSkgfHwge31cbiAgICAgICwgeyB1cmwsIG11bHRpaG9zdCB9ID0gcGFyc2VVcmwoYSlcbiAgICAgICwgcXVlcnkgPSBbLi4udXJsLnNlYXJjaFBhcmFtc10ucmVkdWNlKChhLCBbYiwgY10pID0+IChhW2JdID0gYywgYSksIHt9KVxuICAgICAgLCBob3N0ID0gby5ob3N0bmFtZSB8fCBvLmhvc3QgfHwgbXVsdGlob3N0IHx8IHVybC5ob3N0bmFtZSB8fCBlbnYuUEdIT1NUIHx8ICdsb2NhbGhvc3QnXG4gICAgICAsIHBvcnQgPSBvLnBvcnQgfHwgdXJsLnBvcnQgfHwgZW52LlBHUE9SVCB8fCA1NDMyXG4gICAgICAsIHVzZXIgPSBvLnVzZXIgfHwgby51c2VybmFtZSB8fCB1cmwudXNlcm5hbWUgfHwgZW52LlBHVVNFUk5BTUUgfHwgZW52LlBHVVNFUiB8fCBvc1VzZXJuYW1lKClcblxuICBvLm5vX3ByZXBhcmUgJiYgKG8ucHJlcGFyZSA9IGZhbHNlKVxuICBxdWVyeS5zc2xtb2RlICYmIChxdWVyeS5zc2wgPSBxdWVyeS5zc2xtb2RlLCBkZWxldGUgcXVlcnkuc3NsbW9kZSlcbiAgJ3RpbWVvdXQnIGluIG8gJiYgKGNvbnNvbGUubG9nKCdUaGUgdGltZW91dCBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIGlkbGVfdGltZW91dCBpbnN0ZWFkJyksIG8uaWRsZV90aW1lb3V0ID0gby50aW1lb3V0KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgY29uc3QgaW50cyA9IFsnaWRsZV90aW1lb3V0JywgJ2Nvbm5lY3RfdGltZW91dCcsICdtYXhfbGlmZXRpbWUnLCAnbWF4X3BpcGVsaW5lJywgJ2JhY2tvZmYnLCAna2VlcF9hbGl2ZSddXG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIG1heCAgICAgICAgICAgICA6IDEwLFxuICAgIHNzbCAgICAgICAgICAgICA6IGZhbHNlLFxuICAgIGlkbGVfdGltZW91dCAgICA6IG51bGwsXG4gICAgY29ubmVjdF90aW1lb3V0IDogMzAsXG4gICAgbWF4X2xpZmV0aW1lICAgIDogbWF4X2xpZmV0aW1lLFxuICAgIG1heF9waXBlbGluZSAgICA6IDEwMCxcbiAgICBiYWNrb2ZmICAgICAgICAgOiBiYWNrb2ZmLFxuICAgIGtlZXBfYWxpdmUgICAgICA6IDYwLFxuICAgIHByZXBhcmUgICAgICAgICA6IHRydWUsXG4gICAgZGVidWcgICAgICAgICAgIDogZmFsc2UsXG4gICAgZmV0Y2hfdHlwZXMgICAgIDogdHJ1ZSxcbiAgICBwdWJsaWNhdGlvbnMgICAgOiAnYWxsdGFibGVzJyxcbiAgICB0YXJnZXRfc2Vzc2lvbl9hdHRyczogbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBob3N0ICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KGhvc3QpID8gaG9zdCA6IGhvc3Quc3BsaXQoJywnKS5tYXAoeCA9PiB4LnNwbGl0KCc6JylbMF0pLFxuICAgIHBvcnQgICAgICAgICAgICA6IEFycmF5LmlzQXJyYXkocG9ydCkgPyBwb3J0IDogaG9zdC5zcGxpdCgnLCcpLm1hcCh4ID0+IHBhcnNlSW50KHguc3BsaXQoJzonKVsxXSB8fCBwb3J0KSksXG4gICAgcGF0aCAgICAgICAgICAgIDogby5wYXRoIHx8IGhvc3QuaW5kZXhPZignLycpID4gLTEgJiYgaG9zdCArICcvLnMuUEdTUUwuJyArIHBvcnQsXG4gICAgZGF0YWJhc2UgICAgICAgIDogby5kYXRhYmFzZSB8fCBvLmRiIHx8ICh1cmwucGF0aG5hbWUgfHwgJycpLnNsaWNlKDEpIHx8IGVudi5QR0RBVEFCQVNFIHx8IHVzZXIsXG4gICAgdXNlciAgICAgICAgICAgIDogdXNlcixcbiAgICBwYXNzICAgICAgICAgICAgOiBvLnBhc3MgfHwgby5wYXNzd29yZCB8fCB1cmwucGFzc3dvcmQgfHwgZW52LlBHUEFTU1dPUkQgfHwgJycsXG4gICAgLi4uT2JqZWN0LmVudHJpZXMoZGVmYXVsdHMpLnJlZHVjZShcbiAgICAgIChhY2MsIFtrLCBkXSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGsgaW4gbyA/IG9ba10gOiBrIGluIHF1ZXJ5XG4gICAgICAgICAgPyAocXVlcnlba10gPT09ICdkaXNhYmxlJyB8fCBxdWVyeVtrXSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogcXVlcnlba10pXG4gICAgICAgICAgOiBlbnZbJ1BHJyArIGsudG9VcHBlckNhc2UoKV0gfHwgZFxuICAgICAgICBhY2Nba10gPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGludHMuaW5jbHVkZXMoaylcbiAgICAgICAgICA/ICt2YWx1ZVxuICAgICAgICAgIDogdmFsdWVcbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKSxcbiAgICBjb25uZWN0aW9uICAgICAgOiB7XG4gICAgICBhcHBsaWNhdGlvbl9uYW1lOiAncG9zdGdyZXMuanMnLFxuICAgICAgLi4uby5jb25uZWN0aW9uLFxuICAgICAgLi4uT2JqZWN0LmVudHJpZXMocXVlcnkpLnJlZHVjZSgoYWNjLCBbaywgdl0pID0+IChrIGluIGRlZmF1bHRzIHx8IChhY2Nba10gPSB2KSwgYWNjKSwge30pXG4gICAgfSxcbiAgICB0eXBlcyAgICAgICAgICAgOiBvLnR5cGVzIHx8IHt9LFxuICAgIHRhcmdldF9zZXNzaW9uX2F0dHJzOiB0c2EobywgdXJsLCBlbnYpLFxuICAgIG9ubm90aWNlICAgICAgICA6IG8ub25ub3RpY2UsXG4gICAgb25ub3RpZnkgICAgICAgIDogby5vbm5vdGlmeSxcbiAgICBvbmNsb3NlICAgICAgICAgOiBvLm9uY2xvc2UsXG4gICAgb25wYXJhbWV0ZXIgICAgIDogby5vbnBhcmFtZXRlcixcbiAgICBzb2NrZXQgICAgICAgICAgOiBvLnNvY2tldCxcbiAgICB0cmFuc2Zvcm0gICAgICAgOiBwYXJzZVRyYW5zZm9ybShvLnRyYW5zZm9ybSB8fCB7IHVuZGVmaW5lZDogdW5kZWZpbmVkIH0pLFxuICAgIHBhcmFtZXRlcnMgICAgICA6IHt9LFxuICAgIHNoYXJlZCAgICAgICAgICA6IHsgcmV0cmllczogMCwgdHlwZUFycmF5TWFwOiB7fSB9LFxuICAgIC4uLm1lcmdlVXNlclR5cGVzKG8udHlwZXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gdHNhKG8sIHVybCwgZW52KSB7XG4gIGNvbnN0IHggPSBvLnRhcmdldF9zZXNzaW9uX2F0dHJzIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0YXJnZXRfc2Vzc2lvbl9hdHRycycpIHx8IGVudi5QR1RBUkdFVFNFU1NJT05BVFRSU1xuICBpZiAoIXggfHwgWydyZWFkLXdyaXRlJywgJ3JlYWQtb25seScsICdwcmltYXJ5JywgJ3N0YW5kYnknLCAncHJlZmVyLXN0YW5kYnknXS5pbmNsdWRlcyh4KSlcbiAgICByZXR1cm4geFxuXG4gIHRocm93IG5ldyBFcnJvcigndGFyZ2V0X3Nlc3Npb25fYXR0cnMgJyArIHggKyAnIGlzIG5vdCBzdXBwb3J0ZWQnKVxufVxuXG5mdW5jdGlvbiBiYWNrb2ZmKHJldHJpZXMpIHtcbiAgcmV0dXJuICgwLjUgKyBNYXRoLnJhbmRvbSgpIC8gMikgKiBNYXRoLm1pbigzICoqIHJldHJpZXMgLyAxMDAsIDIwKVxufVxuXG5mdW5jdGlvbiBtYXhfbGlmZXRpbWUoKSB7XG4gIHJldHVybiA2MCAqICgzMCArIE1hdGgucmFuZG9tKCkgKiAzMClcbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0oeCkge1xuICByZXR1cm4ge1xuICAgIHVuZGVmaW5lZDogeC51bmRlZmluZWQsXG4gICAgY29sdW1uOiB7XG4gICAgICBmcm9tOiB0eXBlb2YgeC5jb2x1bW4gPT09ICdmdW5jdGlvbicgPyB4LmNvbHVtbiA6IHguY29sdW1uICYmIHguY29sdW1uLmZyb20sXG4gICAgICB0bzogeC5jb2x1bW4gJiYgeC5jb2x1bW4udG9cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBmcm9tOiB0eXBlb2YgeC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHgudmFsdWUgOiB4LnZhbHVlICYmIHgudmFsdWUuZnJvbSxcbiAgICAgIHRvOiB4LnZhbHVlICYmIHgudmFsdWUudG9cbiAgICB9LFxuICAgIHJvdzoge1xuICAgICAgZnJvbTogdHlwZW9mIHgucm93ID09PSAnZnVuY3Rpb24nID8geC5yb3cgOiB4LnJvdyAmJiB4LnJvdy5mcm9tLFxuICAgICAgdG86IHgucm93ICYmIHgucm93LnRvXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4geyB1cmw6IHsgc2VhcmNoUGFyYW1zOiBuZXcgTWFwKCkgfSB9XG5cbiAgbGV0IGhvc3QgPSB1cmxcbiAgaG9zdCA9IGhvc3Quc2xpY2UoaG9zdC5pbmRleE9mKCc6Ly8nKSArIDMpLnNwbGl0KC9bPy9dLylbMF1cbiAgaG9zdCA9IGRlY29kZVVSSUNvbXBvbmVudChob3N0LnNsaWNlKGhvc3QuaW5kZXhPZignQCcpICsgMSkpXG5cbiAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwucmVwbGFjZShob3N0LCBob3N0LnNwbGl0KCcsJylbMF0pKVxuXG4gIHJldHVybiB7XG4gICAgdXJsOiB7XG4gICAgICB1c2VybmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iai51c2VybmFtZSksXG4gICAgICBwYXNzd29yZDogZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iai5wYXNzd29yZCksXG4gICAgICBob3N0OiB1cmxPYmouaG9zdCxcbiAgICAgIGhvc3RuYW1lOiB1cmxPYmouaG9zdG5hbWUsXG4gICAgICBwb3J0OiB1cmxPYmoucG9ydCxcbiAgICAgIHBhdGhuYW1lOiB1cmxPYmoucGF0aG5hbWUsXG4gICAgICBzZWFyY2hQYXJhbXM6IHVybE9iai5zZWFyY2hQYXJhbXNcbiAgICB9LFxuICAgIG11bHRpaG9zdDogaG9zdC5pbmRleE9mKCcsJykgPiAtMSAmJiBob3N0XG4gIH1cbn1cblxuZnVuY3Rpb24gb3NVc2VybmFtZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb3MudXNlckluZm8oKS51c2VybmFtZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuVVNFUk5BTUUgfHwgcHJvY2Vzcy5lbnYuVVNFUiB8fCBwcm9jZXNzLmVudi5MT0dOQU1FICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/large.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/large.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ largeObject)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n\n\nfunction largeObject(sql, oid, mode = 0x00020000 | 0x00040000) {\n  return new Promise(async(resolve, reject) => {\n    await sql.begin(async sql => {\n      let finish\n      !oid && ([{ oid }] = await sql`select lo_creat(-1) as oid`)\n      const [{ fd }] = await sql`select lo_open(${ oid }, ${ mode }) as fd`\n\n      const lo = {\n        writable,\n        readable,\n        close     : () => sql`select lo_close(${ fd })`.then(finish),\n        tell      : () => sql`select lo_tell64(${ fd })`,\n        read      : (x) => sql`select loread(${ fd }, ${ x }) as data`,\n        write     : (x) => sql`select lowrite(${ fd }, ${ x })`,\n        truncate  : (x) => sql`select lo_truncate64(${ fd }, ${ x })`,\n        seek      : (x, whence = 0) => sql`select lo_lseek64(${ fd }, ${ x }, ${ whence })`,\n        size      : () => sql`\n          select\n            lo_lseek64(${ fd }, location, 0) as position,\n            seek.size\n          from (\n            select\n              lo_lseek64($1, 0, 2) as size,\n              tell.location\n            from (select lo_tell64($1) as location) tell\n          ) seek\n        `\n      }\n\n      resolve(lo)\n\n      return new Promise(async r => finish = r)\n\n      async function readable({\n        highWaterMark = 2048 * 8,\n        start = 0,\n        end = Infinity\n      } = {}) {\n        let max = end - start\n        start && await lo.seek(start)\n        return new stream__WEBPACK_IMPORTED_MODULE_0__.Readable({\n          highWaterMark,\n          async read(size) {\n            const l = size > max ? size - max : size\n            max -= size\n            const [{ data }] = await lo.read(l)\n            this.push(data)\n            if (data.length < size)\n              this.push(null)\n          }\n        })\n      }\n\n      async function writable({\n        highWaterMark = 2048 * 8,\n        start = 0\n      } = {}) {\n        start && await lo.seek(start)\n        return new stream__WEBPACK_IMPORTED_MODULE_0__.Writable({\n          highWaterMark,\n          write(chunk, encoding, callback) {\n            lo.write(chunk).then(() => callback(), callback)\n          }\n        })\n      }\n    }).catch(reject)\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvbGFyZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkI7O0FBRVo7QUFDZjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QixlQUFlLElBQUksZ0NBQWdDLEtBQUssS0FBSyxNQUFNOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRCxrREFBa0QsSUFBSTtBQUN0RCxnREFBZ0QsSUFBSSxLQUFLLEdBQUc7QUFDNUQsaURBQWlELElBQUksS0FBSyxHQUFHO0FBQzdELHVEQUF1RCxJQUFJLEtBQUssR0FBRztBQUNuRSxnRUFBZ0UsSUFBSSxLQUFLLEdBQUcsS0FBSyxRQUFRO0FBQ3pGO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQSxtQkFBbUIsNENBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvbGFyZ2UuanM/ZWRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3RyZWFtIGZyb20gJ3N0cmVhbSdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFyZ2VPYmplY3Qoc3FsLCBvaWQsIG1vZGUgPSAweDAwMDIwMDAwIHwgMHgwMDA0MDAwMCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXdhaXQgc3FsLmJlZ2luKGFzeW5jIHNxbCA9PiB7XG4gICAgICBsZXQgZmluaXNoXG4gICAgICAhb2lkICYmIChbeyBvaWQgfV0gPSBhd2FpdCBzcWxgc2VsZWN0IGxvX2NyZWF0KC0xKSBhcyBvaWRgKVxuICAgICAgY29uc3QgW3sgZmQgfV0gPSBhd2FpdCBzcWxgc2VsZWN0IGxvX29wZW4oJHsgb2lkIH0sICR7IG1vZGUgfSkgYXMgZmRgXG5cbiAgICAgIGNvbnN0IGxvID0ge1xuICAgICAgICB3cml0YWJsZSxcbiAgICAgICAgcmVhZGFibGUsXG4gICAgICAgIGNsb3NlICAgICA6ICgpID0+IHNxbGBzZWxlY3QgbG9fY2xvc2UoJHsgZmQgfSlgLnRoZW4oZmluaXNoKSxcbiAgICAgICAgdGVsbCAgICAgIDogKCkgPT4gc3FsYHNlbGVjdCBsb190ZWxsNjQoJHsgZmQgfSlgLFxuICAgICAgICByZWFkICAgICAgOiAoeCkgPT4gc3FsYHNlbGVjdCBsb3JlYWQoJHsgZmQgfSwgJHsgeCB9KSBhcyBkYXRhYCxcbiAgICAgICAgd3JpdGUgICAgIDogKHgpID0+IHNxbGBzZWxlY3QgbG93cml0ZSgkeyBmZCB9LCAkeyB4IH0pYCxcbiAgICAgICAgdHJ1bmNhdGUgIDogKHgpID0+IHNxbGBzZWxlY3QgbG9fdHJ1bmNhdGU2NCgkeyBmZCB9LCAkeyB4IH0pYCxcbiAgICAgICAgc2VlayAgICAgIDogKHgsIHdoZW5jZSA9IDApID0+IHNxbGBzZWxlY3QgbG9fbHNlZWs2NCgkeyBmZCB9LCAkeyB4IH0sICR7IHdoZW5jZSB9KWAsXG4gICAgICAgIHNpemUgICAgICA6ICgpID0+IHNxbGBcbiAgICAgICAgICBzZWxlY3RcbiAgICAgICAgICAgIGxvX2xzZWVrNjQoJHsgZmQgfSwgbG9jYXRpb24sIDApIGFzIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2Vlay5zaXplXG4gICAgICAgICAgZnJvbSAoXG4gICAgICAgICAgICBzZWxlY3RcbiAgICAgICAgICAgICAgbG9fbHNlZWs2NCgkMSwgMCwgMikgYXMgc2l6ZSxcbiAgICAgICAgICAgICAgdGVsbC5sb2NhdGlvblxuICAgICAgICAgICAgZnJvbSAoc2VsZWN0IGxvX3RlbGw2NCgkMSkgYXMgbG9jYXRpb24pIHRlbGxcbiAgICAgICAgICApIHNlZWtcbiAgICAgICAgYFxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGxvKVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgciA9PiBmaW5pc2ggPSByKVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiByZWFkYWJsZSh7XG4gICAgICAgIGhpZ2hXYXRlck1hcmsgPSAyMDQ4ICogOCxcbiAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICBlbmQgPSBJbmZpbml0eVxuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGxldCBtYXggPSBlbmQgLSBzdGFydFxuICAgICAgICBzdGFydCAmJiBhd2FpdCBsby5zZWVrKHN0YXJ0KVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbS5SZWFkYWJsZSh7XG4gICAgICAgICAgaGlnaFdhdGVyTWFyayxcbiAgICAgICAgICBhc3luYyByZWFkKHNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBzaXplID4gbWF4ID8gc2l6ZSAtIG1heCA6IHNpemVcbiAgICAgICAgICAgIG1heCAtPSBzaXplXG4gICAgICAgICAgICBjb25zdCBbeyBkYXRhIH1dID0gYXdhaXQgbG8ucmVhZChsKVxuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCBzaXplKVxuICAgICAgICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRhYmxlKHtcbiAgICAgICAgaGlnaFdhdGVyTWFyayA9IDIwNDggKiA4LFxuICAgICAgICBzdGFydCA9IDBcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBzdGFydCAmJiBhd2FpdCBsby5zZWVrKHN0YXJ0KVxuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbS5Xcml0YWJsZSh7XG4gICAgICAgICAgaGlnaFdhdGVyTWFyayxcbiAgICAgICAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsby53cml0ZShjaHVuaykudGhlbigoKSA9PiBjYWxsYmFjaygpLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSkuY2F0Y2gocmVqZWN0KVxuICB9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/large.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/large.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/large.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ largeObject)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n\n\nfunction largeObject(sql, oid, mode = 0x00020000 | 0x00040000) {\n  return new Promise(async(resolve, reject) => {\n    await sql.begin(async sql => {\n      let finish\n      !oid && ([{ oid }] = await sql`select lo_creat(-1) as oid`)\n      const [{ fd }] = await sql`select lo_open(${ oid }, ${ mode }) as fd`\n\n      const lo = {\n        writable,\n        readable,\n        close     : () => sql`select lo_close(${ fd })`.then(finish),\n        tell      : () => sql`select lo_tell64(${ fd })`,\n        read      : (x) => sql`select loread(${ fd }, ${ x }) as data`,\n        write     : (x) => sql`select lowrite(${ fd }, ${ x })`,\n        truncate  : (x) => sql`select lo_truncate64(${ fd }, ${ x })`,\n        seek      : (x, whence = 0) => sql`select lo_lseek64(${ fd }, ${ x }, ${ whence })`,\n        size      : () => sql`\n          select\n            lo_lseek64(${ fd }, location, 0) as position,\n            seek.size\n          from (\n            select\n              lo_lseek64($1, 0, 2) as size,\n              tell.location\n            from (select lo_tell64($1) as location) tell\n          ) seek\n        `\n      }\n\n      resolve(lo)\n\n      return new Promise(async r => finish = r)\n\n      async function readable({\n        highWaterMark = 2048 * 8,\n        start = 0,\n        end = Infinity\n      } = {}) {\n        let max = end - start\n        start && await lo.seek(start)\n        return new stream__WEBPACK_IMPORTED_MODULE_0__.Readable({\n          highWaterMark,\n          async read(size) {\n            const l = size > max ? size - max : size\n            max -= size\n            const [{ data }] = await lo.read(l)\n            this.push(data)\n            if (data.length < size)\n              this.push(null)\n          }\n        })\n      }\n\n      async function writable({\n        highWaterMark = 2048 * 8,\n        start = 0\n      } = {}) {\n        start && await lo.seek(start)\n        return new stream__WEBPACK_IMPORTED_MODULE_0__.Writable({\n          highWaterMark,\n          write(chunk, encoding, callback) {\n            lo.write(chunk).then(() => callback(), callback)\n          }\n        })\n      }\n    }).catch(reject)\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2xhcmdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJCOztBQUVaO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkIsZUFBZSxJQUFJLGdDQUFnQyxLQUFLLEtBQUssTUFBTTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUk7QUFDckQsa0RBQWtELElBQUk7QUFDdEQsZ0RBQWdELElBQUksS0FBSyxHQUFHO0FBQzVELGlEQUFpRCxJQUFJLEtBQUssR0FBRztBQUM3RCx1REFBdUQsSUFBSSxLQUFLLEdBQUc7QUFDbkUsZ0VBQWdFLElBQUksS0FBSyxHQUFHLEtBQUssUUFBUTtBQUN6RjtBQUNBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0EsbUJBQW1CLDRDQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL29uZWNhcmQvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL2xhcmdlLmpzPzNhOWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0cmVhbSBmcm9tICdzdHJlYW0nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhcmdlT2JqZWN0KHNxbCwgb2lkLCBtb2RlID0gMHgwMDAyMDAwMCB8IDB4MDAwNDAwMDApIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGF3YWl0IHNxbC5iZWdpbihhc3luYyBzcWwgPT4ge1xuICAgICAgbGV0IGZpbmlzaFxuICAgICAgIW9pZCAmJiAoW3sgb2lkIH1dID0gYXdhaXQgc3FsYHNlbGVjdCBsb19jcmVhdCgtMSkgYXMgb2lkYClcbiAgICAgIGNvbnN0IFt7IGZkIH1dID0gYXdhaXQgc3FsYHNlbGVjdCBsb19vcGVuKCR7IG9pZCB9LCAkeyBtb2RlIH0pIGFzIGZkYFxuXG4gICAgICBjb25zdCBsbyA9IHtcbiAgICAgICAgd3JpdGFibGUsXG4gICAgICAgIHJlYWRhYmxlLFxuICAgICAgICBjbG9zZSAgICAgOiAoKSA9PiBzcWxgc2VsZWN0IGxvX2Nsb3NlKCR7IGZkIH0pYC50aGVuKGZpbmlzaCksXG4gICAgICAgIHRlbGwgICAgICA6ICgpID0+IHNxbGBzZWxlY3QgbG9fdGVsbDY0KCR7IGZkIH0pYCxcbiAgICAgICAgcmVhZCAgICAgIDogKHgpID0+IHNxbGBzZWxlY3QgbG9yZWFkKCR7IGZkIH0sICR7IHggfSkgYXMgZGF0YWAsXG4gICAgICAgIHdyaXRlICAgICA6ICh4KSA9PiBzcWxgc2VsZWN0IGxvd3JpdGUoJHsgZmQgfSwgJHsgeCB9KWAsXG4gICAgICAgIHRydW5jYXRlICA6ICh4KSA9PiBzcWxgc2VsZWN0IGxvX3RydW5jYXRlNjQoJHsgZmQgfSwgJHsgeCB9KWAsXG4gICAgICAgIHNlZWsgICAgICA6ICh4LCB3aGVuY2UgPSAwKSA9PiBzcWxgc2VsZWN0IGxvX2xzZWVrNjQoJHsgZmQgfSwgJHsgeCB9LCAkeyB3aGVuY2UgfSlgLFxuICAgICAgICBzaXplICAgICAgOiAoKSA9PiBzcWxgXG4gICAgICAgICAgc2VsZWN0XG4gICAgICAgICAgICBsb19sc2VlazY0KCR7IGZkIH0sIGxvY2F0aW9uLCAwKSBhcyBwb3NpdGlvbixcbiAgICAgICAgICAgIHNlZWsuc2l6ZVxuICAgICAgICAgIGZyb20gKFxuICAgICAgICAgICAgc2VsZWN0XG4gICAgICAgICAgICAgIGxvX2xzZWVrNjQoJDEsIDAsIDIpIGFzIHNpemUsXG4gICAgICAgICAgICAgIHRlbGwubG9jYXRpb25cbiAgICAgICAgICAgIGZyb20gKHNlbGVjdCBsb190ZWxsNjQoJDEpIGFzIGxvY2F0aW9uKSB0ZWxsXG4gICAgICAgICAgKSBzZWVrXG4gICAgICAgIGBcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShsbylcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIHIgPT4gZmluaXNoID0gcilcblxuICAgICAgYXN5bmMgZnVuY3Rpb24gcmVhZGFibGUoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrID0gMjA0OCAqIDgsXG4gICAgICAgIHN0YXJ0ID0gMCxcbiAgICAgICAgZW5kID0gSW5maW5pdHlcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBsZXQgbWF4ID0gZW5kIC0gc3RhcnRcbiAgICAgICAgc3RhcnQgJiYgYXdhaXQgbG8uc2VlayhzdGFydClcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0uUmVhZGFibGUoe1xuICAgICAgICAgIGhpZ2hXYXRlck1hcmssXG4gICAgICAgICAgYXN5bmMgcmVhZChzaXplKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gc2l6ZSA+IG1heCA/IHNpemUgLSBtYXggOiBzaXplXG4gICAgICAgICAgICBtYXggLT0gc2l6ZVxuICAgICAgICAgICAgY29uc3QgW3sgZGF0YSB9XSA9IGF3YWl0IGxvLnJlYWQobClcbiAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiB3cml0YWJsZSh7XG4gICAgICAgIGhpZ2hXYXRlck1hcmsgPSAyMDQ4ICogOCxcbiAgICAgICAgc3RhcnQgPSAwXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgc3RhcnQgJiYgYXdhaXQgbG8uc2VlayhzdGFydClcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0uV3JpdGFibGUoe1xuICAgICAgICAgIGhpZ2hXYXRlck1hcmssXG4gICAgICAgICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbG8ud3JpdGUoY2h1bmspLnRoZW4oKCkgPT4gY2FsbGJhY2soKSwgY2FsbGJhY2spXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pLmNhdGNoKHJlamVjdClcbiAgfSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/large.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/query.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/query.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLOSE: () => (/* binding */ CLOSE),\n/* harmony export */   Query: () => (/* binding */ Query)\n/* harmony export */ });\nconst originCache = new Map()\n    , originStackCache = new Map()\n    , originError = Symbol('OriginError')\n\nconst CLOSE = {}\nclass Query extends Promise {\n  constructor(strings, args, handler, canceller, options = {}) {\n    let resolve\n      , reject\n\n    super((a, b) => {\n      resolve = a\n      reject = b\n    })\n\n    this.tagged = Array.isArray(strings.raw)\n    this.strings = strings\n    this.args = args\n    this.handler = handler\n    this.canceller = canceller\n    this.options = options\n\n    this.state = null\n    this.statement = null\n\n    this.resolve = x => (this.active = false, resolve(x))\n    this.reject = x => (this.active = false, reject(x))\n\n    this.active = false\n    this.cancelled = null\n    this.executed = false\n    this.signature = ''\n\n    this[originError] = this.handler.debug\n      ? new Error()\n      : this.tagged && cachedError(this.strings)\n  }\n\n  get origin() {\n    return (this.handler.debug\n      ? this[originError].stack\n      : this.tagged && originStackCache.has(this.strings)\n        ? originStackCache.get(this.strings)\n        : originStackCache.set(this.strings, this[originError].stack).get(this.strings)\n    ) || ''\n  }\n\n  static get [Symbol.species]() {\n    return Promise\n  }\n\n  cancel() {\n    return this.canceller && (this.canceller(this), this.canceller = null)\n  }\n\n  simple() {\n    this.options.simple = true\n    this.options.prepare = false\n    return this\n  }\n\n  async readable() {\n    this.simple()\n    this.streaming = true\n    return this\n  }\n\n  async writable() {\n    this.simple()\n    this.streaming = true\n    return this\n  }\n\n  cursor(rows = 1, fn) {\n    this.options.simple = false\n    if (typeof rows === 'function') {\n      fn = rows\n      rows = 1\n    }\n\n    this.cursorRows = rows\n\n    if (typeof fn === 'function')\n      return (this.cursorFn = fn, this)\n\n    let prev\n    return {\n      [Symbol.asyncIterator]: () => ({\n        next: () => {\n          if (this.executed && !this.active)\n            return { done: true }\n\n          prev && prev()\n          const promise = new Promise((resolve, reject) => {\n            this.cursorFn = value => {\n              resolve({ value, done: false })\n              return new Promise(r => prev = r)\n            }\n            this.resolve = () => (this.active = false, resolve({ done: true }))\n            this.reject = x => (this.active = false, reject(x))\n          })\n          this.execute()\n          return promise\n        },\n        return() {\n          prev && prev(CLOSE)\n          return { done: true }\n        }\n      })\n    }\n  }\n\n  describe() {\n    this.options.simple = false\n    this.onlyDescribe = this.options.prepare = true\n    return this\n  }\n\n  stream() {\n    throw new Error('.stream has been renamed to .forEach')\n  }\n\n  forEach(fn) {\n    this.forEachFn = fn\n    this.handle()\n    return this\n  }\n\n  raw() {\n    this.isRaw = true\n    return this\n  }\n\n  values() {\n    this.isRaw = 'values'\n    return this\n  }\n\n  async handle() {\n    !this.executed && (this.executed = true) && await 1 && this.handler(this)\n  }\n\n  execute() {\n    this.handle()\n    return this\n  }\n\n  then() {\n    this.handle()\n    return super.then.apply(this, arguments)\n  }\n\n  catch() {\n    this.handle()\n    return super.catch.apply(this, arguments)\n  }\n\n  finally() {\n    this.handle()\n    return super.finally.apply(this, arguments)\n  }\n}\n\nfunction cachedError(xs) {\n  if (originCache.has(xs))\n    return originCache.get(xs)\n\n  const x = Error.stackTraceLimit\n  Error.stackTraceLimit = 4\n  originCache.set(xs, new Error())\n  Error.stackTraceLimit = x\n  return originCache.get(xs)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvcXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTtBQUNQLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsaUVBQWlFLFlBQVk7QUFDN0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvcXVlcnkuanM/OTlmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvcmlnaW5DYWNoZSA9IG5ldyBNYXAoKVxuICAgICwgb3JpZ2luU3RhY2tDYWNoZSA9IG5ldyBNYXAoKVxuICAgICwgb3JpZ2luRXJyb3IgPSBTeW1ib2woJ09yaWdpbkVycm9yJylcblxuZXhwb3J0IGNvbnN0IENMT1NFID0ge31cbmV4cG9ydCBjbGFzcyBRdWVyeSBleHRlbmRzIFByb21pc2Uge1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCBhcmdzLCBoYW5kbGVyLCBjYW5jZWxsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCByZXNvbHZlXG4gICAgICAsIHJlamVjdFxuXG4gICAgc3VwZXIoKGEsIGIpID0+IHtcbiAgICAgIHJlc29sdmUgPSBhXG4gICAgICByZWplY3QgPSBiXG4gICAgfSlcblxuICAgIHRoaXMudGFnZ2VkID0gQXJyYXkuaXNBcnJheShzdHJpbmdzLnJhdylcbiAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzXG4gICAgdGhpcy5hcmdzID0gYXJnc1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmNhbmNlbGxlciA9IGNhbmNlbGxlclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcblxuICAgIHRoaXMuc3RhdGUgPSBudWxsXG4gICAgdGhpcy5zdGF0ZW1lbnQgPSBudWxsXG5cbiAgICB0aGlzLnJlc29sdmUgPSB4ID0+ICh0aGlzLmFjdGl2ZSA9IGZhbHNlLCByZXNvbHZlKHgpKVxuICAgIHRoaXMucmVqZWN0ID0geCA9PiAodGhpcy5hY3RpdmUgPSBmYWxzZSwgcmVqZWN0KHgpKVxuXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMuY2FuY2VsbGVkID0gbnVsbFxuICAgIHRoaXMuZXhlY3V0ZWQgPSBmYWxzZVxuICAgIHRoaXMuc2lnbmF0dXJlID0gJydcblxuICAgIHRoaXNbb3JpZ2luRXJyb3JdID0gdGhpcy5oYW5kbGVyLmRlYnVnXG4gICAgICA/IG5ldyBFcnJvcigpXG4gICAgICA6IHRoaXMudGFnZ2VkICYmIGNhY2hlZEVycm9yKHRoaXMuc3RyaW5ncylcbiAgfVxuXG4gIGdldCBvcmlnaW4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmhhbmRsZXIuZGVidWdcbiAgICAgID8gdGhpc1tvcmlnaW5FcnJvcl0uc3RhY2tcbiAgICAgIDogdGhpcy50YWdnZWQgJiYgb3JpZ2luU3RhY2tDYWNoZS5oYXModGhpcy5zdHJpbmdzKVxuICAgICAgICA/IG9yaWdpblN0YWNrQ2FjaGUuZ2V0KHRoaXMuc3RyaW5ncylcbiAgICAgICAgOiBvcmlnaW5TdGFja0NhY2hlLnNldCh0aGlzLnN0cmluZ3MsIHRoaXNbb3JpZ2luRXJyb3JdLnN0YWNrKS5nZXQodGhpcy5zdHJpbmdzKVxuICAgICkgfHwgJydcbiAgfVxuXG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHJldHVybiB0aGlzLmNhbmNlbGxlciAmJiAodGhpcy5jYW5jZWxsZXIodGhpcyksIHRoaXMuY2FuY2VsbGVyID0gbnVsbClcbiAgfVxuXG4gIHNpbXBsZSgpIHtcbiAgICB0aGlzLm9wdGlvbnMuc2ltcGxlID0gdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5wcmVwYXJlID0gZmFsc2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXN5bmMgcmVhZGFibGUoKSB7XG4gICAgdGhpcy5zaW1wbGUoKVxuICAgIHRoaXMuc3RyZWFtaW5nID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhc3luYyB3cml0YWJsZSgpIHtcbiAgICB0aGlzLnNpbXBsZSgpXG4gICAgdGhpcy5zdHJlYW1pbmcgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGN1cnNvcihyb3dzID0gMSwgZm4pIHtcbiAgICB0aGlzLm9wdGlvbnMuc2ltcGxlID0gZmFsc2VcbiAgICBpZiAodHlwZW9mIHJvd3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuID0gcm93c1xuICAgICAgcm93cyA9IDFcbiAgICB9XG5cbiAgICB0aGlzLmN1cnNvclJvd3MgPSByb3dzXG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0dXJuICh0aGlzLmN1cnNvckZuID0gZm4sIHRoaXMpXG5cbiAgICBsZXQgcHJldlxuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiAoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0ZWQgJiYgIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9XG5cbiAgICAgICAgICBwcmV2ICYmIHByZXYoKVxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvckZuID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6IGZhbHNlIH0pXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyID0+IHByZXYgPSByKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gKCkgPT4gKHRoaXMuYWN0aXZlID0gZmFsc2UsIHJlc29sdmUoeyBkb25lOiB0cnVlIH0pKVxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSB4ID0+ICh0aGlzLmFjdGl2ZSA9IGZhbHNlLCByZWplY3QoeCkpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLmV4ZWN1dGUoKVxuICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIH0sXG4gICAgICAgIHJldHVybigpIHtcbiAgICAgICAgICBwcmV2ICYmIHByZXYoQ0xPU0UpXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZGVzY3JpYmUoKSB7XG4gICAgdGhpcy5vcHRpb25zLnNpbXBsZSA9IGZhbHNlXG4gICAgdGhpcy5vbmx5RGVzY3JpYmUgPSB0aGlzLm9wdGlvbnMucHJlcGFyZSA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignLnN0cmVhbSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mb3JFYWNoJylcbiAgfVxuXG4gIGZvckVhY2goZm4pIHtcbiAgICB0aGlzLmZvckVhY2hGbiA9IGZuXG4gICAgdGhpcy5oYW5kbGUoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByYXcoKSB7XG4gICAgdGhpcy5pc1JhdyA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFsdWVzKCkge1xuICAgIHRoaXMuaXNSYXcgPSAndmFsdWVzJ1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhc3luYyBoYW5kbGUoKSB7XG4gICAgIXRoaXMuZXhlY3V0ZWQgJiYgKHRoaXMuZXhlY3V0ZWQgPSB0cnVlKSAmJiBhd2FpdCAxICYmIHRoaXMuaGFuZGxlcih0aGlzKVxuICB9XG5cbiAgZXhlY3V0ZSgpIHtcbiAgICB0aGlzLmhhbmRsZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoZW4oKSB7XG4gICAgdGhpcy5oYW5kbGUoKVxuICAgIHJldHVybiBzdXBlci50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuXG4gIGNhdGNoKCkge1xuICAgIHRoaXMuaGFuZGxlKClcbiAgICByZXR1cm4gc3VwZXIuY2F0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG5cbiAgZmluYWxseSgpIHtcbiAgICB0aGlzLmhhbmRsZSgpXG4gICAgcmV0dXJuIHN1cGVyLmZpbmFsbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlZEVycm9yKHhzKSB7XG4gIGlmIChvcmlnaW5DYWNoZS5oYXMoeHMpKVxuICAgIHJldHVybiBvcmlnaW5DYWNoZS5nZXQoeHMpXG5cbiAgY29uc3QgeCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSA0XG4gIG9yaWdpbkNhY2hlLnNldCh4cywgbmV3IEVycm9yKCkpXG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHhcbiAgcmV0dXJuIG9yaWdpbkNhY2hlLmdldCh4cylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/query.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/query.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLOSE: () => (/* binding */ CLOSE),\n/* harmony export */   Query: () => (/* binding */ Query)\n/* harmony export */ });\nconst originCache = new Map()\n    , originStackCache = new Map()\n    , originError = Symbol('OriginError')\n\nconst CLOSE = {}\nclass Query extends Promise {\n  constructor(strings, args, handler, canceller, options = {}) {\n    let resolve\n      , reject\n\n    super((a, b) => {\n      resolve = a\n      reject = b\n    })\n\n    this.tagged = Array.isArray(strings.raw)\n    this.strings = strings\n    this.args = args\n    this.handler = handler\n    this.canceller = canceller\n    this.options = options\n\n    this.state = null\n    this.statement = null\n\n    this.resolve = x => (this.active = false, resolve(x))\n    this.reject = x => (this.active = false, reject(x))\n\n    this.active = false\n    this.cancelled = null\n    this.executed = false\n    this.signature = ''\n\n    this[originError] = this.handler.debug\n      ? new Error()\n      : this.tagged && cachedError(this.strings)\n  }\n\n  get origin() {\n    return (this.handler.debug\n      ? this[originError].stack\n      : this.tagged && originStackCache.has(this.strings)\n        ? originStackCache.get(this.strings)\n        : originStackCache.set(this.strings, this[originError].stack).get(this.strings)\n    ) || ''\n  }\n\n  static get [Symbol.species]() {\n    return Promise\n  }\n\n  cancel() {\n    return this.canceller && (this.canceller(this), this.canceller = null)\n  }\n\n  simple() {\n    this.options.simple = true\n    this.options.prepare = false\n    return this\n  }\n\n  async readable() {\n    this.simple()\n    this.streaming = true\n    return this\n  }\n\n  async writable() {\n    this.simple()\n    this.streaming = true\n    return this\n  }\n\n  cursor(rows = 1, fn) {\n    this.options.simple = false\n    if (typeof rows === 'function') {\n      fn = rows\n      rows = 1\n    }\n\n    this.cursorRows = rows\n\n    if (typeof fn === 'function')\n      return (this.cursorFn = fn, this)\n\n    let prev\n    return {\n      [Symbol.asyncIterator]: () => ({\n        next: () => {\n          if (this.executed && !this.active)\n            return { done: true }\n\n          prev && prev()\n          const promise = new Promise((resolve, reject) => {\n            this.cursorFn = value => {\n              resolve({ value, done: false })\n              return new Promise(r => prev = r)\n            }\n            this.resolve = () => (this.active = false, resolve({ done: true }))\n            this.reject = x => (this.active = false, reject(x))\n          })\n          this.execute()\n          return promise\n        },\n        return() {\n          prev && prev(CLOSE)\n          return { done: true }\n        }\n      })\n    }\n  }\n\n  describe() {\n    this.options.simple = false\n    this.onlyDescribe = this.options.prepare = true\n    return this\n  }\n\n  stream() {\n    throw new Error('.stream has been renamed to .forEach')\n  }\n\n  forEach(fn) {\n    this.forEachFn = fn\n    this.handle()\n    return this\n  }\n\n  raw() {\n    this.isRaw = true\n    return this\n  }\n\n  values() {\n    this.isRaw = 'values'\n    return this\n  }\n\n  async handle() {\n    !this.executed && (this.executed = true) && await 1 && this.handler(this)\n  }\n\n  execute() {\n    this.handle()\n    return this\n  }\n\n  then() {\n    this.handle()\n    return super.then.apply(this, arguments)\n  }\n\n  catch() {\n    this.handle()\n    return super.catch.apply(this, arguments)\n  }\n\n  finally() {\n    this.handle()\n    return super.finally.apply(this, arguments)\n  }\n}\n\nfunction cachedError(xs) {\n  if (originCache.has(xs))\n    return originCache.get(xs)\n\n  const x = Error.stackTraceLimit\n  Error.stackTraceLimit = 4\n  originCache.set(xs, new Error())\n  Error.stackTraceLimit = x\n  return originCache.get(xs)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVPO0FBQ0E7QUFDUCw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29uZWNhcmQvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3F1ZXJ5LmpzPzhkNDciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb3JpZ2luQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAsIG9yaWdpblN0YWNrQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAsIG9yaWdpbkVycm9yID0gU3ltYm9sKCdPcmlnaW5FcnJvcicpXG5cbmV4cG9ydCBjb25zdCBDTE9TRSA9IHt9XG5leHBvcnQgY2xhc3MgUXVlcnkgZXh0ZW5kcyBQcm9taXNlIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgYXJncywgaGFuZGxlciwgY2FuY2VsbGVyLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcmVzb2x2ZVxuICAgICAgLCByZWplY3RcblxuICAgIHN1cGVyKChhLCBiKSA9PiB7XG4gICAgICByZXNvbHZlID0gYVxuICAgICAgcmVqZWN0ID0gYlxuICAgIH0pXG5cbiAgICB0aGlzLnRhZ2dlZCA9IEFycmF5LmlzQXJyYXkoc3RyaW5ncy5yYXcpXG4gICAgdGhpcy5zdHJpbmdzID0gc3RyaW5nc1xuICAgIHRoaXMuYXJncyA9IGFyZ3NcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5jYW5jZWxsZXIgPSBjYW5jZWxsZXJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLnN0YXRlID0gbnVsbFxuICAgIHRoaXMuc3RhdGVtZW50ID0gbnVsbFxuXG4gICAgdGhpcy5yZXNvbHZlID0geCA9PiAodGhpcy5hY3RpdmUgPSBmYWxzZSwgcmVzb2x2ZSh4KSlcbiAgICB0aGlzLnJlamVjdCA9IHggPT4gKHRoaXMuYWN0aXZlID0gZmFsc2UsIHJlamVjdCh4KSlcblxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2VcbiAgICB0aGlzLmNhbmNlbGxlZCA9IG51bGxcbiAgICB0aGlzLmV4ZWN1dGVkID0gZmFsc2VcbiAgICB0aGlzLnNpZ25hdHVyZSA9ICcnXG5cbiAgICB0aGlzW29yaWdpbkVycm9yXSA9IHRoaXMuaGFuZGxlci5kZWJ1Z1xuICAgICAgPyBuZXcgRXJyb3IoKVxuICAgICAgOiB0aGlzLnRhZ2dlZCAmJiBjYWNoZWRFcnJvcih0aGlzLnN0cmluZ3MpXG4gIH1cblxuICBnZXQgb3JpZ2luKCkge1xuICAgIHJldHVybiAodGhpcy5oYW5kbGVyLmRlYnVnXG4gICAgICA/IHRoaXNbb3JpZ2luRXJyb3JdLnN0YWNrXG4gICAgICA6IHRoaXMudGFnZ2VkICYmIG9yaWdpblN0YWNrQ2FjaGUuaGFzKHRoaXMuc3RyaW5ncylcbiAgICAgICAgPyBvcmlnaW5TdGFja0NhY2hlLmdldCh0aGlzLnN0cmluZ3MpXG4gICAgICAgIDogb3JpZ2luU3RhY2tDYWNoZS5zZXQodGhpcy5zdHJpbmdzLCB0aGlzW29yaWdpbkVycm9yXS5zdGFjaykuZ2V0KHRoaXMuc3RyaW5ncylcbiAgICApIHx8ICcnXG4gIH1cblxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIFByb21pc2VcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5jZWxsZXIgJiYgKHRoaXMuY2FuY2VsbGVyKHRoaXMpLCB0aGlzLmNhbmNlbGxlciA9IG51bGwpXG4gIH1cblxuICBzaW1wbGUoKSB7XG4gICAgdGhpcy5vcHRpb25zLnNpbXBsZSA9IHRydWVcbiAgICB0aGlzLm9wdGlvbnMucHJlcGFyZSA9IGZhbHNlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGFzeW5jIHJlYWRhYmxlKCkge1xuICAgIHRoaXMuc2ltcGxlKClcbiAgICB0aGlzLnN0cmVhbWluZyA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXN5bmMgd3JpdGFibGUoKSB7XG4gICAgdGhpcy5zaW1wbGUoKVxuICAgIHRoaXMuc3RyZWFtaW5nID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjdXJzb3Iocm93cyA9IDEsIGZuKSB7XG4gICAgdGhpcy5vcHRpb25zLnNpbXBsZSA9IGZhbHNlXG4gICAgaWYgKHR5cGVvZiByb3dzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbiA9IHJvd3NcbiAgICAgIHJvd3MgPSAxXG4gICAgfVxuXG4gICAgdGhpcy5jdXJzb3JSb3dzID0gcm93c1xuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHJldHVybiAodGhpcy5jdXJzb3JGbiA9IGZuLCB0aGlzKVxuXG4gICAgbGV0IHByZXZcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gKHtcbiAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGVkICYmICF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfVxuXG4gICAgICAgICAgcHJldiAmJiBwcmV2KClcbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3JGbiA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiBmYWxzZSB9KVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UociA9PiBwcmV2ID0gcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+ICh0aGlzLmFjdGl2ZSA9IGZhbHNlLCByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KSlcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0geCA9PiAodGhpcy5hY3RpdmUgPSBmYWxzZSwgcmVqZWN0KHgpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5leGVjdXRlKClcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICB9LFxuICAgICAgICByZXR1cm4oKSB7XG4gICAgICAgICAgcHJldiAmJiBwcmV2KENMT1NFKVxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGRlc2NyaWJlKCkge1xuICAgIHRoaXMub3B0aW9ucy5zaW1wbGUgPSBmYWxzZVxuICAgIHRoaXMub25seURlc2NyaWJlID0gdGhpcy5vcHRpb25zLnByZXBhcmUgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5zdHJlYW0gaGFzIGJlZW4gcmVuYW1lZCB0byAuZm9yRWFjaCcpXG4gIH1cblxuICBmb3JFYWNoKGZuKSB7XG4gICAgdGhpcy5mb3JFYWNoRm4gPSBmblxuICAgIHRoaXMuaGFuZGxlKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmF3KCkge1xuICAgIHRoaXMuaXNSYXcgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhbHVlcygpIHtcbiAgICB0aGlzLmlzUmF3ID0gJ3ZhbHVlcydcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlKCkge1xuICAgICF0aGlzLmV4ZWN1dGVkICYmICh0aGlzLmV4ZWN1dGVkID0gdHJ1ZSkgJiYgYXdhaXQgMSAmJiB0aGlzLmhhbmRsZXIodGhpcylcbiAgfVxuXG4gIGV4ZWN1dGUoKSB7XG4gICAgdGhpcy5oYW5kbGUoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGVuKCkge1xuICAgIHRoaXMuaGFuZGxlKClcbiAgICByZXR1cm4gc3VwZXIudGhlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cblxuICBjYXRjaCgpIHtcbiAgICB0aGlzLmhhbmRsZSgpXG4gICAgcmV0dXJuIHN1cGVyLmNhdGNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZpbmFsbHkoKSB7XG4gICAgdGhpcy5oYW5kbGUoKVxuICAgIHJldHVybiBzdXBlci5maW5hbGx5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZWRFcnJvcih4cykge1xuICBpZiAob3JpZ2luQ2FjaGUuaGFzKHhzKSlcbiAgICByZXR1cm4gb3JpZ2luQ2FjaGUuZ2V0KHhzKVxuXG4gIGNvbnN0IHggPSBFcnJvci5zdGFja1RyYWNlTGltaXRcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNFxuICBvcmlnaW5DYWNoZS5zZXQoeHMsIG5ldyBFcnJvcigpKVxuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSB4XG4gIHJldHVybiBvcmlnaW5DYWNoZS5nZXQoeHMpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/query.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/queue.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/queue.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Queue);\n\nfunction Queue(initial = []) {\n  let xs = initial.slice()\n  let index = 0\n\n  return {\n    get length() {\n      return xs.length - index\n    },\n    remove: (x) => {\n      const index = xs.indexOf(x)\n      return index === -1\n        ? null\n        : (xs.splice(index, 1), x)\n    },\n    push: (x) => (xs.push(x), x),\n    shift: () => {\n      const out = xs[index++]\n\n      if (index === xs.length) {\n        index = 0\n        xs = []\n      } else {\n        xs[index - 1] = undefined\n      }\n\n      return out\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvcXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLEtBQUs7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmVjYXJkLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzL3NyYy9xdWV1ZS5qcz82MjBjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFF1ZXVlXG5cbmZ1bmN0aW9uIFF1ZXVlKGluaXRpYWwgPSBbXSkge1xuICBsZXQgeHMgPSBpbml0aWFsLnNsaWNlKClcbiAgbGV0IGluZGV4ID0gMFxuXG4gIHJldHVybiB7XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiB4cy5sZW5ndGggLSBpbmRleFxuICAgIH0sXG4gICAgcmVtb3ZlOiAoeCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB4cy5pbmRleE9mKHgpXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6ICh4cy5zcGxpY2UoaW5kZXgsIDEpLCB4KVxuICAgIH0sXG4gICAgcHVzaDogKHgpID0+ICh4cy5wdXNoKHgpLCB4KSxcbiAgICBzaGlmdDogKCkgPT4ge1xuICAgICAgY29uc3Qgb3V0ID0geHNbaW5kZXgrK11cblxuICAgICAgaWYgKGluZGV4ID09PSB4cy5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwXG4gICAgICAgIHhzID0gW11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhzW2luZGV4IC0gMV0gPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/queue.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/queue.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Queue);\n\nfunction Queue(initial = []) {\n  let xs = initial.slice()\n  let index = 0\n\n  return {\n    get length() {\n      return xs.length - index\n    },\n    remove: (x) => {\n      const index = xs.indexOf(x)\n      return index === -1\n        ? null\n        : (xs.splice(index, 1), x)\n    },\n    push: (x) => (xs.push(x), x),\n    shift: () => {\n      const out = xs[index++]\n\n      if (index === xs.length) {\n        index = 0\n        xs = []\n      } else {\n        xs[index - 1] = undefined\n      }\n\n      return out\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3F1ZXVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxLQUFLOztBQUVwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvcXVldWUuanM/ZmU1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBRdWV1ZVxuXG5mdW5jdGlvbiBRdWV1ZShpbml0aWFsID0gW10pIHtcbiAgbGV0IHhzID0gaW5pdGlhbC5zbGljZSgpXG4gIGxldCBpbmRleCA9IDBcblxuICByZXR1cm4ge1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4geHMubGVuZ3RoIC0gaW5kZXhcbiAgICB9LFxuICAgIHJlbW92ZTogKHgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0geHMuaW5kZXhPZih4KVxuICAgICAgcmV0dXJuIGluZGV4ID09PSAtMVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiAoeHMuc3BsaWNlKGluZGV4LCAxKSwgeClcbiAgICB9LFxuICAgIHB1c2g6ICh4KSA9PiAoeHMucHVzaCh4KSwgeCksXG4gICAgc2hpZnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IG91dCA9IHhzW2luZGV4KytdXG5cbiAgICAgIGlmIChpbmRleCA9PT0geHMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgICB4cyA9IFtdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4c1tpbmRleCAtIDFdID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/queue.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/result.js":
/*!*********************************************!*\
  !*** ./node_modules/postgres/src/result.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Result)\n/* harmony export */ });\nclass Result extends Array {\n  constructor() {\n    super()\n    Object.defineProperties(this, {\n      count: { value: null, writable: true },\n      state: { value: null, writable: true },\n      command: { value: null, writable: true },\n      columns: { value: null, writable: true },\n      statement: { value: null, writable: true }\n    })\n  }\n\n  static get [Symbol.species]() {\n    return Array\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvcmVzdWx0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDLGVBQWUsNkJBQTZCO0FBQzVDLGlCQUFpQiw2QkFBNkI7QUFDOUMsaUJBQWlCLDZCQUE2QjtBQUM5QyxtQkFBbUI7QUFDbkIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvcmVzdWx0LmpzP2M1ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgY291bnQ6IHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICBzdGF0ZTogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgIGNvbW1hbmQ6IHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICBjb2x1bW5zOiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgc3RhdGVtZW50OiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICByZXR1cm4gQXJyYXlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/result.js":
/*!*********************************************!*\
  !*** ./node_modules/postgres/src/result.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Result)\n/* harmony export */ });\nclass Result extends Array {\n  constructor() {\n    super()\n    Object.defineProperties(this, {\n      count: { value: null, writable: true },\n      state: { value: null, writable: true },\n      command: { value: null, writable: true },\n      columns: { value: null, writable: true },\n      statement: { value: null, writable: true }\n    })\n  }\n\n  static get [Symbol.species]() {\n    return Array\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3Jlc3VsdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLDZCQUE2QjtBQUM1QyxpQkFBaUIsNkJBQTZCO0FBQzlDLGlCQUFpQiw2QkFBNkI7QUFDOUMsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29uZWNhcmQvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3Jlc3VsdC5qcz9lNTY0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdCBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIGNvdW50OiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgc3RhdGU6IHsgdmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICBjb21tYW5kOiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgY29sdW1uczogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICAgIHN0YXRlbWVudDogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIEFycmF5XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/result.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/subscribe.js":
/*!************************************************!*\
  !*** ./node_modules/postgres/src/subscribe.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Subscribe)\n/* harmony export */ });\nconst noop = () => { /* noop */ }\n\nfunction Subscribe(postgres, options) {\n  const subscribers = new Map()\n      , slot = 'postgresjs_' + Math.random().toString(36).slice(2)\n      , state = {}\n\n  let connection\n    , stream\n    , ended = false\n\n  const sql = subscribe.sql = postgres({\n    ...options,\n    transform: { column: {}, value: {}, row: {} },\n    max: 1,\n    fetch_types: false,\n    idle_timeout: null,\n    max_lifetime: null,\n    connection: {\n      ...options.connection,\n      replication: 'database'\n    },\n    onclose: async function() {\n      if (ended)\n        return\n      stream = null\n      state.pid = state.secret = undefined\n      connected(await init(sql, slot, options.publications))\n      subscribers.forEach(event => event.forEach(({ onsubscribe }) => onsubscribe()))\n    },\n    no_subscribe: true\n  })\n\n  const end = sql.end\n      , close = sql.close\n\n  sql.end = async() => {\n    ended = true\n    stream && (await new Promise(r => (stream.once('close', r), stream.end())))\n    return end()\n  }\n\n  sql.close = async() => {\n    stream && (await new Promise(r => (stream.once('close', r), stream.end())))\n    return close()\n  }\n\n  return subscribe\n\n  async function subscribe(event, fn, onsubscribe = noop) {\n    event = parseEvent(event)\n\n    if (!connection)\n      connection = init(sql, slot, options.publications)\n\n    const subscriber = { fn, onsubscribe }\n    const fns = subscribers.has(event)\n      ? subscribers.get(event).add(subscriber)\n      : subscribers.set(event, new Set([subscriber])).get(event)\n\n    const unsubscribe = () => {\n      fns.delete(subscriber)\n      fns.size === 0 && subscribers.delete(event)\n    }\n\n    return connection.then(x => {\n      connected(x)\n      onsubscribe()\n      return { unsubscribe, state, sql }\n    })\n  }\n\n  function connected(x) {\n    stream = x.stream\n    state.pid = x.state.pid\n    state.secret = x.state.secret\n  }\n\n  async function init(sql, slot, publications) {\n    if (!publications)\n      throw new Error('Missing publication names')\n\n    const xs = await sql.unsafe(\n      `CREATE_REPLICATION_SLOT ${ slot } TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`\n    )\n\n    const [x] = xs\n\n    const stream = await sql.unsafe(\n      `START_REPLICATION SLOT ${ slot } LOGICAL ${\n        x.consistent_point\n      } (proto_version '1', publication_names '${ publications }')`\n    ).writable()\n\n    const state = {\n      lsn: Buffer.concat(x.consistent_point.split('/').map(x => Buffer.from(('00000000' + x).slice(-8), 'hex')))\n    }\n\n    stream.on('data', data)\n    stream.on('error', error)\n    stream.on('close', sql.close)\n\n    return { stream, state: xs.state }\n\n    function error(e) {\n      console.error('Unexpected error during logical streaming - reconnecting', e)\n    }\n\n    function data(x) {\n      if (x[0] === 0x77)\n        parse(x.subarray(25), state, sql.options.parsers, handle, options.transform)\n      else if (x[0] === 0x6b && x[17])\n        pong()\n    }\n\n    function handle(a, b) {\n      const path = b.relation.schema + '.' + b.relation.table\n      call('*', a, b)\n      call('*:' + path, a, b)\n      b.relation.keys.length && call('*:' + path + '=' + b.relation.keys.map(x => a[x.name]), a, b)\n      call(b.command, a, b)\n      call(b.command + ':' + path, a, b)\n      b.relation.keys.length && call(b.command + ':' + path + '=' + b.relation.keys.map(x => a[x.name]), a, b)\n    }\n\n    function pong() {\n      const x = Buffer.alloc(34)\n      x[0] = 'r'.charCodeAt(0)\n      x.fill(state.lsn, 1)\n      x.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25)\n      stream.write(x)\n    }\n  }\n\n  function call(x, a, b) {\n    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a, b, x))\n  }\n}\n\nfunction Time(x) {\n  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)))\n}\n\nfunction parse(x, state, parsers, handle, transform) {\n  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc)\n\n  Object.entries({\n    R: x => {  // Relation\n      let i = 1\n      const r = state[x.readUInt32BE(i)] = {\n        schema: x.toString('utf8', i += 4, i = x.indexOf(0, i)) || 'pg_catalog',\n        table: x.toString('utf8', i + 1, i = x.indexOf(0, i + 1)),\n        columns: Array(x.readUInt16BE(i += 2)),\n        keys: []\n      }\n      i += 2\n\n      let columnIndex = 0\n        , column\n\n      while (i < x.length) {\n        column = r.columns[columnIndex++] = {\n          key: x[i++],\n          name: transform.column.from\n            ? transform.column.from(x.toString('utf8', i, i = x.indexOf(0, i)))\n            : x.toString('utf8', i, i = x.indexOf(0, i)),\n          type: x.readUInt32BE(i += 1),\n          parser: parsers[x.readUInt32BE(i)],\n          atttypmod: x.readUInt32BE(i += 4)\n        }\n\n        column.key && r.keys.push(column)\n        i += 4\n      }\n    },\n    Y: () => { /* noop */ }, // Type\n    O: () => { /* noop */ }, // Origin\n    B: x => { // Begin\n      state.date = Time(x.readBigInt64BE(9))\n      state.lsn = x.subarray(1, 9)\n    },\n    I: x => { // Insert\n      let i = 1\n      const relation = state[x.readUInt32BE(i)]\n      const { row } = tuples(x, relation.columns, i += 7, transform)\n\n      handle(row, {\n        command: 'insert',\n        relation\n      })\n    },\n    D: x => { // Delete\n      let i = 1\n      const relation = state[x.readUInt32BE(i)]\n      i += 4\n      const key = x[i] === 75\n      handle(key || x[i] === 79\n        ? tuples(x, relation.columns, i += 3, transform).row\n        : null\n      , {\n        command: 'delete',\n        relation,\n        key\n      })\n    },\n    U: x => { // Update\n      let i = 1\n      const relation = state[x.readUInt32BE(i)]\n      i += 4\n      const key = x[i] === 75\n      const xs = key || x[i] === 79\n        ? tuples(x, relation.columns, i += 3, transform)\n        : null\n\n      xs && (i = xs.i)\n\n      const { row } = tuples(x, relation.columns, i + 3, transform)\n\n      handle(row, {\n        command: 'update',\n        relation,\n        key,\n        old: xs && xs.row\n      })\n    },\n    T: () => { /* noop */ }, // Truncate,\n    C: () => { /* noop */ }  // Commit\n  }).reduce(char, {})[x[0]](x)\n}\n\nfunction tuples(x, columns, xi, transform) {\n  let type\n    , column\n    , value\n\n  const row = transform.raw ? new Array(columns.length) : {}\n  for (let i = 0; i < columns.length; i++) {\n    type = x[xi++]\n    column = columns[i]\n    value = type === 110 // n\n      ? null\n      : type === 117 // u\n        ? undefined\n        : column.parser === undefined\n          ? x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi))\n          : column.parser.array === true\n            ? column.parser(x.toString('utf8', xi + 5, xi += 4 + x.readUInt32BE(xi)))\n            : column.parser(x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi)))\n\n    transform.raw\n      ? (row[i] = transform.raw === true\n        ? value\n        : transform.value.from ? transform.value.from(value, column) : value)\n      : (row[column.name] = transform.value.from\n        ? transform.value.from(value, column)\n        : value\n      )\n  }\n\n  return { i: xi, row: transform.row.from ? transform.row.from(row) : row }\n}\n\nfunction parseEvent(x) {\n  const xs = x.match(/^(\\*|insert|update|delete)?:?([^.]+?\\.?[^=]+)?=?(.+)?/i) || []\n\n  if (!xs)\n    throw new Error('Malformed subscribe pattern: ' + x)\n\n  const [, command, path, key] = xs\n\n  return (command || '*')\n       + (path ? ':' + (path.indexOf('.') === -1 ? 'public.' + path : path) : '')\n       + (key ? '=' + key : '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvc3Vic2NyaWJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxxQkFBcUI7O0FBRU47QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVSxXQUFXLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakUsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQSxRQUFRLDBDQUEwQyxjQUFjO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0IsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLE1BQU07O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLE1BQU07O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGVBQWUsWUFBWTtBQUMzQixlQUFlLGNBQWM7QUFDN0IsR0FBRyxpQkFBaUI7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmVjYXJkLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzL3NyYy9zdWJzY3JpYmUuanM/MGZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBub29wID0gKCkgPT4geyAvKiBub29wICovIH1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3Vic2NyaWJlKHBvc3RncmVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IE1hcCgpXG4gICAgICAsIHNsb3QgPSAncG9zdGdyZXNqc18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMilcbiAgICAgICwgc3RhdGUgPSB7fVxuXG4gIGxldCBjb25uZWN0aW9uXG4gICAgLCBzdHJlYW1cbiAgICAsIGVuZGVkID0gZmFsc2VcblxuICBjb25zdCBzcWwgPSBzdWJzY3JpYmUuc3FsID0gcG9zdGdyZXMoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdHJhbnNmb3JtOiB7IGNvbHVtbjoge30sIHZhbHVlOiB7fSwgcm93OiB7fSB9LFxuICAgIG1heDogMSxcbiAgICBmZXRjaF90eXBlczogZmFsc2UsXG4gICAgaWRsZV90aW1lb3V0OiBudWxsLFxuICAgIG1heF9saWZldGltZTogbnVsbCxcbiAgICBjb25uZWN0aW9uOiB7XG4gICAgICAuLi5vcHRpb25zLmNvbm5lY3Rpb24sXG4gICAgICByZXBsaWNhdGlvbjogJ2RhdGFiYXNlJ1xuICAgIH0sXG4gICAgb25jbG9zZTogYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZW5kZWQpXG4gICAgICAgIHJldHVyblxuICAgICAgc3RyZWFtID0gbnVsbFxuICAgICAgc3RhdGUucGlkID0gc3RhdGUuc2VjcmV0ID0gdW5kZWZpbmVkXG4gICAgICBjb25uZWN0ZWQoYXdhaXQgaW5pdChzcWwsIHNsb3QsIG9wdGlvbnMucHVibGljYXRpb25zKSlcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZXZlbnQgPT4gZXZlbnQuZm9yRWFjaCgoeyBvbnN1YnNjcmliZSB9KSA9PiBvbnN1YnNjcmliZSgpKSlcbiAgICB9LFxuICAgIG5vX3N1YnNjcmliZTogdHJ1ZVxuICB9KVxuXG4gIGNvbnN0IGVuZCA9IHNxbC5lbmRcbiAgICAgICwgY2xvc2UgPSBzcWwuY2xvc2VcblxuICBzcWwuZW5kID0gYXN5bmMoKSA9PiB7XG4gICAgZW5kZWQgPSB0cnVlXG4gICAgc3RyZWFtICYmIChhd2FpdCBuZXcgUHJvbWlzZShyID0+IChzdHJlYW0ub25jZSgnY2xvc2UnLCByKSwgc3RyZWFtLmVuZCgpKSkpXG4gICAgcmV0dXJuIGVuZCgpXG4gIH1cblxuICBzcWwuY2xvc2UgPSBhc3luYygpID0+IHtcbiAgICBzdHJlYW0gJiYgKGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gKHN0cmVhbS5vbmNlKCdjbG9zZScsIHIpLCBzdHJlYW0uZW5kKCkpKSlcbiAgICByZXR1cm4gY2xvc2UoKVxuICB9XG5cbiAgcmV0dXJuIHN1YnNjcmliZVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHN1YnNjcmliZShldmVudCwgZm4sIG9uc3Vic2NyaWJlID0gbm9vcCkge1xuICAgIGV2ZW50ID0gcGFyc2VFdmVudChldmVudClcblxuICAgIGlmICghY29ubmVjdGlvbilcbiAgICAgIGNvbm5lY3Rpb24gPSBpbml0KHNxbCwgc2xvdCwgb3B0aW9ucy5wdWJsaWNhdGlvbnMpXG5cbiAgICBjb25zdCBzdWJzY3JpYmVyID0geyBmbiwgb25zdWJzY3JpYmUgfVxuICAgIGNvbnN0IGZucyA9IHN1YnNjcmliZXJzLmhhcyhldmVudClcbiAgICAgID8gc3Vic2NyaWJlcnMuZ2V0KGV2ZW50KS5hZGQoc3Vic2NyaWJlcilcbiAgICAgIDogc3Vic2NyaWJlcnMuc2V0KGV2ZW50LCBuZXcgU2V0KFtzdWJzY3JpYmVyXSkpLmdldChldmVudClcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgZm5zLmRlbGV0ZShzdWJzY3JpYmVyKVxuICAgICAgZm5zLnNpemUgPT09IDAgJiYgc3Vic2NyaWJlcnMuZGVsZXRlKGV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBjb25uZWN0aW9uLnRoZW4oeCA9PiB7XG4gICAgICBjb25uZWN0ZWQoeClcbiAgICAgIG9uc3Vic2NyaWJlKClcbiAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlLCBzdGF0ZSwgc3FsIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29ubmVjdGVkKHgpIHtcbiAgICBzdHJlYW0gPSB4LnN0cmVhbVxuICAgIHN0YXRlLnBpZCA9IHguc3RhdGUucGlkXG4gICAgc3RhdGUuc2VjcmV0ID0geC5zdGF0ZS5zZWNyZXRcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGluaXQoc3FsLCBzbG90LCBwdWJsaWNhdGlvbnMpIHtcbiAgICBpZiAoIXB1YmxpY2F0aW9ucylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNhdGlvbiBuYW1lcycpXG5cbiAgICBjb25zdCB4cyA9IGF3YWl0IHNxbC51bnNhZmUoXG4gICAgICBgQ1JFQVRFX1JFUExJQ0FUSU9OX1NMT1QgJHsgc2xvdCB9IFRFTVBPUkFSWSBMT0dJQ0FMIHBnb3V0cHV0IE5PRVhQT1JUX1NOQVBTSE9UYFxuICAgIClcblxuICAgIGNvbnN0IFt4XSA9IHhzXG5cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzcWwudW5zYWZlKFxuICAgICAgYFNUQVJUX1JFUExJQ0FUSU9OIFNMT1QgJHsgc2xvdCB9IExPR0lDQUwgJHtcbiAgICAgICAgeC5jb25zaXN0ZW50X3BvaW50XG4gICAgICB9IChwcm90b192ZXJzaW9uICcxJywgcHVibGljYXRpb25fbmFtZXMgJyR7IHB1YmxpY2F0aW9ucyB9JylgXG4gICAgKS53cml0YWJsZSgpXG5cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIGxzbjogQnVmZmVyLmNvbmNhdCh4LmNvbnNpc3RlbnRfcG9pbnQuc3BsaXQoJy8nKS5tYXAoeCA9PiBCdWZmZXIuZnJvbSgoJzAwMDAwMDAwJyArIHgpLnNsaWNlKC04KSwgJ2hleCcpKSlcbiAgICB9XG5cbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBkYXRhKVxuICAgIHN0cmVhbS5vbignZXJyb3InLCBlcnJvcilcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgc3FsLmNsb3NlKVxuXG4gICAgcmV0dXJuIHsgc3RyZWFtLCBzdGF0ZTogeHMuc3RhdGUgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvciBkdXJpbmcgbG9naWNhbCBzdHJlYW1pbmcgLSByZWNvbm5lY3RpbmcnLCBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRhdGEoeCkge1xuICAgICAgaWYgKHhbMF0gPT09IDB4NzcpXG4gICAgICAgIHBhcnNlKHguc3ViYXJyYXkoMjUpLCBzdGF0ZSwgc3FsLm9wdGlvbnMucGFyc2VycywgaGFuZGxlLCBvcHRpb25zLnRyYW5zZm9ybSlcbiAgICAgIGVsc2UgaWYgKHhbMF0gPT09IDB4NmIgJiYgeFsxN10pXG4gICAgICAgIHBvbmcoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZShhLCBiKSB7XG4gICAgICBjb25zdCBwYXRoID0gYi5yZWxhdGlvbi5zY2hlbWEgKyAnLicgKyBiLnJlbGF0aW9uLnRhYmxlXG4gICAgICBjYWxsKCcqJywgYSwgYilcbiAgICAgIGNhbGwoJyo6JyArIHBhdGgsIGEsIGIpXG4gICAgICBiLnJlbGF0aW9uLmtleXMubGVuZ3RoICYmIGNhbGwoJyo6JyArIHBhdGggKyAnPScgKyBiLnJlbGF0aW9uLmtleXMubWFwKHggPT4gYVt4Lm5hbWVdKSwgYSwgYilcbiAgICAgIGNhbGwoYi5jb21tYW5kLCBhLCBiKVxuICAgICAgY2FsbChiLmNvbW1hbmQgKyAnOicgKyBwYXRoLCBhLCBiKVxuICAgICAgYi5yZWxhdGlvbi5rZXlzLmxlbmd0aCAmJiBjYWxsKGIuY29tbWFuZCArICc6JyArIHBhdGggKyAnPScgKyBiLnJlbGF0aW9uLmtleXMubWFwKHggPT4gYVt4Lm5hbWVdKSwgYSwgYilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb25nKCkge1xuICAgICAgY29uc3QgeCA9IEJ1ZmZlci5hbGxvYygzNClcbiAgICAgIHhbMF0gPSAncicuY2hhckNvZGVBdCgwKVxuICAgICAgeC5maWxsKHN0YXRlLmxzbiwgMSlcbiAgICAgIHgud3JpdGVCaWdJbnQ2NEJFKEJpZ0ludChEYXRlLm5vdygpIC0gRGF0ZS5VVEMoMjAwMCwgMCwgMSkpICogQmlnSW50KDEwMDApLCAyNSlcbiAgICAgIHN0cmVhbS53cml0ZSh4KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGwoeCwgYSwgYikge1xuICAgIHN1YnNjcmliZXJzLmhhcyh4KSAmJiBzdWJzY3JpYmVycy5nZXQoeCkuZm9yRWFjaCgoeyBmbiB9KSA9PiBmbihhLCBiLCB4KSlcbiAgfVxufVxuXG5mdW5jdGlvbiBUaW1lKHgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDIwMDAsIDAsIDEpICsgTnVtYmVyKHggLyBCaWdJbnQoMTAwMCkpKVxufVxuXG5mdW5jdGlvbiBwYXJzZSh4LCBzdGF0ZSwgcGFyc2VycywgaGFuZGxlLCB0cmFuc2Zvcm0pIHtcbiAgY29uc3QgY2hhciA9IChhY2MsIFtrLCB2XSkgPT4gKGFjY1trLmNoYXJDb2RlQXQoMCldID0gdiwgYWNjKVxuXG4gIE9iamVjdC5lbnRyaWVzKHtcbiAgICBSOiB4ID0+IHsgIC8vIFJlbGF0aW9uXG4gICAgICBsZXQgaSA9IDFcbiAgICAgIGNvbnN0IHIgPSBzdGF0ZVt4LnJlYWRVSW50MzJCRShpKV0gPSB7XG4gICAgICAgIHNjaGVtYTogeC50b1N0cmluZygndXRmOCcsIGkgKz0gNCwgaSA9IHguaW5kZXhPZigwLCBpKSkgfHwgJ3BnX2NhdGFsb2cnLFxuICAgICAgICB0YWJsZTogeC50b1N0cmluZygndXRmOCcsIGkgKyAxLCBpID0geC5pbmRleE9mKDAsIGkgKyAxKSksXG4gICAgICAgIGNvbHVtbnM6IEFycmF5KHgucmVhZFVJbnQxNkJFKGkgKz0gMikpLFxuICAgICAgICBrZXlzOiBbXVxuICAgICAgfVxuICAgICAgaSArPSAyXG5cbiAgICAgIGxldCBjb2x1bW5JbmRleCA9IDBcbiAgICAgICAgLCBjb2x1bW5cblxuICAgICAgd2hpbGUgKGkgPCB4Lmxlbmd0aCkge1xuICAgICAgICBjb2x1bW4gPSByLmNvbHVtbnNbY29sdW1uSW5kZXgrK10gPSB7XG4gICAgICAgICAga2V5OiB4W2krK10sXG4gICAgICAgICAgbmFtZTogdHJhbnNmb3JtLmNvbHVtbi5mcm9tXG4gICAgICAgICAgICA/IHRyYW5zZm9ybS5jb2x1bW4uZnJvbSh4LnRvU3RyaW5nKCd1dGY4JywgaSwgaSA9IHguaW5kZXhPZigwLCBpKSkpXG4gICAgICAgICAgICA6IHgudG9TdHJpbmcoJ3V0ZjgnLCBpLCBpID0geC5pbmRleE9mKDAsIGkpKSxcbiAgICAgICAgICB0eXBlOiB4LnJlYWRVSW50MzJCRShpICs9IDEpLFxuICAgICAgICAgIHBhcnNlcjogcGFyc2Vyc1t4LnJlYWRVSW50MzJCRShpKV0sXG4gICAgICAgICAgYXR0dHlwbW9kOiB4LnJlYWRVSW50MzJCRShpICs9IDQpXG4gICAgICAgIH1cblxuICAgICAgICBjb2x1bW4ua2V5ICYmIHIua2V5cy5wdXNoKGNvbHVtbilcbiAgICAgICAgaSArPSA0XG4gICAgICB9XG4gICAgfSxcbiAgICBZOiAoKSA9PiB7IC8qIG5vb3AgKi8gfSwgLy8gVHlwZVxuICAgIE86ICgpID0+IHsgLyogbm9vcCAqLyB9LCAvLyBPcmlnaW5cbiAgICBCOiB4ID0+IHsgLy8gQmVnaW5cbiAgICAgIHN0YXRlLmRhdGUgPSBUaW1lKHgucmVhZEJpZ0ludDY0QkUoOSkpXG4gICAgICBzdGF0ZS5sc24gPSB4LnN1YmFycmF5KDEsIDkpXG4gICAgfSxcbiAgICBJOiB4ID0+IHsgLy8gSW5zZXJ0XG4gICAgICBsZXQgaSA9IDFcbiAgICAgIGNvbnN0IHJlbGF0aW9uID0gc3RhdGVbeC5yZWFkVUludDMyQkUoaSldXG4gICAgICBjb25zdCB7IHJvdyB9ID0gdHVwbGVzKHgsIHJlbGF0aW9uLmNvbHVtbnMsIGkgKz0gNywgdHJhbnNmb3JtKVxuXG4gICAgICBoYW5kbGUocm93LCB7XG4gICAgICAgIGNvbW1hbmQ6ICdpbnNlcnQnLFxuICAgICAgICByZWxhdGlvblxuICAgICAgfSlcbiAgICB9LFxuICAgIEQ6IHggPT4geyAvLyBEZWxldGVcbiAgICAgIGxldCBpID0gMVxuICAgICAgY29uc3QgcmVsYXRpb24gPSBzdGF0ZVt4LnJlYWRVSW50MzJCRShpKV1cbiAgICAgIGkgKz0gNFxuICAgICAgY29uc3Qga2V5ID0geFtpXSA9PT0gNzVcbiAgICAgIGhhbmRsZShrZXkgfHwgeFtpXSA9PT0gNzlcbiAgICAgICAgPyB0dXBsZXMoeCwgcmVsYXRpb24uY29sdW1ucywgaSArPSAzLCB0cmFuc2Zvcm0pLnJvd1xuICAgICAgICA6IG51bGxcbiAgICAgICwge1xuICAgICAgICBjb21tYW5kOiAnZGVsZXRlJyxcbiAgICAgICAgcmVsYXRpb24sXG4gICAgICAgIGtleVxuICAgICAgfSlcbiAgICB9LFxuICAgIFU6IHggPT4geyAvLyBVcGRhdGVcbiAgICAgIGxldCBpID0gMVxuICAgICAgY29uc3QgcmVsYXRpb24gPSBzdGF0ZVt4LnJlYWRVSW50MzJCRShpKV1cbiAgICAgIGkgKz0gNFxuICAgICAgY29uc3Qga2V5ID0geFtpXSA9PT0gNzVcbiAgICAgIGNvbnN0IHhzID0ga2V5IHx8IHhbaV0gPT09IDc5XG4gICAgICAgID8gdHVwbGVzKHgsIHJlbGF0aW9uLmNvbHVtbnMsIGkgKz0gMywgdHJhbnNmb3JtKVxuICAgICAgICA6IG51bGxcblxuICAgICAgeHMgJiYgKGkgPSB4cy5pKVxuXG4gICAgICBjb25zdCB7IHJvdyB9ID0gdHVwbGVzKHgsIHJlbGF0aW9uLmNvbHVtbnMsIGkgKyAzLCB0cmFuc2Zvcm0pXG5cbiAgICAgIGhhbmRsZShyb3csIHtcbiAgICAgICAgY29tbWFuZDogJ3VwZGF0ZScsXG4gICAgICAgIHJlbGF0aW9uLFxuICAgICAgICBrZXksXG4gICAgICAgIG9sZDogeHMgJiYgeHMucm93XG4gICAgICB9KVxuICAgIH0sXG4gICAgVDogKCkgPT4geyAvKiBub29wICovIH0sIC8vIFRydW5jYXRlLFxuICAgIEM6ICgpID0+IHsgLyogbm9vcCAqLyB9ICAvLyBDb21taXRcbiAgfSkucmVkdWNlKGNoYXIsIHt9KVt4WzBdXSh4KVxufVxuXG5mdW5jdGlvbiB0dXBsZXMoeCwgY29sdW1ucywgeGksIHRyYW5zZm9ybSkge1xuICBsZXQgdHlwZVxuICAgICwgY29sdW1uXG4gICAgLCB2YWx1ZVxuXG4gIGNvbnN0IHJvdyA9IHRyYW5zZm9ybS5yYXcgPyBuZXcgQXJyYXkoY29sdW1ucy5sZW5ndGgpIDoge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdHlwZSA9IHhbeGkrK11cbiAgICBjb2x1bW4gPSBjb2x1bW5zW2ldXG4gICAgdmFsdWUgPSB0eXBlID09PSAxMTAgLy8gblxuICAgICAgPyBudWxsXG4gICAgICA6IHR5cGUgPT09IDExNyAvLyB1XG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogY29sdW1uLnBhcnNlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB4LnRvU3RyaW5nKCd1dGY4JywgeGkgKyA0LCB4aSArPSA0ICsgeC5yZWFkVUludDMyQkUoeGkpKVxuICAgICAgICAgIDogY29sdW1uLnBhcnNlci5hcnJheSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBjb2x1bW4ucGFyc2VyKHgudG9TdHJpbmcoJ3V0ZjgnLCB4aSArIDUsIHhpICs9IDQgKyB4LnJlYWRVSW50MzJCRSh4aSkpKVxuICAgICAgICAgICAgOiBjb2x1bW4ucGFyc2VyKHgudG9TdHJpbmcoJ3V0ZjgnLCB4aSArIDQsIHhpICs9IDQgKyB4LnJlYWRVSW50MzJCRSh4aSkpKVxuXG4gICAgdHJhbnNmb3JtLnJhd1xuICAgICAgPyAocm93W2ldID0gdHJhbnNmb3JtLnJhdyA9PT0gdHJ1ZVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogdHJhbnNmb3JtLnZhbHVlLmZyb20gPyB0cmFuc2Zvcm0udmFsdWUuZnJvbSh2YWx1ZSwgY29sdW1uKSA6IHZhbHVlKVxuICAgICAgOiAocm93W2NvbHVtbi5uYW1lXSA9IHRyYW5zZm9ybS52YWx1ZS5mcm9tXG4gICAgICAgID8gdHJhbnNmb3JtLnZhbHVlLmZyb20odmFsdWUsIGNvbHVtbilcbiAgICAgICAgOiB2YWx1ZVxuICAgICAgKVxuICB9XG5cbiAgcmV0dXJuIHsgaTogeGksIHJvdzogdHJhbnNmb3JtLnJvdy5mcm9tID8gdHJhbnNmb3JtLnJvdy5mcm9tKHJvdykgOiByb3cgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUV2ZW50KHgpIHtcbiAgY29uc3QgeHMgPSB4Lm1hdGNoKC9eKFxcKnxpbnNlcnR8dXBkYXRlfGRlbGV0ZSk/Oj8oW14uXSs/XFwuP1tePV0rKT89PyguKyk/L2kpIHx8IFtdXG5cbiAgaWYgKCF4cylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBzdWJzY3JpYmUgcGF0dGVybjogJyArIHgpXG5cbiAgY29uc3QgWywgY29tbWFuZCwgcGF0aCwga2V5XSA9IHhzXG5cbiAgcmV0dXJuIChjb21tYW5kIHx8ICcqJylcbiAgICAgICArIChwYXRoID8gJzonICsgKHBhdGguaW5kZXhPZignLicpID09PSAtMSA/ICdwdWJsaWMuJyArIHBhdGggOiBwYXRoKSA6ICcnKVxuICAgICAgICsgKGtleSA/ICc9JyArIGtleSA6ICcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/subscribe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/subscribe.js":
/*!************************************************!*\
  !*** ./node_modules/postgres/src/subscribe.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Subscribe)\n/* harmony export */ });\nconst noop = () => { /* noop */ }\n\nfunction Subscribe(postgres, options) {\n  const subscribers = new Map()\n      , slot = 'postgresjs_' + Math.random().toString(36).slice(2)\n      , state = {}\n\n  let connection\n    , stream\n    , ended = false\n\n  const sql = subscribe.sql = postgres({\n    ...options,\n    transform: { column: {}, value: {}, row: {} },\n    max: 1,\n    fetch_types: false,\n    idle_timeout: null,\n    max_lifetime: null,\n    connection: {\n      ...options.connection,\n      replication: 'database'\n    },\n    onclose: async function() {\n      if (ended)\n        return\n      stream = null\n      state.pid = state.secret = undefined\n      connected(await init(sql, slot, options.publications))\n      subscribers.forEach(event => event.forEach(({ onsubscribe }) => onsubscribe()))\n    },\n    no_subscribe: true\n  })\n\n  const end = sql.end\n      , close = sql.close\n\n  sql.end = async() => {\n    ended = true\n    stream && (await new Promise(r => (stream.once('close', r), stream.end())))\n    return end()\n  }\n\n  sql.close = async() => {\n    stream && (await new Promise(r => (stream.once('close', r), stream.end())))\n    return close()\n  }\n\n  return subscribe\n\n  async function subscribe(event, fn, onsubscribe = noop) {\n    event = parseEvent(event)\n\n    if (!connection)\n      connection = init(sql, slot, options.publications)\n\n    const subscriber = { fn, onsubscribe }\n    const fns = subscribers.has(event)\n      ? subscribers.get(event).add(subscriber)\n      : subscribers.set(event, new Set([subscriber])).get(event)\n\n    const unsubscribe = () => {\n      fns.delete(subscriber)\n      fns.size === 0 && subscribers.delete(event)\n    }\n\n    return connection.then(x => {\n      connected(x)\n      onsubscribe()\n      return { unsubscribe, state, sql }\n    })\n  }\n\n  function connected(x) {\n    stream = x.stream\n    state.pid = x.state.pid\n    state.secret = x.state.secret\n  }\n\n  async function init(sql, slot, publications) {\n    if (!publications)\n      throw new Error('Missing publication names')\n\n    const xs = await sql.unsafe(\n      `CREATE_REPLICATION_SLOT ${ slot } TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`\n    )\n\n    const [x] = xs\n\n    const stream = await sql.unsafe(\n      `START_REPLICATION SLOT ${ slot } LOGICAL ${\n        x.consistent_point\n      } (proto_version '1', publication_names '${ publications }')`\n    ).writable()\n\n    const state = {\n      lsn: Buffer.concat(x.consistent_point.split('/').map(x => Buffer.from(('00000000' + x).slice(-8), 'hex')))\n    }\n\n    stream.on('data', data)\n    stream.on('error', error)\n    stream.on('close', sql.close)\n\n    return { stream, state: xs.state }\n\n    function error(e) {\n      console.error('Unexpected error during logical streaming - reconnecting', e)\n    }\n\n    function data(x) {\n      if (x[0] === 0x77)\n        parse(x.subarray(25), state, sql.options.parsers, handle, options.transform)\n      else if (x[0] === 0x6b && x[17])\n        pong()\n    }\n\n    function handle(a, b) {\n      const path = b.relation.schema + '.' + b.relation.table\n      call('*', a, b)\n      call('*:' + path, a, b)\n      b.relation.keys.length && call('*:' + path + '=' + b.relation.keys.map(x => a[x.name]), a, b)\n      call(b.command, a, b)\n      call(b.command + ':' + path, a, b)\n      b.relation.keys.length && call(b.command + ':' + path + '=' + b.relation.keys.map(x => a[x.name]), a, b)\n    }\n\n    function pong() {\n      const x = Buffer.alloc(34)\n      x[0] = 'r'.charCodeAt(0)\n      x.fill(state.lsn, 1)\n      x.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25)\n      stream.write(x)\n    }\n  }\n\n  function call(x, a, b) {\n    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a, b, x))\n  }\n}\n\nfunction Time(x) {\n  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)))\n}\n\nfunction parse(x, state, parsers, handle, transform) {\n  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc)\n\n  Object.entries({\n    R: x => {  // Relation\n      let i = 1\n      const r = state[x.readUInt32BE(i)] = {\n        schema: x.toString('utf8', i += 4, i = x.indexOf(0, i)) || 'pg_catalog',\n        table: x.toString('utf8', i + 1, i = x.indexOf(0, i + 1)),\n        columns: Array(x.readUInt16BE(i += 2)),\n        keys: []\n      }\n      i += 2\n\n      let columnIndex = 0\n        , column\n\n      while (i < x.length) {\n        column = r.columns[columnIndex++] = {\n          key: x[i++],\n          name: transform.column.from\n            ? transform.column.from(x.toString('utf8', i, i = x.indexOf(0, i)))\n            : x.toString('utf8', i, i = x.indexOf(0, i)),\n          type: x.readUInt32BE(i += 1),\n          parser: parsers[x.readUInt32BE(i)],\n          atttypmod: x.readUInt32BE(i += 4)\n        }\n\n        column.key && r.keys.push(column)\n        i += 4\n      }\n    },\n    Y: () => { /* noop */ }, // Type\n    O: () => { /* noop */ }, // Origin\n    B: x => { // Begin\n      state.date = Time(x.readBigInt64BE(9))\n      state.lsn = x.subarray(1, 9)\n    },\n    I: x => { // Insert\n      let i = 1\n      const relation = state[x.readUInt32BE(i)]\n      const { row } = tuples(x, relation.columns, i += 7, transform)\n\n      handle(row, {\n        command: 'insert',\n        relation\n      })\n    },\n    D: x => { // Delete\n      let i = 1\n      const relation = state[x.readUInt32BE(i)]\n      i += 4\n      const key = x[i] === 75\n      handle(key || x[i] === 79\n        ? tuples(x, relation.columns, i += 3, transform).row\n        : null\n      , {\n        command: 'delete',\n        relation,\n        key\n      })\n    },\n    U: x => { // Update\n      let i = 1\n      const relation = state[x.readUInt32BE(i)]\n      i += 4\n      const key = x[i] === 75\n      const xs = key || x[i] === 79\n        ? tuples(x, relation.columns, i += 3, transform)\n        : null\n\n      xs && (i = xs.i)\n\n      const { row } = tuples(x, relation.columns, i + 3, transform)\n\n      handle(row, {\n        command: 'update',\n        relation,\n        key,\n        old: xs && xs.row\n      })\n    },\n    T: () => { /* noop */ }, // Truncate,\n    C: () => { /* noop */ }  // Commit\n  }).reduce(char, {})[x[0]](x)\n}\n\nfunction tuples(x, columns, xi, transform) {\n  let type\n    , column\n    , value\n\n  const row = transform.raw ? new Array(columns.length) : {}\n  for (let i = 0; i < columns.length; i++) {\n    type = x[xi++]\n    column = columns[i]\n    value = type === 110 // n\n      ? null\n      : type === 117 // u\n        ? undefined\n        : column.parser === undefined\n          ? x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi))\n          : column.parser.array === true\n            ? column.parser(x.toString('utf8', xi + 5, xi += 4 + x.readUInt32BE(xi)))\n            : column.parser(x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi)))\n\n    transform.raw\n      ? (row[i] = transform.raw === true\n        ? value\n        : transform.value.from ? transform.value.from(value, column) : value)\n      : (row[column.name] = transform.value.from\n        ? transform.value.from(value, column)\n        : value\n      )\n  }\n\n  return { i: xi, row: transform.row.from ? transform.row.from(row) : row }\n}\n\nfunction parseEvent(x) {\n  const xs = x.match(/^(\\*|insert|update|delete)?:?([^.]+?\\.?[^=]+)?=?(.+)?/i) || []\n\n  if (!xs)\n    throw new Error('Malformed subscribe pattern: ' + x)\n\n  const [, command, path, key] = xs\n\n  return (command || '*')\n       + (path ? ':' + (path.indexOf('.') === -1 ? 'public.' + path : path) : '')\n       + (key ? '=' + key : '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3N1YnNjcmliZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEscUJBQXFCOztBQUVOO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsV0FBVyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0EsUUFBUSwwQ0FBMEMsY0FBYztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLFlBQVk7QUFDM0IsZUFBZSxZQUFZO0FBQzNCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYyxNQUFNOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxNQUFNOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxlQUFlLFlBQVk7QUFDM0IsZUFBZSxjQUFjO0FBQzdCLEdBQUcsaUJBQWlCO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvc3Vic2NyaWJlLmpzP2Q3ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgbm9vcCA9ICgpID0+IHsgLyogbm9vcCAqLyB9XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN1YnNjcmliZShwb3N0Z3Jlcywgb3B0aW9ucykge1xuICBjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBNYXAoKVxuICAgICAgLCBzbG90ID0gJ3Bvc3RncmVzanNfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpXG4gICAgICAsIHN0YXRlID0ge31cblxuICBsZXQgY29ubmVjdGlvblxuICAgICwgc3RyZWFtXG4gICAgLCBlbmRlZCA9IGZhbHNlXG5cbiAgY29uc3Qgc3FsID0gc3Vic2NyaWJlLnNxbCA9IHBvc3RncmVzKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRyYW5zZm9ybTogeyBjb2x1bW46IHt9LCB2YWx1ZToge30sIHJvdzoge30gfSxcbiAgICBtYXg6IDEsXG4gICAgZmV0Y2hfdHlwZXM6IGZhbHNlLFxuICAgIGlkbGVfdGltZW91dDogbnVsbCxcbiAgICBtYXhfbGlmZXRpbWU6IG51bGwsXG4gICAgY29ubmVjdGlvbjoge1xuICAgICAgLi4ub3B0aW9ucy5jb25uZWN0aW9uLFxuICAgICAgcmVwbGljYXRpb246ICdkYXRhYmFzZSdcbiAgICB9LFxuICAgIG9uY2xvc2U6IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVuZGVkKVxuICAgICAgICByZXR1cm5cbiAgICAgIHN0cmVhbSA9IG51bGxcbiAgICAgIHN0YXRlLnBpZCA9IHN0YXRlLnNlY3JldCA9IHVuZGVmaW5lZFxuICAgICAgY29ubmVjdGVkKGF3YWl0IGluaXQoc3FsLCBzbG90LCBvcHRpb25zLnB1YmxpY2F0aW9ucykpXG4gICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGV2ZW50ID0+IGV2ZW50LmZvckVhY2goKHsgb25zdWJzY3JpYmUgfSkgPT4gb25zdWJzY3JpYmUoKSkpXG4gICAgfSxcbiAgICBub19zdWJzY3JpYmU6IHRydWVcbiAgfSlcblxuICBjb25zdCBlbmQgPSBzcWwuZW5kXG4gICAgICAsIGNsb3NlID0gc3FsLmNsb3NlXG5cbiAgc3FsLmVuZCA9IGFzeW5jKCkgPT4ge1xuICAgIGVuZGVkID0gdHJ1ZVxuICAgIHN0cmVhbSAmJiAoYXdhaXQgbmV3IFByb21pc2UociA9PiAoc3RyZWFtLm9uY2UoJ2Nsb3NlJywgciksIHN0cmVhbS5lbmQoKSkpKVxuICAgIHJldHVybiBlbmQoKVxuICB9XG5cbiAgc3FsLmNsb3NlID0gYXN5bmMoKSA9PiB7XG4gICAgc3RyZWFtICYmIChhd2FpdCBuZXcgUHJvbWlzZShyID0+IChzdHJlYW0ub25jZSgnY2xvc2UnLCByKSwgc3RyZWFtLmVuZCgpKSkpXG4gICAgcmV0dXJuIGNsb3NlKClcbiAgfVxuXG4gIHJldHVybiBzdWJzY3JpYmVcblxuICBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmUoZXZlbnQsIGZuLCBvbnN1YnNjcmliZSA9IG5vb3ApIHtcbiAgICBldmVudCA9IHBhcnNlRXZlbnQoZXZlbnQpXG5cbiAgICBpZiAoIWNvbm5lY3Rpb24pXG4gICAgICBjb25uZWN0aW9uID0gaW5pdChzcWwsIHNsb3QsIG9wdGlvbnMucHVibGljYXRpb25zKVxuXG4gICAgY29uc3Qgc3Vic2NyaWJlciA9IHsgZm4sIG9uc3Vic2NyaWJlIH1cbiAgICBjb25zdCBmbnMgPSBzdWJzY3JpYmVycy5oYXMoZXZlbnQpXG4gICAgICA/IHN1YnNjcmliZXJzLmdldChldmVudCkuYWRkKHN1YnNjcmliZXIpXG4gICAgICA6IHN1YnNjcmliZXJzLnNldChldmVudCwgbmV3IFNldChbc3Vic2NyaWJlcl0pKS5nZXQoZXZlbnQpXG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgIGZucy5kZWxldGUoc3Vic2NyaWJlcilcbiAgICAgIGZucy5zaXplID09PSAwICYmIHN1YnNjcmliZXJzLmRlbGV0ZShldmVudClcbiAgICB9XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbi50aGVuKHggPT4ge1xuICAgICAgY29ubmVjdGVkKHgpXG4gICAgICBvbnN1YnNjcmliZSgpXG4gICAgICByZXR1cm4geyB1bnN1YnNjcmliZSwgc3RhdGUsIHNxbCB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbm5lY3RlZCh4KSB7XG4gICAgc3RyZWFtID0geC5zdHJlYW1cbiAgICBzdGF0ZS5waWQgPSB4LnN0YXRlLnBpZFxuICAgIHN0YXRlLnNlY3JldCA9IHguc3RhdGUuc2VjcmV0XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBpbml0KHNxbCwgc2xvdCwgcHVibGljYXRpb25zKSB7XG4gICAgaWYgKCFwdWJsaWNhdGlvbnMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHVibGljYXRpb24gbmFtZXMnKVxuXG4gICAgY29uc3QgeHMgPSBhd2FpdCBzcWwudW5zYWZlKFxuICAgICAgYENSRUFURV9SRVBMSUNBVElPTl9TTE9UICR7IHNsb3QgfSBURU1QT1JBUlkgTE9HSUNBTCBwZ291dHB1dCBOT0VYUE9SVF9TTkFQU0hPVGBcbiAgICApXG5cbiAgICBjb25zdCBbeF0gPSB4c1xuXG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgc3FsLnVuc2FmZShcbiAgICAgIGBTVEFSVF9SRVBMSUNBVElPTiBTTE9UICR7IHNsb3QgfSBMT0dJQ0FMICR7XG4gICAgICAgIHguY29uc2lzdGVudF9wb2ludFxuICAgICAgfSAocHJvdG9fdmVyc2lvbiAnMScsIHB1YmxpY2F0aW9uX25hbWVzICckeyBwdWJsaWNhdGlvbnMgfScpYFxuICAgICkud3JpdGFibGUoKVxuXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICBsc246IEJ1ZmZlci5jb25jYXQoeC5jb25zaXN0ZW50X3BvaW50LnNwbGl0KCcvJykubWFwKHggPT4gQnVmZmVyLmZyb20oKCcwMDAwMDAwMCcgKyB4KS5zbGljZSgtOCksICdoZXgnKSkpXG4gICAgfVxuXG4gICAgc3RyZWFtLm9uKCdkYXRhJywgZGF0YSlcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgZXJyb3IpXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIHNxbC5jbG9zZSlcblxuICAgIHJldHVybiB7IHN0cmVhbSwgc3RhdGU6IHhzLnN0YXRlIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGxvZ2ljYWwgc3RyZWFtaW5nIC0gcmVjb25uZWN0aW5nJywgZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRhKHgpIHtcbiAgICAgIGlmICh4WzBdID09PSAweDc3KVxuICAgICAgICBwYXJzZSh4LnN1YmFycmF5KDI1KSwgc3RhdGUsIHNxbC5vcHRpb25zLnBhcnNlcnMsIGhhbmRsZSwgb3B0aW9ucy50cmFuc2Zvcm0pXG4gICAgICBlbHNlIGlmICh4WzBdID09PSAweDZiICYmIHhbMTddKVxuICAgICAgICBwb25nKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGUoYSwgYikge1xuICAgICAgY29uc3QgcGF0aCA9IGIucmVsYXRpb24uc2NoZW1hICsgJy4nICsgYi5yZWxhdGlvbi50YWJsZVxuICAgICAgY2FsbCgnKicsIGEsIGIpXG4gICAgICBjYWxsKCcqOicgKyBwYXRoLCBhLCBiKVxuICAgICAgYi5yZWxhdGlvbi5rZXlzLmxlbmd0aCAmJiBjYWxsKCcqOicgKyBwYXRoICsgJz0nICsgYi5yZWxhdGlvbi5rZXlzLm1hcCh4ID0+IGFbeC5uYW1lXSksIGEsIGIpXG4gICAgICBjYWxsKGIuY29tbWFuZCwgYSwgYilcbiAgICAgIGNhbGwoYi5jb21tYW5kICsgJzonICsgcGF0aCwgYSwgYilcbiAgICAgIGIucmVsYXRpb24ua2V5cy5sZW5ndGggJiYgY2FsbChiLmNvbW1hbmQgKyAnOicgKyBwYXRoICsgJz0nICsgYi5yZWxhdGlvbi5rZXlzLm1hcCh4ID0+IGFbeC5uYW1lXSksIGEsIGIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9uZygpIHtcbiAgICAgIGNvbnN0IHggPSBCdWZmZXIuYWxsb2MoMzQpXG4gICAgICB4WzBdID0gJ3InLmNoYXJDb2RlQXQoMClcbiAgICAgIHguZmlsbChzdGF0ZS5sc24sIDEpXG4gICAgICB4LndyaXRlQmlnSW50NjRCRShCaWdJbnQoRGF0ZS5ub3coKSAtIERhdGUuVVRDKDIwMDAsIDAsIDEpKSAqIEJpZ0ludCgxMDAwKSwgMjUpXG4gICAgICBzdHJlYW0ud3JpdGUoeClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsKHgsIGEsIGIpIHtcbiAgICBzdWJzY3JpYmVycy5oYXMoeCkgJiYgc3Vic2NyaWJlcnMuZ2V0KHgpLmZvckVhY2goKHsgZm4gfSkgPT4gZm4oYSwgYiwgeCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gVGltZSh4KSB7XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygyMDAwLCAwLCAxKSArIE51bWJlcih4IC8gQmlnSW50KDEwMDApKSlcbn1cblxuZnVuY3Rpb24gcGFyc2UoeCwgc3RhdGUsIHBhcnNlcnMsIGhhbmRsZSwgdHJhbnNmb3JtKSB7XG4gIGNvbnN0IGNoYXIgPSAoYWNjLCBbaywgdl0pID0+IChhY2Nbay5jaGFyQ29kZUF0KDApXSA9IHYsIGFjYylcblxuICBPYmplY3QuZW50cmllcyh7XG4gICAgUjogeCA9PiB7ICAvLyBSZWxhdGlvblxuICAgICAgbGV0IGkgPSAxXG4gICAgICBjb25zdCByID0gc3RhdGVbeC5yZWFkVUludDMyQkUoaSldID0ge1xuICAgICAgICBzY2hlbWE6IHgudG9TdHJpbmcoJ3V0ZjgnLCBpICs9IDQsIGkgPSB4LmluZGV4T2YoMCwgaSkpIHx8ICdwZ19jYXRhbG9nJyxcbiAgICAgICAgdGFibGU6IHgudG9TdHJpbmcoJ3V0ZjgnLCBpICsgMSwgaSA9IHguaW5kZXhPZigwLCBpICsgMSkpLFxuICAgICAgICBjb2x1bW5zOiBBcnJheSh4LnJlYWRVSW50MTZCRShpICs9IDIpKSxcbiAgICAgICAga2V5czogW11cbiAgICAgIH1cbiAgICAgIGkgKz0gMlxuXG4gICAgICBsZXQgY29sdW1uSW5kZXggPSAwXG4gICAgICAgICwgY29sdW1uXG5cbiAgICAgIHdoaWxlIChpIDwgeC5sZW5ndGgpIHtcbiAgICAgICAgY29sdW1uID0gci5jb2x1bW5zW2NvbHVtbkluZGV4KytdID0ge1xuICAgICAgICAgIGtleTogeFtpKytdLFxuICAgICAgICAgIG5hbWU6IHRyYW5zZm9ybS5jb2x1bW4uZnJvbVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm0uY29sdW1uLmZyb20oeC50b1N0cmluZygndXRmOCcsIGksIGkgPSB4LmluZGV4T2YoMCwgaSkpKVxuICAgICAgICAgICAgOiB4LnRvU3RyaW5nKCd1dGY4JywgaSwgaSA9IHguaW5kZXhPZigwLCBpKSksXG4gICAgICAgICAgdHlwZTogeC5yZWFkVUludDMyQkUoaSArPSAxKSxcbiAgICAgICAgICBwYXJzZXI6IHBhcnNlcnNbeC5yZWFkVUludDMyQkUoaSldLFxuICAgICAgICAgIGF0dHR5cG1vZDogeC5yZWFkVUludDMyQkUoaSArPSA0KVxuICAgICAgICB9XG5cbiAgICAgICAgY29sdW1uLmtleSAmJiByLmtleXMucHVzaChjb2x1bW4pXG4gICAgICAgIGkgKz0gNFxuICAgICAgfVxuICAgIH0sXG4gICAgWTogKCkgPT4geyAvKiBub29wICovIH0sIC8vIFR5cGVcbiAgICBPOiAoKSA9PiB7IC8qIG5vb3AgKi8gfSwgLy8gT3JpZ2luXG4gICAgQjogeCA9PiB7IC8vIEJlZ2luXG4gICAgICBzdGF0ZS5kYXRlID0gVGltZSh4LnJlYWRCaWdJbnQ2NEJFKDkpKVxuICAgICAgc3RhdGUubHNuID0geC5zdWJhcnJheSgxLCA5KVxuICAgIH0sXG4gICAgSTogeCA9PiB7IC8vIEluc2VydFxuICAgICAgbGV0IGkgPSAxXG4gICAgICBjb25zdCByZWxhdGlvbiA9IHN0YXRlW3gucmVhZFVJbnQzMkJFKGkpXVxuICAgICAgY29uc3QgeyByb3cgfSA9IHR1cGxlcyh4LCByZWxhdGlvbi5jb2x1bW5zLCBpICs9IDcsIHRyYW5zZm9ybSlcblxuICAgICAgaGFuZGxlKHJvdywge1xuICAgICAgICBjb21tYW5kOiAnaW5zZXJ0JyxcbiAgICAgICAgcmVsYXRpb25cbiAgICAgIH0pXG4gICAgfSxcbiAgICBEOiB4ID0+IHsgLy8gRGVsZXRlXG4gICAgICBsZXQgaSA9IDFcbiAgICAgIGNvbnN0IHJlbGF0aW9uID0gc3RhdGVbeC5yZWFkVUludDMyQkUoaSldXG4gICAgICBpICs9IDRcbiAgICAgIGNvbnN0IGtleSA9IHhbaV0gPT09IDc1XG4gICAgICBoYW5kbGUoa2V5IHx8IHhbaV0gPT09IDc5XG4gICAgICAgID8gdHVwbGVzKHgsIHJlbGF0aW9uLmNvbHVtbnMsIGkgKz0gMywgdHJhbnNmb3JtKS5yb3dcbiAgICAgICAgOiBudWxsXG4gICAgICAsIHtcbiAgICAgICAgY29tbWFuZDogJ2RlbGV0ZScsXG4gICAgICAgIHJlbGF0aW9uLFxuICAgICAgICBrZXlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBVOiB4ID0+IHsgLy8gVXBkYXRlXG4gICAgICBsZXQgaSA9IDFcbiAgICAgIGNvbnN0IHJlbGF0aW9uID0gc3RhdGVbeC5yZWFkVUludDMyQkUoaSldXG4gICAgICBpICs9IDRcbiAgICAgIGNvbnN0IGtleSA9IHhbaV0gPT09IDc1XG4gICAgICBjb25zdCB4cyA9IGtleSB8fCB4W2ldID09PSA3OVxuICAgICAgICA/IHR1cGxlcyh4LCByZWxhdGlvbi5jb2x1bW5zLCBpICs9IDMsIHRyYW5zZm9ybSlcbiAgICAgICAgOiBudWxsXG5cbiAgICAgIHhzICYmIChpID0geHMuaSlcblxuICAgICAgY29uc3QgeyByb3cgfSA9IHR1cGxlcyh4LCByZWxhdGlvbi5jb2x1bW5zLCBpICsgMywgdHJhbnNmb3JtKVxuXG4gICAgICBoYW5kbGUocm93LCB7XG4gICAgICAgIGNvbW1hbmQ6ICd1cGRhdGUnLFxuICAgICAgICByZWxhdGlvbixcbiAgICAgICAga2V5LFxuICAgICAgICBvbGQ6IHhzICYmIHhzLnJvd1xuICAgICAgfSlcbiAgICB9LFxuICAgIFQ6ICgpID0+IHsgLyogbm9vcCAqLyB9LCAvLyBUcnVuY2F0ZSxcbiAgICBDOiAoKSA9PiB7IC8qIG5vb3AgKi8gfSAgLy8gQ29tbWl0XG4gIH0pLnJlZHVjZShjaGFyLCB7fSlbeFswXV0oeClcbn1cblxuZnVuY3Rpb24gdHVwbGVzKHgsIGNvbHVtbnMsIHhpLCB0cmFuc2Zvcm0pIHtcbiAgbGV0IHR5cGVcbiAgICAsIGNvbHVtblxuICAgICwgdmFsdWVcblxuICBjb25zdCByb3cgPSB0cmFuc2Zvcm0ucmF3ID8gbmV3IEFycmF5KGNvbHVtbnMubGVuZ3RoKSA6IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHR5cGUgPSB4W3hpKytdXG4gICAgY29sdW1uID0gY29sdW1uc1tpXVxuICAgIHZhbHVlID0gdHlwZSA9PT0gMTEwIC8vIG5cbiAgICAgID8gbnVsbFxuICAgICAgOiB0eXBlID09PSAxMTcgLy8gdVxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGNvbHVtbi5wYXJzZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8geC50b1N0cmluZygndXRmOCcsIHhpICsgNCwgeGkgKz0gNCArIHgucmVhZFVJbnQzMkJFKHhpKSlcbiAgICAgICAgICA6IGNvbHVtbi5wYXJzZXIuYXJyYXkgPT09IHRydWVcbiAgICAgICAgICAgID8gY29sdW1uLnBhcnNlcih4LnRvU3RyaW5nKCd1dGY4JywgeGkgKyA1LCB4aSArPSA0ICsgeC5yZWFkVUludDMyQkUoeGkpKSlcbiAgICAgICAgICAgIDogY29sdW1uLnBhcnNlcih4LnRvU3RyaW5nKCd1dGY4JywgeGkgKyA0LCB4aSArPSA0ICsgeC5yZWFkVUludDMyQkUoeGkpKSlcblxuICAgIHRyYW5zZm9ybS5yYXdcbiAgICAgID8gKHJvd1tpXSA9IHRyYW5zZm9ybS5yYXcgPT09IHRydWVcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHRyYW5zZm9ybS52YWx1ZS5mcm9tID8gdHJhbnNmb3JtLnZhbHVlLmZyb20odmFsdWUsIGNvbHVtbikgOiB2YWx1ZSlcbiAgICAgIDogKHJvd1tjb2x1bW4ubmFtZV0gPSB0cmFuc2Zvcm0udmFsdWUuZnJvbVxuICAgICAgICA/IHRyYW5zZm9ybS52YWx1ZS5mcm9tKHZhbHVlLCBjb2x1bW4pXG4gICAgICAgIDogdmFsdWVcbiAgICAgIClcbiAgfVxuXG4gIHJldHVybiB7IGk6IHhpLCByb3c6IHRyYW5zZm9ybS5yb3cuZnJvbSA/IHRyYW5zZm9ybS5yb3cuZnJvbShyb3cpIDogcm93IH1cbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudCh4KSB7XG4gIGNvbnN0IHhzID0geC5tYXRjaCgvXihcXCp8aW5zZXJ0fHVwZGF0ZXxkZWxldGUpPzo/KFteLl0rP1xcLj9bXj1dKyk/PT8oLispPy9pKSB8fCBbXVxuXG4gIGlmICgheHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgc3Vic2NyaWJlIHBhdHRlcm46ICcgKyB4KVxuXG4gIGNvbnN0IFssIGNvbW1hbmQsIHBhdGgsIGtleV0gPSB4c1xuXG4gIHJldHVybiAoY29tbWFuZCB8fCAnKicpXG4gICAgICAgKyAocGF0aCA/ICc6JyArIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyAncHVibGljLicgKyBwYXRoIDogcGF0aCkgOiAnJylcbiAgICAgICArIChrZXkgPyAnPScgKyBrZXkgOiAnJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/subscribe.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/postgres/src/types.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/types.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Builder: () => (/* binding */ Builder),\n/* harmony export */   END: () => (/* binding */ END),\n/* harmony export */   Identifier: () => (/* binding */ Identifier),\n/* harmony export */   Parameter: () => (/* binding */ Parameter),\n/* harmony export */   arrayParser: () => (/* binding */ arrayParser),\n/* harmony export */   arraySerializer: () => (/* binding */ arraySerializer),\n/* harmony export */   camel: () => (/* binding */ camel),\n/* harmony export */   escapeIdentifier: () => (/* binding */ escapeIdentifier),\n/* harmony export */   fromCamel: () => (/* binding */ fromCamel),\n/* harmony export */   fromKebab: () => (/* binding */ fromKebab),\n/* harmony export */   fromPascal: () => (/* binding */ fromPascal),\n/* harmony export */   handleValue: () => (/* binding */ handleValue),\n/* harmony export */   inferType: () => (/* binding */ inferType),\n/* harmony export */   kebab: () => (/* binding */ kebab),\n/* harmony export */   mergeUserTypes: () => (/* binding */ mergeUserTypes),\n/* harmony export */   parsers: () => (/* binding */ parsers),\n/* harmony export */   pascal: () => (/* binding */ pascal),\n/* harmony export */   serializers: () => (/* binding */ serializers),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   toCamel: () => (/* binding */ toCamel),\n/* harmony export */   toKebab: () => (/* binding */ toKebab),\n/* harmony export */   toPascal: () => (/* binding */ toPascal),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./query.js */ \"(action-browser)/./node_modules/postgres/src/query.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(action-browser)/./node_modules/postgres/src/errors.js\");\n\n\n\nconst types = {\n  string: {\n    to: 25,\n    from: null,             // defaults to string\n    serialize: x => '' + x\n  },\n  number: {\n    to: 0,\n    from: [21, 23, 26, 700, 701],\n    serialize: x => '' + x,\n    parse: x => +x\n  },\n  json: {\n    to: 114,\n    from: [114, 3802],\n    serialize: x => JSON.stringify(x),\n    parse: x => JSON.parse(x)\n  },\n  boolean: {\n    to: 16,\n    from: 16,\n    serialize: x => x === true ? 't' : 'f',\n    parse: x => x === 't'\n  },\n  date: {\n    to: 1184,\n    from: [1082, 1114, 1184],\n    serialize: x => (x instanceof Date ? x : new Date(x)).toISOString(),\n    parse: x => new Date(x)\n  },\n  bytea: {\n    to: 17,\n    from: 17,\n    serialize: x => '\\\\x' + Buffer.from(x).toString('hex'),\n    parse: x => Buffer.from(x.slice(2), 'hex')\n  }\n}\n\nclass NotTagged { then() { notTagged() } catch() { notTagged() } finally() { notTagged() }}\n\nclass Identifier extends NotTagged {\n  constructor(value) {\n    super()\n    this.value = escapeIdentifier(value)\n  }\n}\n\nclass Parameter extends NotTagged {\n  constructor(value, type, array) {\n    super()\n    this.value = value\n    this.type = type\n    this.array = array\n  }\n}\n\nclass Builder extends NotTagged {\n  constructor(first, rest) {\n    super()\n    this.first = first\n    this.rest = rest\n  }\n\n  build(before, parameters, types, options) {\n    const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a, b) => a.i - b.i).pop()\n    return keyword.i === -1\n      ? escapeIdentifiers(this.first, options)\n      : keyword.fn(this.first, this.rest, parameters, types, options)\n  }\n}\n\nfunction handleValue(x, parameters, types, options) {\n  let value = x instanceof Parameter ? x.value : x\n  if (value === undefined) {\n    x instanceof Parameter\n      ? x.value = options.transform.undefined\n      : value = x = options.transform.undefined\n\n    if (value === undefined)\n      throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed')\n  }\n\n  return '$' + (types.push(\n    x instanceof Parameter\n      ? (parameters.push(x.value), x.array\n        ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value)\n        : x.type\n      )\n      : (parameters.push(x), inferType(x))\n  ))\n}\n\nconst defaultHandlers = typeHandlers(types)\n\nfunction stringify(q, string, value, parameters, types, options) { // eslint-disable-line\n  for (let i = 1; i < q.strings.length; i++) {\n    string += (stringifyValue(string, value, parameters, types, options)) + q.strings[i]\n    value = q.args[i]\n  }\n\n  return string\n}\n\nfunction stringifyValue(string, value, parameters, types, o) {\n  return (\n    value instanceof Builder ? value.build(string, parameters, types, o) :\n    value instanceof _query_js__WEBPACK_IMPORTED_MODULE_0__.Query ? fragment(value, parameters, types, o) :\n    value instanceof Identifier ? value.value :\n    value && value[0] instanceof _query_js__WEBPACK_IMPORTED_MODULE_0__.Query ? value.reduce((acc, x) => acc + ' ' + fragment(x, parameters, types, o), '') :\n    handleValue(value, parameters, types, o)\n  )\n}\n\nfunction fragment(q, parameters, types, options) {\n  q.fragment = true\n  return stringify(q, q.strings[0], q.args[0], parameters, types, options)\n}\n\nfunction valuesBuilder(first, parameters, types, columns, options) {\n  return first.map(row =>\n    '(' + columns.map(column =>\n      stringifyValue('values', row[column], parameters, types, options)\n    ).join(',') + ')'\n  ).join(',')\n}\n\nfunction values(first, rest, parameters, types, options) {\n  const multi = Array.isArray(first[0])\n  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first)\n  return valuesBuilder(multi ? first : [first], parameters, types, columns, options)\n}\n\nfunction select(first, rest, parameters, types, options) {\n  typeof first === 'string' && (first = [first].concat(rest))\n  if (Array.isArray(first))\n    return escapeIdentifiers(first, options)\n\n  let value\n  const columns = rest.length ? rest.flat() : Object.keys(first)\n  return columns.map(x => {\n    value = first[x]\n    return (\n      value instanceof _query_js__WEBPACK_IMPORTED_MODULE_0__.Query ? fragment(value, parameters, types, options) :\n      value instanceof Identifier ? value.value :\n      handleValue(value, parameters, types, options)\n    ) + ' as ' + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)\n  }).join(',')\n}\n\nconst builders = Object.entries({\n  values,\n  in: (...xs) => {\n    const x = values(...xs)\n    return x === '()' ? '(null)' : x\n  },\n  select,\n  as: select,\n  returning: select,\n  '\\\\(': select,\n\n  update(first, rest, parameters, types, options) {\n    return (rest.length ? rest.flat() : Object.keys(first)).map(x =>\n      escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) +\n      '=' + stringifyValue('values', first[x], parameters, types, options)\n    )\n  },\n\n  insert(first, rest, parameters, types, options) {\n    const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first)\n    return '(' + escapeIdentifiers(columns, options) + ')values' +\n    valuesBuilder(Array.isArray(first) ? first : [first], parameters, types, columns, options)\n  }\n}).map(([x, fn]) => ([new RegExp('((?:^|[\\\\s(])' + x + '(?:$|[\\\\s(]))(?![\\\\s\\\\S]*\\\\1)', 'i'), fn]))\n\nfunction notTagged() {\n  throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.Errors.generic('NOT_TAGGED_CALL', 'Query not called as a tagged template literal')\n}\n\nconst serializers = defaultHandlers.serializers\nconst parsers = defaultHandlers.parsers\n\nconst END = {}\n\nfunction firstIsString(x) {\n  if (Array.isArray(x))\n    return firstIsString(x[0])\n  return typeof x === 'string' ? 1009 : 0\n}\n\nconst mergeUserTypes = function(types) {\n  const user = typeHandlers(types || {})\n  return {\n    serializers: Object.assign({}, serializers, user.serializers),\n    parsers: Object.assign({}, parsers, user.parsers)\n  }\n}\n\nfunction typeHandlers(types) {\n  return Object.keys(types).reduce((acc, k) => {\n    types[k].from && [].concat(types[k].from).forEach(x => acc.parsers[x] = types[k].parse)\n    if (types[k].serialize) {\n      acc.serializers[types[k].to] = types[k].serialize\n      types[k].from && [].concat(types[k].from).forEach(x => acc.serializers[x] = types[k].serialize)\n    }\n    return acc\n  }, { parsers: {}, serializers: {} })\n}\n\nfunction escapeIdentifiers(xs, { transform: { column } }) {\n  return xs.map(x => escapeIdentifier(column.to ? column.to(x) : x)).join(',')\n}\n\nconst escapeIdentifier = function escape(str) {\n  return '\"' + str.replace(/\"/g, '\"\"').replace(/\\./g, '\".\"') + '\"'\n}\n\nconst inferType = function inferType(x) {\n  return (\n    x instanceof Parameter ? x.type :\n    x instanceof Date ? 1184 :\n    x instanceof Uint8Array ? 17 :\n    (x === true || x === false) ? 16 :\n    typeof x === 'bigint' ? 20 :\n    Array.isArray(x) ? inferType(x[0]) :\n    0\n  )\n}\n\nconst escapeBackslash = /\\\\/g\nconst escapeQuote = /\"/g\n\nfunction arrayEscape(x) {\n  return x\n    .replace(escapeBackslash, '\\\\\\\\')\n    .replace(escapeQuote, '\\\\\"')\n}\n\nconst arraySerializer = function arraySerializer(xs, serializer, options, typarray) {\n  if (Array.isArray(xs) === false)\n    return xs\n\n  if (!xs.length)\n    return '{}'\n\n  const first = xs[0]\n  // Only _box (1020) has the ';' delimiter for arrays, all other types use the ',' delimiter\n  const delimiter = typarray === 1020 ? ';' : ','\n\n  if (Array.isArray(first) && !first.type)\n    return '{' + xs.map(x => arraySerializer(x, serializer, options, typarray)).join(delimiter) + '}'\n\n  return '{' + xs.map(x => {\n    if (x === undefined) {\n      x = options.transform.undefined\n      if (x === undefined)\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed')\n    }\n\n    return x === null\n      ? 'null'\n      : '\"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : '' + x) + '\"'\n  }).join(delimiter) + '}'\n}\n\nconst arrayParserState = {\n  i: 0,\n  char: null,\n  str: '',\n  quoted: false,\n  last: 0\n}\n\nconst arrayParser = function arrayParser(x, parser, typarray) {\n  arrayParserState.i = arrayParserState.last = 0\n  return arrayParserLoop(arrayParserState, x, parser, typarray)\n}\n\nfunction arrayParserLoop(s, x, parser, typarray) {\n  const xs = []\n  // Only _box (1020) has the ';' delimiter for arrays, all other types use the ',' delimiter\n  const delimiter = typarray === 1020 ? ';' : ','\n  for (; s.i < x.length; s.i++) {\n    s.char = x[s.i]\n    if (s.quoted) {\n      if (s.char === '\\\\') {\n        s.str += x[++s.i]\n      } else if (s.char === '\"') {\n        xs.push(parser ? parser(s.str) : s.str)\n        s.str = ''\n        s.quoted = x[s.i + 1] === '\"'\n        s.last = s.i + 2\n      } else {\n        s.str += s.char\n      }\n    } else if (s.char === '\"') {\n      s.quoted = true\n    } else if (s.char === '{') {\n      s.last = ++s.i\n      xs.push(arrayParserLoop(s, x, parser, typarray))\n    } else if (s.char === '}') {\n      s.quoted = false\n      s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i))\n      s.last = s.i + 1\n      break\n    } else if (s.char === delimiter && s.p !== '}' && s.p !== '\"') {\n      xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i))\n      s.last = s.i + 1\n    }\n    s.p = s.char\n  }\n  s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1))\n  return xs\n}\n\nconst toCamel = x => {\n  let str = x[0]\n  for (let i = 1; i < x.length; i++)\n    str += x[i] === '_' ? x[++i].toUpperCase() : x[i]\n  return str\n}\n\nconst toPascal = x => {\n  let str = x[0].toUpperCase()\n  for (let i = 1; i < x.length; i++)\n    str += x[i] === '_' ? x[++i].toUpperCase() : x[i]\n  return str\n}\n\nconst toKebab = x => x.replace(/_/g, '-')\n\nconst fromCamel = x => x.replace(/([A-Z])/g, '_$1').toLowerCase()\nconst fromPascal = x => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, '_$1')).toLowerCase()\nconst fromKebab = x => x.replace(/-/g, '_')\n\nfunction createJsonTransform(fn) {\n  return function jsonTransform(x, column) {\n    return typeof x === 'object' && x !== null && (column.type === 114 || column.type === 3802)\n      ? Array.isArray(x)\n        ? x.map(x => jsonTransform(x, column))\n        : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column) }), {})\n      : x\n  }\n}\n\ntoCamel.column = { from: toCamel }\ntoCamel.value = { from: createJsonTransform(toCamel) }\nfromCamel.column = { to: fromCamel }\n\nconst camel = { ...toCamel }\ncamel.column.to = fromCamel\n\ntoPascal.column = { from: toPascal }\ntoPascal.value = { from: createJsonTransform(toPascal) }\nfromPascal.column = { to: fromPascal }\n\nconst pascal = { ...toPascal }\npascal.column.to = fromPascal\n\ntoKebab.column = { from: toKebab }\ntoKebab.value = { from: createJsonTransform(toKebab) }\nfromKebab.column = { to: fromKebab }\n\nconst kebab = { ...toKebab }\nkebab.column.to = fromKebab\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNFOztBQUU3QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVMsY0FBYyxVQUFVLGNBQWMsWUFBWTs7QUFFdEU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksOENBQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPLG1FQUFtRTtBQUMxRSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBSztBQUMxQjtBQUNBLGlDQUFpQyw0Q0FBSztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsUUFBUSw4Q0FBTTtBQUNkOztBQUVPO0FBQ0E7O0FBRUE7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHVDQUF1QztBQUN2QztBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJLFdBQVcsbUJBQW1CO0FBQ3JDOztBQUVBLGlDQUFpQyxhQUFhLFVBQVU7QUFDeEQ7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBLGdDQUFnQztBQUNoQywwQ0FBMEM7O0FBRTFDO0FBQ0EsYUFBYSx1RkFBdUY7O0FBRXBHLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhDQUFNO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0JBQXNCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMENBQTBDO0FBQzFDLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNLHNCQUFzQjtBQUM1QjtBQUNBO0FBQ0EsTUFBTSxzQkFBc0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJDQUEyQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxtQ0FBbUMsS0FBSztBQUNqSDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixxQkFBcUI7O0FBRWQsZ0JBQWdCO0FBQ3ZCOztBQUVBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsc0JBQXNCOztBQUVmLGlCQUFpQjtBQUN4Qjs7QUFFQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHFCQUFxQjs7QUFFZCxnQkFBZ0I7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmVjYXJkLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzL3NyYy90eXBlcy5qcz9hNjEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeS5qcydcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gJy4vZXJyb3JzLmpzJ1xuXG5leHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gIHN0cmluZzoge1xuICAgIHRvOiAyNSxcbiAgICBmcm9tOiBudWxsLCAgICAgICAgICAgICAvLyBkZWZhdWx0cyB0byBzdHJpbmdcbiAgICBzZXJpYWxpemU6IHggPT4gJycgKyB4XG4gIH0sXG4gIG51bWJlcjoge1xuICAgIHRvOiAwLFxuICAgIGZyb206IFsyMSwgMjMsIDI2LCA3MDAsIDcwMV0sXG4gICAgc2VyaWFsaXplOiB4ID0+ICcnICsgeCxcbiAgICBwYXJzZTogeCA9PiAreFxuICB9LFxuICBqc29uOiB7XG4gICAgdG86IDExNCxcbiAgICBmcm9tOiBbMTE0LCAzODAyXSxcbiAgICBzZXJpYWxpemU6IHggPT4gSlNPTi5zdHJpbmdpZnkoeCksXG4gICAgcGFyc2U6IHggPT4gSlNPTi5wYXJzZSh4KVxuICB9LFxuICBib29sZWFuOiB7XG4gICAgdG86IDE2LFxuICAgIGZyb206IDE2LFxuICAgIHNlcmlhbGl6ZTogeCA9PiB4ID09PSB0cnVlID8gJ3QnIDogJ2YnLFxuICAgIHBhcnNlOiB4ID0+IHggPT09ICd0J1xuICB9LFxuICBkYXRlOiB7XG4gICAgdG86IDExODQsXG4gICAgZnJvbTogWzEwODIsIDExMTQsIDExODRdLFxuICAgIHNlcmlhbGl6ZTogeCA9PiAoeCBpbnN0YW5jZW9mIERhdGUgPyB4IDogbmV3IERhdGUoeCkpLnRvSVNPU3RyaW5nKCksXG4gICAgcGFyc2U6IHggPT4gbmV3IERhdGUoeClcbiAgfSxcbiAgYnl0ZWE6IHtcbiAgICB0bzogMTcsXG4gICAgZnJvbTogMTcsXG4gICAgc2VyaWFsaXplOiB4ID0+ICdcXFxceCcgKyBCdWZmZXIuZnJvbSh4KS50b1N0cmluZygnaGV4JyksXG4gICAgcGFyc2U6IHggPT4gQnVmZmVyLmZyb20oeC5zbGljZSgyKSwgJ2hleCcpXG4gIH1cbn1cblxuY2xhc3MgTm90VGFnZ2VkIHsgdGhlbigpIHsgbm90VGFnZ2VkKCkgfSBjYXRjaCgpIHsgbm90VGFnZ2VkKCkgfSBmaW5hbGx5KCkgeyBub3RUYWdnZWQoKSB9fVxuXG5leHBvcnQgY2xhc3MgSWRlbnRpZmllciBleHRlbmRzIE5vdFRhZ2dlZCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudmFsdWUgPSBlc2NhcGVJZGVudGlmaWVyKHZhbHVlKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXIgZXh0ZW5kcyBOb3RUYWdnZWQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSwgYXJyYXkpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMuYXJyYXkgPSBhcnJheVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCdWlsZGVyIGV4dGVuZHMgTm90VGFnZ2VkIHtcbiAgY29uc3RydWN0b3IoZmlyc3QsIHJlc3QpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5maXJzdCA9IGZpcnN0XG4gICAgdGhpcy5yZXN0ID0gcmVzdFxuICB9XG5cbiAgYnVpbGQoYmVmb3JlLCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGtleXdvcmQgPSBidWlsZGVycy5tYXAoKFt4LCBmbl0pID0+ICh7IGZuLCBpOiBiZWZvcmUuc2VhcmNoKHgpIH0pKS5zb3J0KChhLCBiKSA9PiBhLmkgLSBiLmkpLnBvcCgpXG4gICAgcmV0dXJuIGtleXdvcmQuaSA9PT0gLTFcbiAgICAgID8gZXNjYXBlSWRlbnRpZmllcnModGhpcy5maXJzdCwgb3B0aW9ucylcbiAgICAgIDoga2V5d29yZC5mbih0aGlzLmZpcnN0LCB0aGlzLnJlc3QsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVWYWx1ZSh4LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICBsZXQgdmFsdWUgPSB4IGluc3RhbmNlb2YgUGFyYW1ldGVyID8geC52YWx1ZSA6IHhcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB4IGluc3RhbmNlb2YgUGFyYW1ldGVyXG4gICAgICA/IHgudmFsdWUgPSBvcHRpb25zLnRyYW5zZm9ybS51bmRlZmluZWRcbiAgICAgIDogdmFsdWUgPSB4ID0gb3B0aW9ucy50cmFuc2Zvcm0udW5kZWZpbmVkXG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IEVycm9ycy5nZW5lcmljKCdVTkRFRklORURfVkFMVUUnLCAnVW5kZWZpbmVkIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQnKVxuICB9XG5cbiAgcmV0dXJuICckJyArICh0eXBlcy5wdXNoKFxuICAgIHggaW5zdGFuY2VvZiBQYXJhbWV0ZXJcbiAgICAgID8gKHBhcmFtZXRlcnMucHVzaCh4LnZhbHVlKSwgeC5hcnJheVxuICAgICAgICA/IHguYXJyYXlbeC50eXBlIHx8IGluZmVyVHlwZSh4LnZhbHVlKV0gfHwgeC50eXBlIHx8IGZpcnN0SXNTdHJpbmcoeC52YWx1ZSlcbiAgICAgICAgOiB4LnR5cGVcbiAgICAgIClcbiAgICAgIDogKHBhcmFtZXRlcnMucHVzaCh4KSwgaW5mZXJUeXBlKHgpKVxuICApKVxufVxuXG5jb25zdCBkZWZhdWx0SGFuZGxlcnMgPSB0eXBlSGFuZGxlcnModHlwZXMpXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkocSwgc3RyaW5nLCB2YWx1ZSwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHEuc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIHN0cmluZyArPSAoc3RyaW5naWZ5VmFsdWUoc3RyaW5nLCB2YWx1ZSwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpKSArIHEuc3RyaW5nc1tpXVxuICAgIHZhbHVlID0gcS5hcmdzW2ldXG4gIH1cblxuICByZXR1cm4gc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHN0cmluZywgdmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgaW5zdGFuY2VvZiBCdWlsZGVyID8gdmFsdWUuYnVpbGQoc3RyaW5nLCBwYXJhbWV0ZXJzLCB0eXBlcywgbykgOlxuICAgIHZhbHVlIGluc3RhbmNlb2YgUXVlcnkgPyBmcmFnbWVudCh2YWx1ZSwgcGFyYW1ldGVycywgdHlwZXMsIG8pIDpcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIElkZW50aWZpZXIgPyB2YWx1ZS52YWx1ZSA6XG4gICAgdmFsdWUgJiYgdmFsdWVbMF0gaW5zdGFuY2VvZiBRdWVyeSA/IHZhbHVlLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyAnICcgKyBmcmFnbWVudCh4LCBwYXJhbWV0ZXJzLCB0eXBlcywgbyksICcnKSA6XG4gICAgaGFuZGxlVmFsdWUodmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvKVxuICApXG59XG5cbmZ1bmN0aW9uIGZyYWdtZW50KHEsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSB7XG4gIHEuZnJhZ21lbnQgPSB0cnVlXG4gIHJldHVybiBzdHJpbmdpZnkocSwgcS5zdHJpbmdzWzBdLCBxLmFyZ3NbMF0sIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiB2YWx1ZXNCdWlsZGVyKGZpcnN0LCBwYXJhbWV0ZXJzLCB0eXBlcywgY29sdW1ucywgb3B0aW9ucykge1xuICByZXR1cm4gZmlyc3QubWFwKHJvdyA9PlxuICAgICcoJyArIGNvbHVtbnMubWFwKGNvbHVtbiA9PlxuICAgICAgc3RyaW5naWZ5VmFsdWUoJ3ZhbHVlcycsIHJvd1tjb2x1bW5dLCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucylcbiAgICApLmpvaW4oJywnKSArICcpJ1xuICApLmpvaW4oJywnKVxufVxuXG5mdW5jdGlvbiB2YWx1ZXMoZmlyc3QsIHJlc3QsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG11bHRpID0gQXJyYXkuaXNBcnJheShmaXJzdFswXSlcbiAgY29uc3QgY29sdW1ucyA9IHJlc3QubGVuZ3RoID8gcmVzdC5mbGF0KCkgOiBPYmplY3Qua2V5cyhtdWx0aSA/IGZpcnN0WzBdIDogZmlyc3QpXG4gIHJldHVybiB2YWx1ZXNCdWlsZGVyKG11bHRpID8gZmlyc3QgOiBbZmlyc3RdLCBwYXJhbWV0ZXJzLCB0eXBlcywgY29sdW1ucywgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc2VsZWN0KGZpcnN0LCByZXN0LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICB0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnICYmIChmaXJzdCA9IFtmaXJzdF0uY29uY2F0KHJlc3QpKVxuICBpZiAoQXJyYXkuaXNBcnJheShmaXJzdCkpXG4gICAgcmV0dXJuIGVzY2FwZUlkZW50aWZpZXJzKGZpcnN0LCBvcHRpb25zKVxuXG4gIGxldCB2YWx1ZVxuICBjb25zdCBjb2x1bW5zID0gcmVzdC5sZW5ndGggPyByZXN0LmZsYXQoKSA6IE9iamVjdC5rZXlzKGZpcnN0KVxuICByZXR1cm4gY29sdW1ucy5tYXAoeCA9PiB7XG4gICAgdmFsdWUgPSBmaXJzdFt4XVxuICAgIHJldHVybiAoXG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIFF1ZXJ5ID8gZnJhZ21lbnQodmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSA6XG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIElkZW50aWZpZXIgPyB2YWx1ZS52YWx1ZSA6XG4gICAgICBoYW5kbGVWYWx1ZSh2YWx1ZSwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpXG4gICAgKSArICcgYXMgJyArIGVzY2FwZUlkZW50aWZpZXIob3B0aW9ucy50cmFuc2Zvcm0uY29sdW1uLnRvID8gb3B0aW9ucy50cmFuc2Zvcm0uY29sdW1uLnRvKHgpIDogeClcbiAgfSkuam9pbignLCcpXG59XG5cbmNvbnN0IGJ1aWxkZXJzID0gT2JqZWN0LmVudHJpZXMoe1xuICB2YWx1ZXMsXG4gIGluOiAoLi4ueHMpID0+IHtcbiAgICBjb25zdCB4ID0gdmFsdWVzKC4uLnhzKVxuICAgIHJldHVybiB4ID09PSAnKCknID8gJyhudWxsKScgOiB4XG4gIH0sXG4gIHNlbGVjdCxcbiAgYXM6IHNlbGVjdCxcbiAgcmV0dXJuaW5nOiBzZWxlY3QsXG4gICdcXFxcKCc6IHNlbGVjdCxcblxuICB1cGRhdGUoZmlyc3QsIHJlc3QsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIChyZXN0Lmxlbmd0aCA/IHJlc3QuZmxhdCgpIDogT2JqZWN0LmtleXMoZmlyc3QpKS5tYXAoeCA9PlxuICAgICAgZXNjYXBlSWRlbnRpZmllcihvcHRpb25zLnRyYW5zZm9ybS5jb2x1bW4udG8gPyBvcHRpb25zLnRyYW5zZm9ybS5jb2x1bW4udG8oeCkgOiB4KSArXG4gICAgICAnPScgKyBzdHJpbmdpZnlWYWx1ZSgndmFsdWVzJywgZmlyc3RbeF0sIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKVxuICAgIClcbiAgfSxcblxuICBpbnNlcnQoZmlyc3QsIHJlc3QsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29sdW1ucyA9IHJlc3QubGVuZ3RoID8gcmVzdC5mbGF0KCkgOiBPYmplY3Qua2V5cyhBcnJheS5pc0FycmF5KGZpcnN0KSA/IGZpcnN0WzBdIDogZmlyc3QpXG4gICAgcmV0dXJuICcoJyArIGVzY2FwZUlkZW50aWZpZXJzKGNvbHVtbnMsIG9wdGlvbnMpICsgJyl2YWx1ZXMnICtcbiAgICB2YWx1ZXNCdWlsZGVyKEFycmF5LmlzQXJyYXkoZmlyc3QpID8gZmlyc3QgOiBbZmlyc3RdLCBwYXJhbWV0ZXJzLCB0eXBlcywgY29sdW1ucywgb3B0aW9ucylcbiAgfVxufSkubWFwKChbeCwgZm5dKSA9PiAoW25ldyBSZWdFeHAoJygoPzpefFtcXFxccyhdKScgKyB4ICsgJyg/OiR8W1xcXFxzKF0pKSg/IVtcXFxcc1xcXFxTXSpcXFxcMSknLCAnaScpLCBmbl0pKVxuXG5mdW5jdGlvbiBub3RUYWdnZWQoKSB7XG4gIHRocm93IEVycm9ycy5nZW5lcmljKCdOT1RfVEFHR0VEX0NBTEwnLCAnUXVlcnkgbm90IGNhbGxlZCBhcyBhIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsJylcbn1cblxuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZXJzID0gZGVmYXVsdEhhbmRsZXJzLnNlcmlhbGl6ZXJzXG5leHBvcnQgY29uc3QgcGFyc2VycyA9IGRlZmF1bHRIYW5kbGVycy5wYXJzZXJzXG5cbmV4cG9ydCBjb25zdCBFTkQgPSB7fVxuXG5mdW5jdGlvbiBmaXJzdElzU3RyaW5nKHgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpXG4gICAgcmV0dXJuIGZpcnN0SXNTdHJpbmcoeFswXSlcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyA/IDEwMDkgOiAwXG59XG5cbmV4cG9ydCBjb25zdCBtZXJnZVVzZXJUeXBlcyA9IGZ1bmN0aW9uKHR5cGVzKSB7XG4gIGNvbnN0IHVzZXIgPSB0eXBlSGFuZGxlcnModHlwZXMgfHwge30pXG4gIHJldHVybiB7XG4gICAgc2VyaWFsaXplcnM6IE9iamVjdC5hc3NpZ24oe30sIHNlcmlhbGl6ZXJzLCB1c2VyLnNlcmlhbGl6ZXJzKSxcbiAgICBwYXJzZXJzOiBPYmplY3QuYXNzaWduKHt9LCBwYXJzZXJzLCB1c2VyLnBhcnNlcnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gdHlwZUhhbmRsZXJzKHR5cGVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlcykucmVkdWNlKChhY2MsIGspID0+IHtcbiAgICB0eXBlc1trXS5mcm9tICYmIFtdLmNvbmNhdCh0eXBlc1trXS5mcm9tKS5mb3JFYWNoKHggPT4gYWNjLnBhcnNlcnNbeF0gPSB0eXBlc1trXS5wYXJzZSlcbiAgICBpZiAodHlwZXNba10uc2VyaWFsaXplKSB7XG4gICAgICBhY2Muc2VyaWFsaXplcnNbdHlwZXNba10udG9dID0gdHlwZXNba10uc2VyaWFsaXplXG4gICAgICB0eXBlc1trXS5mcm9tICYmIFtdLmNvbmNhdCh0eXBlc1trXS5mcm9tKS5mb3JFYWNoKHggPT4gYWNjLnNlcmlhbGl6ZXJzW3hdID0gdHlwZXNba10uc2VyaWFsaXplKVxuICAgIH1cbiAgICByZXR1cm4gYWNjXG4gIH0sIHsgcGFyc2Vyczoge30sIHNlcmlhbGl6ZXJzOiB7fSB9KVxufVxuXG5mdW5jdGlvbiBlc2NhcGVJZGVudGlmaWVycyh4cywgeyB0cmFuc2Zvcm06IHsgY29sdW1uIH0gfSkge1xuICByZXR1cm4geHMubWFwKHggPT4gZXNjYXBlSWRlbnRpZmllcihjb2x1bW4udG8gPyBjb2x1bW4udG8oeCkgOiB4KSkuam9pbignLCcpXG59XG5cbmV4cG9ydCBjb25zdCBlc2NhcGVJZGVudGlmaWVyID0gZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cIi9nLCAnXCJcIicpLnJlcGxhY2UoL1xcLi9nLCAnXCIuXCInKSArICdcIidcbn1cblxuZXhwb3J0IGNvbnN0IGluZmVyVHlwZSA9IGZ1bmN0aW9uIGluZmVyVHlwZSh4KSB7XG4gIHJldHVybiAoXG4gICAgeCBpbnN0YW5jZW9mIFBhcmFtZXRlciA/IHgudHlwZSA6XG4gICAgeCBpbnN0YW5jZW9mIERhdGUgPyAxMTg0IDpcbiAgICB4IGluc3RhbmNlb2YgVWludDhBcnJheSA/IDE3IDpcbiAgICAoeCA9PT0gdHJ1ZSB8fCB4ID09PSBmYWxzZSkgPyAxNiA6XG4gICAgdHlwZW9mIHggPT09ICdiaWdpbnQnID8gMjAgOlxuICAgIEFycmF5LmlzQXJyYXkoeCkgPyBpbmZlclR5cGUoeFswXSkgOlxuICAgIDBcbiAgKVxufVxuXG5jb25zdCBlc2NhcGVCYWNrc2xhc2ggPSAvXFxcXC9nXG5jb25zdCBlc2NhcGVRdW90ZSA9IC9cIi9nXG5cbmZ1bmN0aW9uIGFycmF5RXNjYXBlKHgpIHtcbiAgcmV0dXJuIHhcbiAgICAucmVwbGFjZShlc2NhcGVCYWNrc2xhc2gsICdcXFxcXFxcXCcpXG4gICAgLnJlcGxhY2UoZXNjYXBlUXVvdGUsICdcXFxcXCInKVxufVxuXG5leHBvcnQgY29uc3QgYXJyYXlTZXJpYWxpemVyID0gZnVuY3Rpb24gYXJyYXlTZXJpYWxpemVyKHhzLCBzZXJpYWxpemVyLCBvcHRpb25zLCB0eXBhcnJheSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4cykgPT09IGZhbHNlKVxuICAgIHJldHVybiB4c1xuXG4gIGlmICgheHMubGVuZ3RoKVxuICAgIHJldHVybiAne30nXG5cbiAgY29uc3QgZmlyc3QgPSB4c1swXVxuICAvLyBPbmx5IF9ib3ggKDEwMjApIGhhcyB0aGUgJzsnIGRlbGltaXRlciBmb3IgYXJyYXlzLCBhbGwgb3RoZXIgdHlwZXMgdXNlIHRoZSAnLCcgZGVsaW1pdGVyXG4gIGNvbnN0IGRlbGltaXRlciA9IHR5cGFycmF5ID09PSAxMDIwID8gJzsnIDogJywnXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3QpICYmICFmaXJzdC50eXBlKVxuICAgIHJldHVybiAneycgKyB4cy5tYXAoeCA9PiBhcnJheVNlcmlhbGl6ZXIoeCwgc2VyaWFsaXplciwgb3B0aW9ucywgdHlwYXJyYXkpKS5qb2luKGRlbGltaXRlcikgKyAnfSdcblxuICByZXR1cm4gJ3snICsgeHMubWFwKHggPT4ge1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHggPSBvcHRpb25zLnRyYW5zZm9ybS51bmRlZmluZWRcbiAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9ycy5nZW5lcmljKCdVTkRFRklORURfVkFMVUUnLCAnVW5kZWZpbmVkIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB4ID09PSBudWxsXG4gICAgICA/ICdudWxsJ1xuICAgICAgOiAnXCInICsgYXJyYXlFc2NhcGUoc2VyaWFsaXplciA/IHNlcmlhbGl6ZXIoeC50eXBlID8geC52YWx1ZSA6IHgpIDogJycgKyB4KSArICdcIidcbiAgfSkuam9pbihkZWxpbWl0ZXIpICsgJ30nXG59XG5cbmNvbnN0IGFycmF5UGFyc2VyU3RhdGUgPSB7XG4gIGk6IDAsXG4gIGNoYXI6IG51bGwsXG4gIHN0cjogJycsXG4gIHF1b3RlZDogZmFsc2UsXG4gIGxhc3Q6IDBcbn1cblxuZXhwb3J0IGNvbnN0IGFycmF5UGFyc2VyID0gZnVuY3Rpb24gYXJyYXlQYXJzZXIoeCwgcGFyc2VyLCB0eXBhcnJheSkge1xuICBhcnJheVBhcnNlclN0YXRlLmkgPSBhcnJheVBhcnNlclN0YXRlLmxhc3QgPSAwXG4gIHJldHVybiBhcnJheVBhcnNlckxvb3AoYXJyYXlQYXJzZXJTdGF0ZSwgeCwgcGFyc2VyLCB0eXBhcnJheSlcbn1cblxuZnVuY3Rpb24gYXJyYXlQYXJzZXJMb29wKHMsIHgsIHBhcnNlciwgdHlwYXJyYXkpIHtcbiAgY29uc3QgeHMgPSBbXVxuICAvLyBPbmx5IF9ib3ggKDEwMjApIGhhcyB0aGUgJzsnIGRlbGltaXRlciBmb3IgYXJyYXlzLCBhbGwgb3RoZXIgdHlwZXMgdXNlIHRoZSAnLCcgZGVsaW1pdGVyXG4gIGNvbnN0IGRlbGltaXRlciA9IHR5cGFycmF5ID09PSAxMDIwID8gJzsnIDogJywnXG4gIGZvciAoOyBzLmkgPCB4Lmxlbmd0aDsgcy5pKyspIHtcbiAgICBzLmNoYXIgPSB4W3MuaV1cbiAgICBpZiAocy5xdW90ZWQpIHtcbiAgICAgIGlmIChzLmNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICBzLnN0ciArPSB4Wysrcy5pXVxuICAgICAgfSBlbHNlIGlmIChzLmNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgeHMucHVzaChwYXJzZXIgPyBwYXJzZXIocy5zdHIpIDogcy5zdHIpXG4gICAgICAgIHMuc3RyID0gJydcbiAgICAgICAgcy5xdW90ZWQgPSB4W3MuaSArIDFdID09PSAnXCInXG4gICAgICAgIHMubGFzdCA9IHMuaSArIDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuc3RyICs9IHMuY2hhclxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocy5jaGFyID09PSAnXCInKSB7XG4gICAgICBzLnF1b3RlZCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHMuY2hhciA9PT0gJ3snKSB7XG4gICAgICBzLmxhc3QgPSArK3MuaVxuICAgICAgeHMucHVzaChhcnJheVBhcnNlckxvb3AocywgeCwgcGFyc2VyLCB0eXBhcnJheSkpXG4gICAgfSBlbHNlIGlmIChzLmNoYXIgPT09ICd9Jykge1xuICAgICAgcy5xdW90ZWQgPSBmYWxzZVxuICAgICAgcy5sYXN0IDwgcy5pICYmIHhzLnB1c2gocGFyc2VyID8gcGFyc2VyKHguc2xpY2Uocy5sYXN0LCBzLmkpKSA6IHguc2xpY2Uocy5sYXN0LCBzLmkpKVxuICAgICAgcy5sYXN0ID0gcy5pICsgMVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKHMuY2hhciA9PT0gZGVsaW1pdGVyICYmIHMucCAhPT0gJ30nICYmIHMucCAhPT0gJ1wiJykge1xuICAgICAgeHMucHVzaChwYXJzZXIgPyBwYXJzZXIoeC5zbGljZShzLmxhc3QsIHMuaSkpIDogeC5zbGljZShzLmxhc3QsIHMuaSkpXG4gICAgICBzLmxhc3QgPSBzLmkgKyAxXG4gICAgfVxuICAgIHMucCA9IHMuY2hhclxuICB9XG4gIHMubGFzdCA8IHMuaSAmJiB4cy5wdXNoKHBhcnNlciA/IHBhcnNlcih4LnNsaWNlKHMubGFzdCwgcy5pICsgMSkpIDogeC5zbGljZShzLmxhc3QsIHMuaSArIDEpKVxuICByZXR1cm4geHNcbn1cblxuZXhwb3J0IGNvbnN0IHRvQ2FtZWwgPSB4ID0+IHtcbiAgbGV0IHN0ciA9IHhbMF1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKVxuICAgIHN0ciArPSB4W2ldID09PSAnXycgPyB4WysraV0udG9VcHBlckNhc2UoKSA6IHhbaV1cbiAgcmV0dXJuIHN0clxufVxuXG5leHBvcnQgY29uc3QgdG9QYXNjYWwgPSB4ID0+IHtcbiAgbGV0IHN0ciA9IHhbMF0udG9VcHBlckNhc2UoKVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHgubGVuZ3RoOyBpKyspXG4gICAgc3RyICs9IHhbaV0gPT09ICdfJyA/IHhbKytpXS50b1VwcGVyQ2FzZSgpIDogeFtpXVxuICByZXR1cm4gc3RyXG59XG5cbmV4cG9ydCBjb25zdCB0b0tlYmFiID0geCA9PiB4LnJlcGxhY2UoL18vZywgJy0nKVxuXG5leHBvcnQgY29uc3QgZnJvbUNhbWVsID0geCA9PiB4LnJlcGxhY2UoLyhbQS1aXSkvZywgJ18kMScpLnRvTG93ZXJDYXNlKClcbmV4cG9ydCBjb25zdCBmcm9tUGFzY2FsID0geCA9PiAoeC5zbGljZSgwLCAxKSArIHguc2xpY2UoMSkucmVwbGFjZSgvKFtBLVpdKS9nLCAnXyQxJykpLnRvTG93ZXJDYXNlKClcbmV4cG9ydCBjb25zdCBmcm9tS2ViYWIgPSB4ID0+IHgucmVwbGFjZSgvLS9nLCAnXycpXG5cbmZ1bmN0aW9uIGNyZWF0ZUpzb25UcmFuc2Zvcm0oZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGpzb25UcmFuc2Zvcm0oeCwgY29sdW1uKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIChjb2x1bW4udHlwZSA9PT0gMTE0IHx8IGNvbHVtbi50eXBlID09PSAzODAyKVxuICAgICAgPyBBcnJheS5pc0FycmF5KHgpXG4gICAgICAgID8geC5tYXAoeCA9PiBqc29uVHJhbnNmb3JtKHgsIGNvbHVtbikpXG4gICAgICAgIDogT2JqZWN0LmVudHJpZXMoeCkucmVkdWNlKChhY2MsIFtrLCB2XSkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW2ZuKGspXToganNvblRyYW5zZm9ybSh2LCBjb2x1bW4pIH0pLCB7fSlcbiAgICAgIDogeFxuICB9XG59XG5cbnRvQ2FtZWwuY29sdW1uID0geyBmcm9tOiB0b0NhbWVsIH1cbnRvQ2FtZWwudmFsdWUgPSB7IGZyb206IGNyZWF0ZUpzb25UcmFuc2Zvcm0odG9DYW1lbCkgfVxuZnJvbUNhbWVsLmNvbHVtbiA9IHsgdG86IGZyb21DYW1lbCB9XG5cbmV4cG9ydCBjb25zdCBjYW1lbCA9IHsgLi4udG9DYW1lbCB9XG5jYW1lbC5jb2x1bW4udG8gPSBmcm9tQ2FtZWxcblxudG9QYXNjYWwuY29sdW1uID0geyBmcm9tOiB0b1Bhc2NhbCB9XG50b1Bhc2NhbC52YWx1ZSA9IHsgZnJvbTogY3JlYXRlSnNvblRyYW5zZm9ybSh0b1Bhc2NhbCkgfVxuZnJvbVBhc2NhbC5jb2x1bW4gPSB7IHRvOiBmcm9tUGFzY2FsIH1cblxuZXhwb3J0IGNvbnN0IHBhc2NhbCA9IHsgLi4udG9QYXNjYWwgfVxucGFzY2FsLmNvbHVtbi50byA9IGZyb21QYXNjYWxcblxudG9LZWJhYi5jb2x1bW4gPSB7IGZyb206IHRvS2ViYWIgfVxudG9LZWJhYi52YWx1ZSA9IHsgZnJvbTogY3JlYXRlSnNvblRyYW5zZm9ybSh0b0tlYmFiKSB9XG5mcm9tS2ViYWIuY29sdW1uID0geyB0bzogZnJvbUtlYmFiIH1cblxuZXhwb3J0IGNvbnN0IGtlYmFiID0geyAuLi50b0tlYmFiIH1cbmtlYmFiLmNvbHVtbi50byA9IGZyb21LZWJhYlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/postgres/src/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/postgres/src/types.js":
/*!********************************************!*\
  !*** ./node_modules/postgres/src/types.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Builder: () => (/* binding */ Builder),\n/* harmony export */   END: () => (/* binding */ END),\n/* harmony export */   Identifier: () => (/* binding */ Identifier),\n/* harmony export */   Parameter: () => (/* binding */ Parameter),\n/* harmony export */   arrayParser: () => (/* binding */ arrayParser),\n/* harmony export */   arraySerializer: () => (/* binding */ arraySerializer),\n/* harmony export */   camel: () => (/* binding */ camel),\n/* harmony export */   escapeIdentifier: () => (/* binding */ escapeIdentifier),\n/* harmony export */   fromCamel: () => (/* binding */ fromCamel),\n/* harmony export */   fromKebab: () => (/* binding */ fromKebab),\n/* harmony export */   fromPascal: () => (/* binding */ fromPascal),\n/* harmony export */   handleValue: () => (/* binding */ handleValue),\n/* harmony export */   inferType: () => (/* binding */ inferType),\n/* harmony export */   kebab: () => (/* binding */ kebab),\n/* harmony export */   mergeUserTypes: () => (/* binding */ mergeUserTypes),\n/* harmony export */   parsers: () => (/* binding */ parsers),\n/* harmony export */   pascal: () => (/* binding */ pascal),\n/* harmony export */   serializers: () => (/* binding */ serializers),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   toCamel: () => (/* binding */ toCamel),\n/* harmony export */   toKebab: () => (/* binding */ toKebab),\n/* harmony export */   toPascal: () => (/* binding */ toPascal),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./query.js */ \"(rsc)/./node_modules/postgres/src/query.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/postgres/src/errors.js\");\n\n\n\nconst types = {\n  string: {\n    to: 25,\n    from: null,             // defaults to string\n    serialize: x => '' + x\n  },\n  number: {\n    to: 0,\n    from: [21, 23, 26, 700, 701],\n    serialize: x => '' + x,\n    parse: x => +x\n  },\n  json: {\n    to: 114,\n    from: [114, 3802],\n    serialize: x => JSON.stringify(x),\n    parse: x => JSON.parse(x)\n  },\n  boolean: {\n    to: 16,\n    from: 16,\n    serialize: x => x === true ? 't' : 'f',\n    parse: x => x === 't'\n  },\n  date: {\n    to: 1184,\n    from: [1082, 1114, 1184],\n    serialize: x => (x instanceof Date ? x : new Date(x)).toISOString(),\n    parse: x => new Date(x)\n  },\n  bytea: {\n    to: 17,\n    from: 17,\n    serialize: x => '\\\\x' + Buffer.from(x).toString('hex'),\n    parse: x => Buffer.from(x.slice(2), 'hex')\n  }\n}\n\nclass NotTagged { then() { notTagged() } catch() { notTagged() } finally() { notTagged() }}\n\nclass Identifier extends NotTagged {\n  constructor(value) {\n    super()\n    this.value = escapeIdentifier(value)\n  }\n}\n\nclass Parameter extends NotTagged {\n  constructor(value, type, array) {\n    super()\n    this.value = value\n    this.type = type\n    this.array = array\n  }\n}\n\nclass Builder extends NotTagged {\n  constructor(first, rest) {\n    super()\n    this.first = first\n    this.rest = rest\n  }\n\n  build(before, parameters, types, options) {\n    const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a, b) => a.i - b.i).pop()\n    return keyword.i === -1\n      ? escapeIdentifiers(this.first, options)\n      : keyword.fn(this.first, this.rest, parameters, types, options)\n  }\n}\n\nfunction handleValue(x, parameters, types, options) {\n  let value = x instanceof Parameter ? x.value : x\n  if (value === undefined) {\n    x instanceof Parameter\n      ? x.value = options.transform.undefined\n      : value = x = options.transform.undefined\n\n    if (value === undefined)\n      throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed')\n  }\n\n  return '$' + (types.push(\n    x instanceof Parameter\n      ? (parameters.push(x.value), x.array\n        ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value)\n        : x.type\n      )\n      : (parameters.push(x), inferType(x))\n  ))\n}\n\nconst defaultHandlers = typeHandlers(types)\n\nfunction stringify(q, string, value, parameters, types, options) { // eslint-disable-line\n  for (let i = 1; i < q.strings.length; i++) {\n    string += (stringifyValue(string, value, parameters, types, options)) + q.strings[i]\n    value = q.args[i]\n  }\n\n  return string\n}\n\nfunction stringifyValue(string, value, parameters, types, o) {\n  return (\n    value instanceof Builder ? value.build(string, parameters, types, o) :\n    value instanceof _query_js__WEBPACK_IMPORTED_MODULE_0__.Query ? fragment(value, parameters, types, o) :\n    value instanceof Identifier ? value.value :\n    value && value[0] instanceof _query_js__WEBPACK_IMPORTED_MODULE_0__.Query ? value.reduce((acc, x) => acc + ' ' + fragment(x, parameters, types, o), '') :\n    handleValue(value, parameters, types, o)\n  )\n}\n\nfunction fragment(q, parameters, types, options) {\n  q.fragment = true\n  return stringify(q, q.strings[0], q.args[0], parameters, types, options)\n}\n\nfunction valuesBuilder(first, parameters, types, columns, options) {\n  return first.map(row =>\n    '(' + columns.map(column =>\n      stringifyValue('values', row[column], parameters, types, options)\n    ).join(',') + ')'\n  ).join(',')\n}\n\nfunction values(first, rest, parameters, types, options) {\n  const multi = Array.isArray(first[0])\n  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first)\n  return valuesBuilder(multi ? first : [first], parameters, types, columns, options)\n}\n\nfunction select(first, rest, parameters, types, options) {\n  typeof first === 'string' && (first = [first].concat(rest))\n  if (Array.isArray(first))\n    return escapeIdentifiers(first, options)\n\n  let value\n  const columns = rest.length ? rest.flat() : Object.keys(first)\n  return columns.map(x => {\n    value = first[x]\n    return (\n      value instanceof _query_js__WEBPACK_IMPORTED_MODULE_0__.Query ? fragment(value, parameters, types, options) :\n      value instanceof Identifier ? value.value :\n      handleValue(value, parameters, types, options)\n    ) + ' as ' + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)\n  }).join(',')\n}\n\nconst builders = Object.entries({\n  values,\n  in: (...xs) => {\n    const x = values(...xs)\n    return x === '()' ? '(null)' : x\n  },\n  select,\n  as: select,\n  returning: select,\n  '\\\\(': select,\n\n  update(first, rest, parameters, types, options) {\n    return (rest.length ? rest.flat() : Object.keys(first)).map(x =>\n      escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) +\n      '=' + stringifyValue('values', first[x], parameters, types, options)\n    )\n  },\n\n  insert(first, rest, parameters, types, options) {\n    const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first)\n    return '(' + escapeIdentifiers(columns, options) + ')values' +\n    valuesBuilder(Array.isArray(first) ? first : [first], parameters, types, columns, options)\n  }\n}).map(([x, fn]) => ([new RegExp('((?:^|[\\\\s(])' + x + '(?:$|[\\\\s(]))(?![\\\\s\\\\S]*\\\\1)', 'i'), fn]))\n\nfunction notTagged() {\n  throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.Errors.generic('NOT_TAGGED_CALL', 'Query not called as a tagged template literal')\n}\n\nconst serializers = defaultHandlers.serializers\nconst parsers = defaultHandlers.parsers\n\nconst END = {}\n\nfunction firstIsString(x) {\n  if (Array.isArray(x))\n    return firstIsString(x[0])\n  return typeof x === 'string' ? 1009 : 0\n}\n\nconst mergeUserTypes = function(types) {\n  const user = typeHandlers(types || {})\n  return {\n    serializers: Object.assign({}, serializers, user.serializers),\n    parsers: Object.assign({}, parsers, user.parsers)\n  }\n}\n\nfunction typeHandlers(types) {\n  return Object.keys(types).reduce((acc, k) => {\n    types[k].from && [].concat(types[k].from).forEach(x => acc.parsers[x] = types[k].parse)\n    if (types[k].serialize) {\n      acc.serializers[types[k].to] = types[k].serialize\n      types[k].from && [].concat(types[k].from).forEach(x => acc.serializers[x] = types[k].serialize)\n    }\n    return acc\n  }, { parsers: {}, serializers: {} })\n}\n\nfunction escapeIdentifiers(xs, { transform: { column } }) {\n  return xs.map(x => escapeIdentifier(column.to ? column.to(x) : x)).join(',')\n}\n\nconst escapeIdentifier = function escape(str) {\n  return '\"' + str.replace(/\"/g, '\"\"').replace(/\\./g, '\".\"') + '\"'\n}\n\nconst inferType = function inferType(x) {\n  return (\n    x instanceof Parameter ? x.type :\n    x instanceof Date ? 1184 :\n    x instanceof Uint8Array ? 17 :\n    (x === true || x === false) ? 16 :\n    typeof x === 'bigint' ? 20 :\n    Array.isArray(x) ? inferType(x[0]) :\n    0\n  )\n}\n\nconst escapeBackslash = /\\\\/g\nconst escapeQuote = /\"/g\n\nfunction arrayEscape(x) {\n  return x\n    .replace(escapeBackslash, '\\\\\\\\')\n    .replace(escapeQuote, '\\\\\"')\n}\n\nconst arraySerializer = function arraySerializer(xs, serializer, options, typarray) {\n  if (Array.isArray(xs) === false)\n    return xs\n\n  if (!xs.length)\n    return '{}'\n\n  const first = xs[0]\n  // Only _box (1020) has the ';' delimiter for arrays, all other types use the ',' delimiter\n  const delimiter = typarray === 1020 ? ';' : ','\n\n  if (Array.isArray(first) && !first.type)\n    return '{' + xs.map(x => arraySerializer(x, serializer, options, typarray)).join(delimiter) + '}'\n\n  return '{' + xs.map(x => {\n    if (x === undefined) {\n      x = options.transform.undefined\n      if (x === undefined)\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed')\n    }\n\n    return x === null\n      ? 'null'\n      : '\"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : '' + x) + '\"'\n  }).join(delimiter) + '}'\n}\n\nconst arrayParserState = {\n  i: 0,\n  char: null,\n  str: '',\n  quoted: false,\n  last: 0\n}\n\nconst arrayParser = function arrayParser(x, parser, typarray) {\n  arrayParserState.i = arrayParserState.last = 0\n  return arrayParserLoop(arrayParserState, x, parser, typarray)\n}\n\nfunction arrayParserLoop(s, x, parser, typarray) {\n  const xs = []\n  // Only _box (1020) has the ';' delimiter for arrays, all other types use the ',' delimiter\n  const delimiter = typarray === 1020 ? ';' : ','\n  for (; s.i < x.length; s.i++) {\n    s.char = x[s.i]\n    if (s.quoted) {\n      if (s.char === '\\\\') {\n        s.str += x[++s.i]\n      } else if (s.char === '\"') {\n        xs.push(parser ? parser(s.str) : s.str)\n        s.str = ''\n        s.quoted = x[s.i + 1] === '\"'\n        s.last = s.i + 2\n      } else {\n        s.str += s.char\n      }\n    } else if (s.char === '\"') {\n      s.quoted = true\n    } else if (s.char === '{') {\n      s.last = ++s.i\n      xs.push(arrayParserLoop(s, x, parser, typarray))\n    } else if (s.char === '}') {\n      s.quoted = false\n      s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i))\n      s.last = s.i + 1\n      break\n    } else if (s.char === delimiter && s.p !== '}' && s.p !== '\"') {\n      xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i))\n      s.last = s.i + 1\n    }\n    s.p = s.char\n  }\n  s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1))\n  return xs\n}\n\nconst toCamel = x => {\n  let str = x[0]\n  for (let i = 1; i < x.length; i++)\n    str += x[i] === '_' ? x[++i].toUpperCase() : x[i]\n  return str\n}\n\nconst toPascal = x => {\n  let str = x[0].toUpperCase()\n  for (let i = 1; i < x.length; i++)\n    str += x[i] === '_' ? x[++i].toUpperCase() : x[i]\n  return str\n}\n\nconst toKebab = x => x.replace(/_/g, '-')\n\nconst fromCamel = x => x.replace(/([A-Z])/g, '_$1').toLowerCase()\nconst fromPascal = x => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, '_$1')).toLowerCase()\nconst fromKebab = x => x.replace(/-/g, '_')\n\nfunction createJsonTransform(fn) {\n  return function jsonTransform(x, column) {\n    return typeof x === 'object' && x !== null && (column.type === 114 || column.type === 3802)\n      ? Array.isArray(x)\n        ? x.map(x => jsonTransform(x, column))\n        : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column) }), {})\n      : x\n  }\n}\n\ntoCamel.column = { from: toCamel }\ntoCamel.value = { from: createJsonTransform(toCamel) }\nfromCamel.column = { to: fromCamel }\n\nconst camel = { ...toCamel }\ncamel.column.to = fromCamel\n\ntoPascal.column = { from: toPascal }\ntoPascal.value = { from: createJsonTransform(toPascal) }\nfromPascal.column = { to: fromPascal }\n\nconst pascal = { ...toPascal }\npascal.column.to = fromPascal\n\ntoKebab.column = { from: toKebab }\ntoKebab.value = { from: createJsonTransform(toKebab) }\nfromKebab.column = { to: fromKebab }\n\nconst kebab = { ...toKebab }\nkebab.column.to = fromKebab\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMvc3JjL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDRTs7QUFFN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTLGNBQWMsVUFBVSxjQUFjLFlBQVk7O0FBRXRFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhDQUFNO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTyxtRUFBbUU7QUFDMUUsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQUs7QUFDMUI7QUFDQSxpQ0FBaUMsNENBQUs7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFFBQVEsOENBQU07QUFDZDs7QUFFTztBQUNBOztBQUVBOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCx1Q0FBdUM7QUFDdkM7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSxXQUFXLG1CQUFtQjtBQUNyQzs7QUFFQSxpQ0FBaUMsYUFBYSxVQUFVO0FBQ3hEO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQSxnQ0FBZ0M7QUFDaEMsMENBQTBDOztBQUUxQztBQUNBLGFBQWEsdUZBQXVGOztBQUVwRyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBTTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNCQUFzQjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDBDQUEwQztBQUMxQyxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSxzQkFBc0I7QUFDNUI7QUFDQTtBQUNBLE1BQU0sc0JBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQ0FBMkM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7O0FBRU87O0FBRUE7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbUNBQW1DLEtBQUs7QUFDakg7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIscUJBQXFCOztBQUVkLGdCQUFnQjtBQUN2Qjs7QUFFQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHNCQUFzQjs7QUFFZixpQkFBaUI7QUFDeEI7O0FBRUEsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixxQkFBcUI7O0FBRWQsZ0JBQWdCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25lY2FyZC8uL25vZGVfbW9kdWxlcy9wb3N0Z3Jlcy9zcmMvdHlwZXMuanM/M2UyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBRdWVyeSB9IGZyb20gJy4vcXVlcnkuanMnXG5pbXBvcnQgeyBFcnJvcnMgfSBmcm9tICcuL2Vycm9ycy5qcydcblxuZXhwb3J0IGNvbnN0IHR5cGVzID0ge1xuICBzdHJpbmc6IHtcbiAgICB0bzogMjUsXG4gICAgZnJvbTogbnVsbCwgICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gc3RyaW5nXG4gICAgc2VyaWFsaXplOiB4ID0+ICcnICsgeFxuICB9LFxuICBudW1iZXI6IHtcbiAgICB0bzogMCxcbiAgICBmcm9tOiBbMjEsIDIzLCAyNiwgNzAwLCA3MDFdLFxuICAgIHNlcmlhbGl6ZTogeCA9PiAnJyArIHgsXG4gICAgcGFyc2U6IHggPT4gK3hcbiAgfSxcbiAganNvbjoge1xuICAgIHRvOiAxMTQsXG4gICAgZnJvbTogWzExNCwgMzgwMl0sXG4gICAgc2VyaWFsaXplOiB4ID0+IEpTT04uc3RyaW5naWZ5KHgpLFxuICAgIHBhcnNlOiB4ID0+IEpTT04ucGFyc2UoeClcbiAgfSxcbiAgYm9vbGVhbjoge1xuICAgIHRvOiAxNixcbiAgICBmcm9tOiAxNixcbiAgICBzZXJpYWxpemU6IHggPT4geCA9PT0gdHJ1ZSA/ICd0JyA6ICdmJyxcbiAgICBwYXJzZTogeCA9PiB4ID09PSAndCdcbiAgfSxcbiAgZGF0ZToge1xuICAgIHRvOiAxMTg0LFxuICAgIGZyb206IFsxMDgyLCAxMTE0LCAxMTg0XSxcbiAgICBzZXJpYWxpemU6IHggPT4gKHggaW5zdGFuY2VvZiBEYXRlID8geCA6IG5ldyBEYXRlKHgpKS50b0lTT1N0cmluZygpLFxuICAgIHBhcnNlOiB4ID0+IG5ldyBEYXRlKHgpXG4gIH0sXG4gIGJ5dGVhOiB7XG4gICAgdG86IDE3LFxuICAgIGZyb206IDE3LFxuICAgIHNlcmlhbGl6ZTogeCA9PiAnXFxcXHgnICsgQnVmZmVyLmZyb20oeCkudG9TdHJpbmcoJ2hleCcpLFxuICAgIHBhcnNlOiB4ID0+IEJ1ZmZlci5mcm9tKHguc2xpY2UoMiksICdoZXgnKVxuICB9XG59XG5cbmNsYXNzIE5vdFRhZ2dlZCB7IHRoZW4oKSB7IG5vdFRhZ2dlZCgpIH0gY2F0Y2goKSB7IG5vdFRhZ2dlZCgpIH0gZmluYWxseSgpIHsgbm90VGFnZ2VkKCkgfX1cblxuZXhwb3J0IGNsYXNzIElkZW50aWZpZXIgZXh0ZW5kcyBOb3RUYWdnZWQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnZhbHVlID0gZXNjYXBlSWRlbnRpZmllcih2YWx1ZSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyIGV4dGVuZHMgTm90VGFnZ2VkIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHR5cGUsIGFycmF5KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLmFycmF5ID0gYXJyYXlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnVpbGRlciBleHRlbmRzIE5vdFRhZ2dlZCB7XG4gIGNvbnN0cnVjdG9yKGZpcnN0LCByZXN0KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdFxuICAgIHRoaXMucmVzdCA9IHJlc3RcbiAgfVxuXG4gIGJ1aWxkKGJlZm9yZSwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXl3b3JkID0gYnVpbGRlcnMubWFwKChbeCwgZm5dKSA9PiAoeyBmbiwgaTogYmVmb3JlLnNlYXJjaCh4KSB9KSkuc29ydCgoYSwgYikgPT4gYS5pIC0gYi5pKS5wb3AoKVxuICAgIHJldHVybiBrZXl3b3JkLmkgPT09IC0xXG4gICAgICA/IGVzY2FwZUlkZW50aWZpZXJzKHRoaXMuZmlyc3QsIG9wdGlvbnMpXG4gICAgICA6IGtleXdvcmQuZm4odGhpcy5maXJzdCwgdGhpcy5yZXN0LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlVmFsdWUoeCwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpIHtcbiAgbGV0IHZhbHVlID0geCBpbnN0YW5jZW9mIFBhcmFtZXRlciA/IHgudmFsdWUgOiB4XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgeCBpbnN0YW5jZW9mIFBhcmFtZXRlclxuICAgICAgPyB4LnZhbHVlID0gb3B0aW9ucy50cmFuc2Zvcm0udW5kZWZpbmVkXG4gICAgICA6IHZhbHVlID0geCA9IG9wdGlvbnMudHJhbnNmb3JtLnVuZGVmaW5lZFxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBFcnJvcnMuZ2VuZXJpYygnVU5ERUZJTkVEX1ZBTFVFJywgJ1VuZGVmaW5lZCB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkJylcbiAgfVxuXG4gIHJldHVybiAnJCcgKyAodHlwZXMucHVzaChcbiAgICB4IGluc3RhbmNlb2YgUGFyYW1ldGVyXG4gICAgICA/IChwYXJhbWV0ZXJzLnB1c2goeC52YWx1ZSksIHguYXJyYXlcbiAgICAgICAgPyB4LmFycmF5W3gudHlwZSB8fCBpbmZlclR5cGUoeC52YWx1ZSldIHx8IHgudHlwZSB8fCBmaXJzdElzU3RyaW5nKHgudmFsdWUpXG4gICAgICAgIDogeC50eXBlXG4gICAgICApXG4gICAgICA6IChwYXJhbWV0ZXJzLnB1c2goeCksIGluZmVyVHlwZSh4KSlcbiAgKSlcbn1cblxuY29uc3QgZGVmYXVsdEhhbmRsZXJzID0gdHlwZUhhbmRsZXJzKHR5cGVzKVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KHEsIHN0cmluZywgdmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBxLnN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJpbmcgKz0gKHN0cmluZ2lmeVZhbHVlKHN0cmluZywgdmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKSkgKyBxLnN0cmluZ3NbaV1cbiAgICB2YWx1ZSA9IHEuYXJnc1tpXVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZShzdHJpbmcsIHZhbHVlLCBwYXJhbWV0ZXJzLCB0eXBlcywgbykge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIGluc3RhbmNlb2YgQnVpbGRlciA/IHZhbHVlLmJ1aWxkKHN0cmluZywgcGFyYW1ldGVycywgdHlwZXMsIG8pIDpcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFF1ZXJ5ID8gZnJhZ21lbnQodmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvKSA6XG4gICAgdmFsdWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyID8gdmFsdWUudmFsdWUgOlxuICAgIHZhbHVlICYmIHZhbHVlWzBdIGluc3RhbmNlb2YgUXVlcnkgPyB2YWx1ZS5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgJyAnICsgZnJhZ21lbnQoeCwgcGFyYW1ldGVycywgdHlwZXMsIG8pLCAnJykgOlxuICAgIGhhbmRsZVZhbHVlKHZhbHVlLCBwYXJhbWV0ZXJzLCB0eXBlcywgbylcbiAgKVxufVxuXG5mdW5jdGlvbiBmcmFnbWVudChxLCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICBxLmZyYWdtZW50ID0gdHJ1ZVxuICByZXR1cm4gc3RyaW5naWZ5KHEsIHEuc3RyaW5nc1swXSwgcS5hcmdzWzBdLCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gdmFsdWVzQnVpbGRlcihmaXJzdCwgcGFyYW1ldGVycywgdHlwZXMsIGNvbHVtbnMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZpcnN0Lm1hcChyb3cgPT5cbiAgICAnKCcgKyBjb2x1bW5zLm1hcChjb2x1bW4gPT5cbiAgICAgIHN0cmluZ2lmeVZhbHVlKCd2YWx1ZXMnLCByb3dbY29sdW1uXSwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpXG4gICAgKS5qb2luKCcsJykgKyAnKSdcbiAgKS5qb2luKCcsJylcbn1cblxuZnVuY3Rpb24gdmFsdWVzKGZpcnN0LCByZXN0LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICBjb25zdCBtdWx0aSA9IEFycmF5LmlzQXJyYXkoZmlyc3RbMF0pXG4gIGNvbnN0IGNvbHVtbnMgPSByZXN0Lmxlbmd0aCA/IHJlc3QuZmxhdCgpIDogT2JqZWN0LmtleXMobXVsdGkgPyBmaXJzdFswXSA6IGZpcnN0KVxuICByZXR1cm4gdmFsdWVzQnVpbGRlcihtdWx0aSA/IGZpcnN0IDogW2ZpcnN0XSwgcGFyYW1ldGVycywgdHlwZXMsIGNvbHVtbnMsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHNlbGVjdChmaXJzdCwgcmVzdCwgcGFyYW1ldGVycywgdHlwZXMsIG9wdGlvbnMpIHtcbiAgdHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyAmJiAoZmlyc3QgPSBbZmlyc3RdLmNvbmNhdChyZXN0KSlcbiAgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3QpKVxuICAgIHJldHVybiBlc2NhcGVJZGVudGlmaWVycyhmaXJzdCwgb3B0aW9ucylcblxuICBsZXQgdmFsdWVcbiAgY29uc3QgY29sdW1ucyA9IHJlc3QubGVuZ3RoID8gcmVzdC5mbGF0KCkgOiBPYmplY3Qua2V5cyhmaXJzdClcbiAgcmV0dXJuIGNvbHVtbnMubWFwKHggPT4ge1xuICAgIHZhbHVlID0gZmlyc3RbeF1cbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBRdWVyeSA/IGZyYWdtZW50KHZhbHVlLCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykgOlxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyID8gdmFsdWUudmFsdWUgOlxuICAgICAgaGFuZGxlVmFsdWUodmFsdWUsIHBhcmFtZXRlcnMsIHR5cGVzLCBvcHRpb25zKVxuICAgICkgKyAnIGFzICcgKyBlc2NhcGVJZGVudGlmaWVyKG9wdGlvbnMudHJhbnNmb3JtLmNvbHVtbi50byA/IG9wdGlvbnMudHJhbnNmb3JtLmNvbHVtbi50byh4KSA6IHgpXG4gIH0pLmpvaW4oJywnKVxufVxuXG5jb25zdCBidWlsZGVycyA9IE9iamVjdC5lbnRyaWVzKHtcbiAgdmFsdWVzLFxuICBpbjogKC4uLnhzKSA9PiB7XG4gICAgY29uc3QgeCA9IHZhbHVlcyguLi54cylcbiAgICByZXR1cm4geCA9PT0gJygpJyA/ICcobnVsbCknIDogeFxuICB9LFxuICBzZWxlY3QsXG4gIGFzOiBzZWxlY3QsXG4gIHJldHVybmluZzogc2VsZWN0LFxuICAnXFxcXCgnOiBzZWxlY3QsXG5cbiAgdXBkYXRlKGZpcnN0LCByZXN0LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICAgIHJldHVybiAocmVzdC5sZW5ndGggPyByZXN0LmZsYXQoKSA6IE9iamVjdC5rZXlzKGZpcnN0KSkubWFwKHggPT5cbiAgICAgIGVzY2FwZUlkZW50aWZpZXIob3B0aW9ucy50cmFuc2Zvcm0uY29sdW1uLnRvID8gb3B0aW9ucy50cmFuc2Zvcm0uY29sdW1uLnRvKHgpIDogeCkgK1xuICAgICAgJz0nICsgc3RyaW5naWZ5VmFsdWUoJ3ZhbHVlcycsIGZpcnN0W3hdLCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucylcbiAgICApXG4gIH0sXG5cbiAgaW5zZXJ0KGZpcnN0LCByZXN0LCBwYXJhbWV0ZXJzLCB0eXBlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbHVtbnMgPSByZXN0Lmxlbmd0aCA/IHJlc3QuZmxhdCgpIDogT2JqZWN0LmtleXMoQXJyYXkuaXNBcnJheShmaXJzdCkgPyBmaXJzdFswXSA6IGZpcnN0KVxuICAgIHJldHVybiAnKCcgKyBlc2NhcGVJZGVudGlmaWVycyhjb2x1bW5zLCBvcHRpb25zKSArICcpdmFsdWVzJyArXG4gICAgdmFsdWVzQnVpbGRlcihBcnJheS5pc0FycmF5KGZpcnN0KSA/IGZpcnN0IDogW2ZpcnN0XSwgcGFyYW1ldGVycywgdHlwZXMsIGNvbHVtbnMsIG9wdGlvbnMpXG4gIH1cbn0pLm1hcCgoW3gsIGZuXSkgPT4gKFtuZXcgUmVnRXhwKCcoKD86XnxbXFxcXHMoXSknICsgeCArICcoPzokfFtcXFxccyhdKSkoPyFbXFxcXHNcXFxcU10qXFxcXDEpJywgJ2knKSwgZm5dKSlcblxuZnVuY3Rpb24gbm90VGFnZ2VkKCkge1xuICB0aHJvdyBFcnJvcnMuZ2VuZXJpYygnTk9UX1RBR0dFRF9DQUxMJywgJ1F1ZXJ5IG5vdCBjYWxsZWQgYXMgYSB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbCcpXG59XG5cbmV4cG9ydCBjb25zdCBzZXJpYWxpemVycyA9IGRlZmF1bHRIYW5kbGVycy5zZXJpYWxpemVyc1xuZXhwb3J0IGNvbnN0IHBhcnNlcnMgPSBkZWZhdWx0SGFuZGxlcnMucGFyc2Vyc1xuXG5leHBvcnQgY29uc3QgRU5EID0ge31cblxuZnVuY3Rpb24gZmlyc3RJc1N0cmluZyh4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKVxuICAgIHJldHVybiBmaXJzdElzU3RyaW5nKHhbMF0pXG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgPyAxMDA5IDogMFxufVxuXG5leHBvcnQgY29uc3QgbWVyZ2VVc2VyVHlwZXMgPSBmdW5jdGlvbih0eXBlcykge1xuICBjb25zdCB1c2VyID0gdHlwZUhhbmRsZXJzKHR5cGVzIHx8IHt9KVxuICByZXR1cm4ge1xuICAgIHNlcmlhbGl6ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBzZXJpYWxpemVycywgdXNlci5zZXJpYWxpemVycyksXG4gICAgcGFyc2VyczogT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VycywgdXNlci5wYXJzZXJzKVxuICB9XG59XG5cbmZ1bmN0aW9uIHR5cGVIYW5kbGVycyh0eXBlcykge1xuICByZXR1cm4gT2JqZWN0LmtleXModHlwZXMpLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgdHlwZXNba10uZnJvbSAmJiBbXS5jb25jYXQodHlwZXNba10uZnJvbSkuZm9yRWFjaCh4ID0+IGFjYy5wYXJzZXJzW3hdID0gdHlwZXNba10ucGFyc2UpXG4gICAgaWYgKHR5cGVzW2tdLnNlcmlhbGl6ZSkge1xuICAgICAgYWNjLnNlcmlhbGl6ZXJzW3R5cGVzW2tdLnRvXSA9IHR5cGVzW2tdLnNlcmlhbGl6ZVxuICAgICAgdHlwZXNba10uZnJvbSAmJiBbXS5jb25jYXQodHlwZXNba10uZnJvbSkuZm9yRWFjaCh4ID0+IGFjYy5zZXJpYWxpemVyc1t4XSA9IHR5cGVzW2tdLnNlcmlhbGl6ZSlcbiAgICB9XG4gICAgcmV0dXJuIGFjY1xuICB9LCB7IHBhcnNlcnM6IHt9LCBzZXJpYWxpemVyczoge30gfSlcbn1cblxuZnVuY3Rpb24gZXNjYXBlSWRlbnRpZmllcnMoeHMsIHsgdHJhbnNmb3JtOiB7IGNvbHVtbiB9IH0pIHtcbiAgcmV0dXJuIHhzLm1hcCh4ID0+IGVzY2FwZUlkZW50aWZpZXIoY29sdW1uLnRvID8gY29sdW1uLnRvKHgpIDogeCkpLmpvaW4oJywnKVxufVxuXG5leHBvcnQgY29uc3QgZXNjYXBlSWRlbnRpZmllciA9IGZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZSgvXCIvZywgJ1wiXCInKS5yZXBsYWNlKC9cXC4vZywgJ1wiLlwiJykgKyAnXCInXG59XG5cbmV4cG9ydCBjb25zdCBpbmZlclR5cGUgPSBmdW5jdGlvbiBpbmZlclR5cGUoeCkge1xuICByZXR1cm4gKFxuICAgIHggaW5zdGFuY2VvZiBQYXJhbWV0ZXIgPyB4LnR5cGUgOlxuICAgIHggaW5zdGFuY2VvZiBEYXRlID8gMTE4NCA6XG4gICAgeCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyAxNyA6XG4gICAgKHggPT09IHRydWUgfHwgeCA9PT0gZmFsc2UpID8gMTYgOlxuICAgIHR5cGVvZiB4ID09PSAnYmlnaW50JyA/IDIwIDpcbiAgICBBcnJheS5pc0FycmF5KHgpID8gaW5mZXJUeXBlKHhbMF0pIDpcbiAgICAwXG4gIClcbn1cblxuY29uc3QgZXNjYXBlQmFja3NsYXNoID0gL1xcXFwvZ1xuY29uc3QgZXNjYXBlUXVvdGUgPSAvXCIvZ1xuXG5mdW5jdGlvbiBhcnJheUVzY2FwZSh4KSB7XG4gIHJldHVybiB4XG4gICAgLnJlcGxhY2UoZXNjYXBlQmFja3NsYXNoLCAnXFxcXFxcXFwnKVxuICAgIC5yZXBsYWNlKGVzY2FwZVF1b3RlLCAnXFxcXFwiJylcbn1cblxuZXhwb3J0IGNvbnN0IGFycmF5U2VyaWFsaXplciA9IGZ1bmN0aW9uIGFycmF5U2VyaWFsaXplcih4cywgc2VyaWFsaXplciwgb3B0aW9ucywgdHlwYXJyYXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeHMpID09PSBmYWxzZSlcbiAgICByZXR1cm4geHNcblxuICBpZiAoIXhzLmxlbmd0aClcbiAgICByZXR1cm4gJ3t9J1xuXG4gIGNvbnN0IGZpcnN0ID0geHNbMF1cbiAgLy8gT25seSBfYm94ICgxMDIwKSBoYXMgdGhlICc7JyBkZWxpbWl0ZXIgZm9yIGFycmF5cywgYWxsIG90aGVyIHR5cGVzIHVzZSB0aGUgJywnIGRlbGltaXRlclxuICBjb25zdCBkZWxpbWl0ZXIgPSB0eXBhcnJheSA9PT0gMTAyMCA/ICc7JyA6ICcsJ1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSAmJiAhZmlyc3QudHlwZSlcbiAgICByZXR1cm4gJ3snICsgeHMubWFwKHggPT4gYXJyYXlTZXJpYWxpemVyKHgsIHNlcmlhbGl6ZXIsIG9wdGlvbnMsIHR5cGFycmF5KSkuam9pbihkZWxpbWl0ZXIpICsgJ30nXG5cbiAgcmV0dXJuICd7JyArIHhzLm1hcCh4ID0+IHtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB4ID0gb3B0aW9ucy50cmFuc2Zvcm0udW5kZWZpbmVkXG4gICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcnMuZ2VuZXJpYygnVU5ERUZJTkVEX1ZBTFVFJywgJ1VuZGVmaW5lZCB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkJylcbiAgICB9XG5cbiAgICByZXR1cm4geCA9PT0gbnVsbFxuICAgICAgPyAnbnVsbCdcbiAgICAgIDogJ1wiJyArIGFycmF5RXNjYXBlKHNlcmlhbGl6ZXIgPyBzZXJpYWxpemVyKHgudHlwZSA/IHgudmFsdWUgOiB4KSA6ICcnICsgeCkgKyAnXCInXG4gIH0pLmpvaW4oZGVsaW1pdGVyKSArICd9J1xufVxuXG5jb25zdCBhcnJheVBhcnNlclN0YXRlID0ge1xuICBpOiAwLFxuICBjaGFyOiBudWxsLFxuICBzdHI6ICcnLFxuICBxdW90ZWQ6IGZhbHNlLFxuICBsYXN0OiAwXG59XG5cbmV4cG9ydCBjb25zdCBhcnJheVBhcnNlciA9IGZ1bmN0aW9uIGFycmF5UGFyc2VyKHgsIHBhcnNlciwgdHlwYXJyYXkpIHtcbiAgYXJyYXlQYXJzZXJTdGF0ZS5pID0gYXJyYXlQYXJzZXJTdGF0ZS5sYXN0ID0gMFxuICByZXR1cm4gYXJyYXlQYXJzZXJMb29wKGFycmF5UGFyc2VyU3RhdGUsIHgsIHBhcnNlciwgdHlwYXJyYXkpXG59XG5cbmZ1bmN0aW9uIGFycmF5UGFyc2VyTG9vcChzLCB4LCBwYXJzZXIsIHR5cGFycmF5KSB7XG4gIGNvbnN0IHhzID0gW11cbiAgLy8gT25seSBfYm94ICgxMDIwKSBoYXMgdGhlICc7JyBkZWxpbWl0ZXIgZm9yIGFycmF5cywgYWxsIG90aGVyIHR5cGVzIHVzZSB0aGUgJywnIGRlbGltaXRlclxuICBjb25zdCBkZWxpbWl0ZXIgPSB0eXBhcnJheSA9PT0gMTAyMCA/ICc7JyA6ICcsJ1xuICBmb3IgKDsgcy5pIDwgeC5sZW5ndGg7IHMuaSsrKSB7XG4gICAgcy5jaGFyID0geFtzLmldXG4gICAgaWYgKHMucXVvdGVkKSB7XG4gICAgICBpZiAocy5jaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgcy5zdHIgKz0geFsrK3MuaV1cbiAgICAgIH0gZWxzZSBpZiAocy5jaGFyID09PSAnXCInKSB7XG4gICAgICAgIHhzLnB1c2gocGFyc2VyID8gcGFyc2VyKHMuc3RyKSA6IHMuc3RyKVxuICAgICAgICBzLnN0ciA9ICcnXG4gICAgICAgIHMucXVvdGVkID0geFtzLmkgKyAxXSA9PT0gJ1wiJ1xuICAgICAgICBzLmxhc3QgPSBzLmkgKyAyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnN0ciArPSBzLmNoYXJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHMuY2hhciA9PT0gJ1wiJykge1xuICAgICAgcy5xdW90ZWQgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChzLmNoYXIgPT09ICd7Jykge1xuICAgICAgcy5sYXN0ID0gKytzLmlcbiAgICAgIHhzLnB1c2goYXJyYXlQYXJzZXJMb29wKHMsIHgsIHBhcnNlciwgdHlwYXJyYXkpKVxuICAgIH0gZWxzZSBpZiAocy5jaGFyID09PSAnfScpIHtcbiAgICAgIHMucXVvdGVkID0gZmFsc2VcbiAgICAgIHMubGFzdCA8IHMuaSAmJiB4cy5wdXNoKHBhcnNlciA/IHBhcnNlcih4LnNsaWNlKHMubGFzdCwgcy5pKSkgOiB4LnNsaWNlKHMubGFzdCwgcy5pKSlcbiAgICAgIHMubGFzdCA9IHMuaSArIDFcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChzLmNoYXIgPT09IGRlbGltaXRlciAmJiBzLnAgIT09ICd9JyAmJiBzLnAgIT09ICdcIicpIHtcbiAgICAgIHhzLnB1c2gocGFyc2VyID8gcGFyc2VyKHguc2xpY2Uocy5sYXN0LCBzLmkpKSA6IHguc2xpY2Uocy5sYXN0LCBzLmkpKVxuICAgICAgcy5sYXN0ID0gcy5pICsgMVxuICAgIH1cbiAgICBzLnAgPSBzLmNoYXJcbiAgfVxuICBzLmxhc3QgPCBzLmkgJiYgeHMucHVzaChwYXJzZXIgPyBwYXJzZXIoeC5zbGljZShzLmxhc3QsIHMuaSArIDEpKSA6IHguc2xpY2Uocy5sYXN0LCBzLmkgKyAxKSlcbiAgcmV0dXJuIHhzXG59XG5cbmV4cG9ydCBjb25zdCB0b0NhbWVsID0geCA9PiB7XG4gIGxldCBzdHIgPSB4WzBdXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgeC5sZW5ndGg7IGkrKylcbiAgICBzdHIgKz0geFtpXSA9PT0gJ18nID8geFsrK2ldLnRvVXBwZXJDYXNlKCkgOiB4W2ldXG4gIHJldHVybiBzdHJcbn1cblxuZXhwb3J0IGNvbnN0IHRvUGFzY2FsID0geCA9PiB7XG4gIGxldCBzdHIgPSB4WzBdLnRvVXBwZXJDYXNlKClcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB4Lmxlbmd0aDsgaSsrKVxuICAgIHN0ciArPSB4W2ldID09PSAnXycgPyB4WysraV0udG9VcHBlckNhc2UoKSA6IHhbaV1cbiAgcmV0dXJuIHN0clxufVxuXG5leHBvcnQgY29uc3QgdG9LZWJhYiA9IHggPT4geC5yZXBsYWNlKC9fL2csICctJylcblxuZXhwb3J0IGNvbnN0IGZyb21DYW1lbCA9IHggPT4geC5yZXBsYWNlKC8oW0EtWl0pL2csICdfJDEnKS50b0xvd2VyQ2FzZSgpXG5leHBvcnQgY29uc3QgZnJvbVBhc2NhbCA9IHggPT4gKHguc2xpY2UoMCwgMSkgKyB4LnNsaWNlKDEpLnJlcGxhY2UoLyhbQS1aXSkvZywgJ18kMScpKS50b0xvd2VyQ2FzZSgpXG5leHBvcnQgY29uc3QgZnJvbUtlYmFiID0geCA9PiB4LnJlcGxhY2UoLy0vZywgJ18nKVxuXG5mdW5jdGlvbiBjcmVhdGVKc29uVHJhbnNmb3JtKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBqc29uVHJhbnNmb3JtKHgsIGNvbHVtbikge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAoY29sdW1uLnR5cGUgPT09IDExNCB8fCBjb2x1bW4udHlwZSA9PT0gMzgwMilcbiAgICAgID8gQXJyYXkuaXNBcnJheSh4KVxuICAgICAgICA/IHgubWFwKHggPT4ganNvblRyYW5zZm9ybSh4LCBjb2x1bW4pKVxuICAgICAgICA6IE9iamVjdC5lbnRyaWVzKHgpLnJlZHVjZSgoYWNjLCBbaywgdl0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7IFtmbihrKV06IGpzb25UcmFuc2Zvcm0odiwgY29sdW1uKSB9KSwge30pXG4gICAgICA6IHhcbiAgfVxufVxuXG50b0NhbWVsLmNvbHVtbiA9IHsgZnJvbTogdG9DYW1lbCB9XG50b0NhbWVsLnZhbHVlID0geyBmcm9tOiBjcmVhdGVKc29uVHJhbnNmb3JtKHRvQ2FtZWwpIH1cbmZyb21DYW1lbC5jb2x1bW4gPSB7IHRvOiBmcm9tQ2FtZWwgfVxuXG5leHBvcnQgY29uc3QgY2FtZWwgPSB7IC4uLnRvQ2FtZWwgfVxuY2FtZWwuY29sdW1uLnRvID0gZnJvbUNhbWVsXG5cbnRvUGFzY2FsLmNvbHVtbiA9IHsgZnJvbTogdG9QYXNjYWwgfVxudG9QYXNjYWwudmFsdWUgPSB7IGZyb206IGNyZWF0ZUpzb25UcmFuc2Zvcm0odG9QYXNjYWwpIH1cbmZyb21QYXNjYWwuY29sdW1uID0geyB0bzogZnJvbVBhc2NhbCB9XG5cbmV4cG9ydCBjb25zdCBwYXNjYWwgPSB7IC4uLnRvUGFzY2FsIH1cbnBhc2NhbC5jb2x1bW4udG8gPSBmcm9tUGFzY2FsXG5cbnRvS2ViYWIuY29sdW1uID0geyBmcm9tOiB0b0tlYmFiIH1cbnRvS2ViYWIudmFsdWUgPSB7IGZyb206IGNyZWF0ZUpzb25UcmFuc2Zvcm0odG9LZWJhYikgfVxuZnJvbUtlYmFiLmNvbHVtbiA9IHsgdG86IGZyb21LZWJhYiB9XG5cbmV4cG9ydCBjb25zdCBrZWJhYiA9IHsgLi4udG9LZWJhYiB9XG5rZWJhYi5jb2x1bW4udG8gPSBmcm9tS2ViYWJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres/src/types.js\n");

/***/ })

};
;